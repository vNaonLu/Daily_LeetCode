#include <gtest/gtest.h>
#include <iostream>
#include <numeric>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 918.
 *      Maximum Sum Circular Subarray
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a “circular integer array” ‘nums’ of length ‘n’ , return “the
 *   maximum possible sum of a non-empty “subarray” of ” ‘nums’
 *   A “circular array” means the end of the array connects to the
 *   beginning of the array. Formally, the next element of ‘nums[i]’ is
 *   ‘nums[(i + 1) % n]’ and the previous element of ‘nums[i]’ is ‘nums[(i
 *   - 1 + n) % n]’
 *   A “subarray” may only include each element of the fixed buffer ‘nums’
 *   at most once. Formally, for a subarray ‘nums[i], nums[i + 1], ...,
 *   nums[j]’ , there does not exist ‘i ≤ k1’ , ‘k2 ≤ j’ with ‘k1 % n = k2
 *   % n’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = nums.length’
 *   • ‘1 ≤ n ≤ 3 × 10⁴’
 *   • ‘-3 × 10⁴ ≤ nums[i] ≤ 3 × 10⁴’
 *
 */

struct q918 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    int kadane(vector<int>::iterator beg, vector<int>::iterator end, int sign) {
      if (beg == end) return 0;
      int res = *beg * sign,
          lmx = *beg * sign;
      ++beg;
      while (beg != end) {
        lmx = *(beg++) * sign + max(0, lmx);
        res = max(res, lmx);
      }
      return res;
    }
   public:
    int maxSubarraySumCircular(vector<int>& nums) {
      int sum = accumulate(nums.begin(), nums.end(), 0);
      return max({kadane(nums.begin(), nums.end(), 1),
                  sum + kadane(nums.begin() + 1, nums.end(), -1),
                  sum + kadane(nums.begin(), nums.end() - 1, -1)});
    }
  };

  class Solution *solution;
};

TEST_F(q918, sample_input01) {
  solution = new Solution();
  vector<int> nums = {1, -2, 3, -2};
  int exp = 3;
  EXPECT_EQ(solution->maxSubarraySumCircular(nums), exp);
  delete solution;
}

TEST_F(q918, sample_input02) {
  solution = new Solution();
  vector<int> nums = {5, -3, 5};
  int exp = 10;
  EXPECT_EQ(solution->maxSubarraySumCircular(nums), exp);
  delete solution;
}

TEST_F(q918, sample_input03) {
  solution = new Solution();
  vector<int> nums = {3, -1, 2, -1};
  int exp = 4;
  EXPECT_EQ(solution->maxSubarraySumCircular(nums), exp);
  delete solution;
}

TEST_F(q918, sample_input04) {
  solution = new Solution();
  vector<int> nums = {3, -2, 2, -3};
  int exp = 3;
  EXPECT_EQ(solution->maxSubarraySumCircular(nums), exp);
  delete solution;
}

TEST_F(q918, sample_input05) {
  solution = new Solution();
  vector<int> nums = {-2, -3, -1};
  int exp = -1;
  EXPECT_EQ(solution->maxSubarraySumCircular(nums), exp);
  delete solution;
}