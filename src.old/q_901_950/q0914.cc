#include <gtest/gtest.h>
#include <iostream>
#include <numeric>
#include <unordered_map>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 914.
 *      X of a Kind in a Deck of Cards
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given an integer array ‘deck’ where ‘deck[i]’ represents the
 *   number written on the ‘iᵗʰ’
 *   Partition the cards into “one or more groups” such
 *       - Each group has “exactly” ‘x’ cards where ‘x > 1’ ,
 *       - All the cards in one group have the same integer written on
 *   Return ‘true’ “ if such partition is possible, or ” ‘false’ “
 *   otherwise” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ deck.length ≤ 10⁴’
 *   • ‘0 ≤ deck[i] < 10⁴’
 *
 */

struct q914 : public ::testing::Test {
  // Leetcode answer here
class Solution {
public:
  bool hasGroupsSizeX(vector<int>& deck) {
    auto freq = unordered_map<int, int>();   
    for (auto x : deck) {
      ++freq[x];
    }

    auto min_cnt = (int)deck.size();
    for (auto &x : freq) {
      min_cnt = min(min_cnt, x.second);
    }

    if (min_cnt < 2) {
      return false;
    }

    auto gcds = unordered_set<int>();
    for (auto &x : freq) {
      auto cur = gcd(x.second, min_cnt);
      if (cur == 1) {
        return false;
      }

      for (auto g : gcds) {
        if (gcd(g, cur) == 1) {
          return false;
        }
      }
      gcds.emplace(cur);
    }

    return true;
  }
};

  class Solution *solution;
};

TEST_F(q914, sample_input01) {
  solution         = new Solution();
  vector<int> deck = {1, 2, 3, 4, 4, 3, 2, 1};
  bool        exp  = true;
  bool        act  = solution->hasGroupsSizeX(deck);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q914, sample_input02) {
  solution         = new Solution();
  vector<int> deck = {1, 1, 1, 2, 2, 2, 3, 3};
  bool        exp  = false;
  bool        act  = solution->hasGroupsSizeX(deck);
  EXPECT_EQ(act, exp);
  delete solution;
}