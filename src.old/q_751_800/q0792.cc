#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 792.
 *      Number of Matching Subsequences
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a string ‘s’ and an array of strings ‘words’ , return “the
 *   number of” ‘words[i]’ “that is a subsequence of” ‘s’
 *   A “subsequence” of a string is a new string generated from the
 *   original string with some characters (can be none) deleted without
 *   changing the relative order of the remaining
 *       - For example, ‘'ace'’ is a subsequence of ‘'abcde'’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ s.length ≤ 5 × 10⁴’
 *   • ‘1 ≤ words.length ≤ 5000’
 *   • ‘1 ≤ words[i].length ≤ 50’
 *   • ‘s’ and ‘words[i]’ consist of only lowercase English letters.
 *
 */

struct q792 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    int numMatchingSubseq(string s, vector<string> &words) {
      vector<vector<int>> dict(26);
      for (size_t i = 0; i < s.size(); ++i) {
        dict[s[i] - 'a'].emplace_back(i);
      }

      int res = 0;
      for (auto &w : words) {
        int curr_idx = -1;
        auto it = w.begin();
        while (it != w.end()) {
          auto &d = dict[*it - 'a'];
          auto find = upper_bound(d.begin(), d.end(), curr_idx);
          if (find == d.end()) {
            break;
          } else {
            ++it;
            curr_idx = *find;
          }
        }

        if (it == w.end()) {
          ++res;
        }
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q792, sample_input01) {
  solution = new Solution();
  string s = "abcde";
  vector<string> words = {"a", "bb", "acd", "ace"};
  int exp = 3;
  int act = solution->numMatchingSubseq(s, words);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q792, sample_input02) {
  solution = new Solution();
  string s = "dsahjpjauf";
  vector<string> words = {"ahjpjau", "ja", "ahbwzgqnuk", "tnmlanowax"};
  int exp = 2;
  int act = solution->numMatchingSubseq(s, words);
  EXPECT_EQ(act, exp);
  delete solution;
}