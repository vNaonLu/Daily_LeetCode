#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 785.
 *      Is Graph Bipartite?
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   There is an “undirected” graph with ‘n’ nodes, where each node is
 *   numbered between ‘0’ and ‘n - 1’ . You are given a 2D array ‘graph’ ,
 *   where ‘graph[u]’ is an array of nodes that node ‘u’ is adjacent to.
 *   More formally, for each ‘v’ in ‘graph[u]’ , there is an undirected
 *   edge between node ‘u’ and node ‘v’ . The graph has the following
 *       - There are no self-edges ( ‘graph[u]’ does not contain ‘u’
 *       - There are no parallel edges ( ‘graph[u]’ does not contain
 *   duplicate
 *       - If ‘v’ is in ‘graph[u]’ , then ‘u’ is in ‘graph[v]’ (the graph
 *   is
 *       - The graph may not be connected, meaning there may be two nodes
 *   ‘u’ and ‘v’ such that there is no path between
 *   A graph is “bipartite” if the nodes can be partitioned into two
 *   independent sets ‘A’ and ‘B’ such that “every” edge in the graph
 *   connects a node in set ‘A’ and a node in set ‘B’
 *   Return ‘true’ “ if and only if it is “bipartite” ” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘graph.length = n’
 *   • ‘1 ≤ n ≤ 100’
 *   • ‘0 ≤ graph[u].length < n’
 *   • ‘0 ≤ graph[u][i] ≤ n - 1’
 *   • ‘graph[u]’ does not contain ‘u’ .
 *   • All the values of ‘graph[u]’ are “unique” .
 *   • If ‘graph[u]’ contains ‘v’ , then ‘graph[v]’ contains ‘u’ .
 *
 */

struct q785 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    bool isBipartite(vector<vector<int>> &graph) {
      int n = graph.size();

      vector<int> grouped(n, false),
                  visited(n, false);

      for (int i = 0; i < n; ++i) {
        if (visited[i]) continue;

        queue<int> q;
        q.emplace(i);

        while (!q.empty()) {
          auto x = q.front(); q.pop();

          for (auto &y : graph[x]) {
            if (visited[y]) {
              if (grouped[x] == grouped[y]) {
                return false;
              }
            } else {
              visited[y] = true;
              grouped[y] = !grouped[x];
              q.emplace(y);
            }
          }
        }
      }
      return true;
    }
  };

  class Solution *solution;
};

TEST_F(q785, sample_input01) {
  solution = new Solution();
  vector<vector<int>> graph = {{1, 2, 3}, {0, 2}, {0, 1, 3}, {0, 2}};
  bool exp = false;
  bool act = solution->isBipartite(graph);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q785, sample_input02) {
  solution = new Solution();
  vector<vector<int>> graph = {{1, 3}, {0, 2}, {1, 3}, {0, 2}};
  bool exp = true;
  bool act = solution->isBipartite(graph);
  EXPECT_EQ(act, exp);
  delete solution;
}