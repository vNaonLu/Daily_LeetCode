#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 826.
 *      Most Profit Assigning Work
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You have ‘n’ jobs and ‘m’ workers. You are given three arrays:
 *   ‘difficulty’ , ‘profit’ , and ‘worker’
 *       -  ‘difficulty[i]’ and ‘profit[i]’ are the difficulty and the
 *   profit of the ‘iᵗʰ’ job,
 *       -  ‘worker[j]’ is the ability of ‘jᵗʰ’ worker (i.e., the ‘jᵗʰ’
 *   worker can only complete a job with difficulty at most ‘worker[j]’
 *   Every worker can be assigned “at most one job” , but one job can be
 *   “completed multiple times”
 *       - For example, if three workers attempt the same job that pays
 *   ‘$1’ , then the total profit will be ‘$3’ . If a worker cannot
 *   complete any job, their profit is ‘$0’
 *   Return the maximum profit we can achieve after assigning the workers
 *   to the jobs.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = difficulty.length’
 *   • ‘n = profit.length’
 *   • ‘m = worker.length’
 *   • ‘1 ≤ n, m ≤ 10⁴’
 *   • ‘1 ≤ difficulty[i], profit[i], worker[i] ≤ 10⁵’
 *
 */

struct q826 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    int maxProfitAssignment(vector<int> &difficulty, vector<int> &profit, vector<int> &worker) {
      auto cmp = [](pair<int, int> const &a, pair<int, int> const &b) {
        return a.first > b.first;
      };
      priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);
      for (int i = 0; i < difficulty.size(); ++i) {
        pq.emplace(difficulty[i], profit[i]);
      }

      sort(worker.begin(), worker.end());
      int res = 0, best = 0;
      for (auto &skill : worker) {
        while (!pq.empty()) {
          auto x = pq.top();
          if (skill < x.first) {
            break;
          } else {
            pq.pop();
            best = max(best, x.second);
          }
        }
        res += best;
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q826, sample_input01) {
  solution = new Solution();
  vector<int> difficulty = {2, 4, 6, 8, 10};
  vector<int> profit = {10, 20, 30, 40, 50};
  vector<int> worker = {4, 5, 6, 7};
  int exp = 100;
  int act = solution->maxProfitAssignment(difficulty, profit, worker);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q826, sample_input02) {
  solution = new Solution();
  vector<int> difficulty = {85, 47, 57};
  vector<int> profit = {24, 66, 99};
  vector<int> worker = {40, 25, 25};
  int exp = 0;
  int act = solution->maxProfitAssignment(difficulty, profit, worker);
  EXPECT_EQ(act, exp);
  delete solution;
}