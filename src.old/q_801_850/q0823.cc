#include <gtest/gtest.h>
#include <iostream>
#include <unordered_map>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 823.
 *      Binary Trees With Factors
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an array of unique integers, ‘arr’ , where each integer ‘arr[i]’
 *   is strictly greater than ‘1’
 *   We make a binary tree using these integers, and each number may be
 *   used for any number of times. Each non-leaf node's value should be
 *   equal to the product of the values of its
 *   Return “the number of binary trees we can make” . The answer may be
 *   too large so return the answer “modulo” ‘10⁹ + 7’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ arr.length ≤ 1000’
 *   • ‘2 ≤ arr[i] ≤ 10⁹’
 *   • All the values of ‘arr’ are “unique” .
 *
 */

struct q823 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    inline constexpr static int kMod = 1e9 + 7;

  public:
    int numFactoredBinaryTrees(vector<int> &arr) {
      sort(arr.begin(), arr.end());
      auto res = int64_t(0);
      auto dp = vector<int64_t>(arr.size(), 1);
      auto index = unordered_map<int, int>();

      for (int i = 0; i < dp.size(); ++i) {
        index[arr[i]] = i;
        for (int j = 0; j < i; ++j) {
          if (arr[i] % arr[j] == 0) {
            int r = arr[i] / arr[j];
            if (index.count(r)) {
              dp[i] = (dp[i] + dp[j] * dp[index[r]]) % kMod;
            }
          }
        }
      }

      for (auto &x : dp) {
        res += x;
        res %= kMod;
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q823, sample_input01) {
  solution = new Solution();
  vector<int> arr = {2, 4};
  int exp = 3;
  int act = solution->numFactoredBinaryTrees(arr);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q823, sample_input02) {
  solution = new Solution();
  vector<int> arr = {2, 4, 5, 10};
  int exp = 7;
  int act = solution->numFactoredBinaryTrees(arr);
  EXPECT_EQ(act, exp);
  delete solution;
}