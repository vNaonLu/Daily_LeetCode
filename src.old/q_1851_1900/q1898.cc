#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1898.
 *       Maximum Number of Removable Characters
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given two strings ‘s’ and ‘p’ where ‘p’ is a “subsequence ” of
 *   ‘s’ . You are also given a “distinct 0-indexed ” integer array
 *   ‘removable’ containing a subset of indices of ‘s’ ( ‘s’ is also
 *   “0-indexed”
 *   You want to choose an integer ‘k’ ( ‘0 ≤ k ≤ removable.length’ ) such
 *   that, after removing ‘k’ characters from ‘s’ using the “first” ‘k’
 *   indices in ‘removable’ , ‘p’ is still a “subsequence” of ‘s’ . More
 *   formally, you will mark the character at ‘s[removable[i]]’ for each ‘0
 *   ≤ i < k’ , then remove all marked characters and check if ‘p’ is still
 *   a
 *   Return “the “maximum” ” ‘k’ “ you can choose such that ” ‘p’ “ is
 *   still a “subsequence” of ” ‘s’ “ after the removals”
 *   A “subsequence” of a string is a new string generated from the
 *   original string with some characters (can be none) deleted without
 *   changing the relative order of the remaining characters.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ p.length ≤ s.length ≤ 10⁵’
 *   • ‘0 ≤ removable.length < s.length’
 *   • ‘0 ≤ removable[i] < s.length’
 *   • ‘p’ is a “subsequence” of ‘s’ .
 *   • ‘s’ and ‘p’ both consist of lowercase English letters.
 *   • The elements in ‘removable’ are “distinct” .
 *
 */

struct q1898 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    bool helper(string s, string &p, int mid, vector<int> &rm) {
      for (int i = 0; i < mid; ++i) {
        s[rm[i]] = ' ';
      }
      int j = 0;
      auto it = s.begin();
      auto pit = p.begin();
      while (it != s.end() && pit != p.end()) {
        if (*it++ == *pit) {
          ++pit;
        }
      }

      return pit == p.end();
    }

  public:
    int maximumRemovals(string s, string p, vector<int> &removable) {
      int res = 0;
      int lo = 0, hi = removable.size();

      while (lo <= hi) {
        auto mid = lo + (hi - lo) / 2;
        if (helper(s, p, mid, removable)) {
          res = max(res, mid);
          lo = mid + 1;
        } else {
          hi = mid - 1;
        }
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1898, sample_input01) {
  solution = new Solution();
  string s = "abcacb";
  string p = "ab";
  vector<int> removable = {3, 1, 0};
  int exp = 2;
  int act = solution->maximumRemovals(s, p, removable);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1898, sample_input02) {
  solution = new Solution();
  string s = "abcbddddd";
  string p = "abcd";
  vector<int> removable = {3, 2, 1, 4, 5, 6};
  int exp = 1;
  int act = solution->maximumRemovals(s, p, removable);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1898, sample_input03) {
  solution = new Solution();
  string s = "abcab";
  string p = "abc";
  vector<int> removable = {0, 1, 2, 3, 4};
  int exp = 0;
  int act = solution->maximumRemovals(s, p, removable);
  EXPECT_EQ(act, exp);
  delete solution;
}