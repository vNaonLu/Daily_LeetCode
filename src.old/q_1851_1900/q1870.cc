#include <cmath>
#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1870.
 *       Minimum Speed to Arrive on Time
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given a floating-point number ‘hour’ , representing the amount
 *   of time you have to reach the office. To commute to the office, you
 *   must take ‘n’ trains in sequential order. You are also given an
 *   integer array ‘dist’ of length ‘n’ , where ‘dist[i]’ describes the
 *   distance (in kilometers) of the ‘iᵗʰ’ train
 *   Each train can only depart at an integer hour, so you may need to wait
 *   in between each train
 *       - For example, if the ‘1ˢᵗ’ train ride takes ‘1.5’ hours, you must
 *   wait for an additional ‘0.5’ hours before you can depart on the ‘2ⁿᵈ’
 *   train ride at the 2 hour
 *   Return “the “minimum positive integer” speed “(in kilometers per
 *   hour)” that all the trains must travel at for you to reach the office
 *   on time, or ” ‘-1’ “ if it is impossible to be on time”
 *   Tests are generated such that the answer will not exceed ‘10⁷’ and
 *   ‘hour’ will have “at most two digits after the decimal point” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = dist.length’
 *   • ‘1 ≤ n ≤ 10⁵’
 *   • ‘1 ≤ dist[i] ≤ 10⁵’
 *   • ‘1 ≤ hour ≤ 10⁹’
 *   • There will be at most two digits after the decimal point in ‘hour’ .
 *
 */

struct q1870 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    double helper(vector<int> &d, int m) {
      double res = 0;
      for (int i = 0; i < d.size(); ++i) {
        double k = d[i];
        k /= m;
        res += i == d.size() - 1 ? k : ceil(k);
      }

      return res;
    }

  public:
    int minSpeedOnTime(vector<int> &dist, double hour) {
      if (dist.size() - 1 >= hour) {

        return -1;
      }

      int lo = 1, hi = numeric_limits<int>::max() - 1;
      while (lo <= hi) {
        auto mid = lo + (hi - lo) / 2;
        auto spend = helper(dist, mid);

        if (spend == hour) {
          return mid;
        } else if (spend > hour) {
          lo = mid + 1;
        } else {
          hi = mid - 1;
        }
      }

      return lo;
    }
  };

  class Solution *solution;
};

TEST_F(q1870, sample_input01) {
  solution = new Solution();
  vector<int> dist = {1, 3, 2};
  double hour = 6;
  int exp = 1;
  int act = solution->minSpeedOnTime(dist, hour);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1870, sample_input02) {
  solution = new Solution();
  vector<int> dist = {1, 3, 2};
  double hour = 2.7;
  int exp = 3;
  int act = solution->minSpeedOnTime(dist, hour);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1870, sample_input03) {
  solution = new Solution();
  vector<int> dist = {1, 3, 2};
  double hour = 1.9;
  int exp = -1;
  int act = solution->minSpeedOnTime(dist, hour);
  EXPECT_EQ(act, exp);
  delete solution;
}