#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1191.
 *       K-Concatenation Maximum Sum
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an integer array ‘arr’ and an integer ‘k’ , modify the array by
 *   repeating it ‘k’
 *   For example, if ‘arr = [1, 2]’ and ‘k = 3 ’ then the modified array
 *   will be ‘[1, 2, 1, 2, 1, 2]’
 *   Return the maximum sub-array sum in the modified array. Note that the
 *   length of the sub-array can be ‘0’ and its sum in that case is ‘0’
 *   As the answer can be very large, return the answer “modulo” ‘10⁹ + 7’ 
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ arr.length ≤ 10⁵’
 *   • ‘1 ≤ k ≤ 10⁵’
 *   • ‘-10⁴ ≤ arr[i] ≤ 10⁴’
 *
 */

struct q1191 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    constexpr static inline int kMod = 1e9 + 7;
    int kadane(vector<int> &arr) {
      int sum = 0,
          res = 0;
      for (const auto &x : arr) {
        sum = max(sum, 0) + x;
        res = max(res, sum);
      }
      return res;
    }

   public:
    int kConcatenationMaxSum(vector<int> &arr, int k) {
      if (k == 1) return kadane(arr) % kMod;
      int sum = 0,
          n = arr.size();
      for (const auto &x : arr) sum = (sum + x) % kMod;

      arr.reserve(2 * arr.size());
      for (int i = 0; i < n; ++i) {
        arr.push_back(arr[i]);
      }

      int res = kadane(arr);
      if (sum <= 0) return res;
      else          return (res + long(k - 2) * sum) % kMod;
    }
  };

  class Solution *solution;
};

TEST_F(q1191, sample_input01) {
  solution = new Solution();
  vector<int> arr = {1, 2};
  int k = 3;
  int exp = 9;
  int act = solution->kConcatenationMaxSum(arr, k);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1191, sample_input02) {
  solution = new Solution();
  vector<int> arr = {1, -2, 1};
  int k = 5;
  int exp = 2;
  int act = solution->kConcatenationMaxSum(arr, k);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1191, sample_input03) {
  solution = new Solution();
  vector<int> arr = {-1, -2};
  int k = 7;
  int exp = 0;
  int act = solution->kConcatenationMaxSum(arr, k);
  EXPECT_EQ(act, exp);
  delete solution;
}