#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1160.
 *       Find Words That Can Be Formed by Characters
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given an array of strings ‘words’ and a string ‘chars’
 *   A string is “good” if it can be formed by characters from chars (each
 *   character can only be used
 *   Return “the sum of lengths of all good strings in words” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ words.length ≤ 1000’
 *   • ‘1 ≤ words[i].length, chars.length ≤ 100’
 *   • ‘words[i]’ and ‘chars’ consist of lowercase English letters.
 *
 */

struct q1160 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    int countCharacters(vector<string> &words, string chars) {
      auto freq = vector<int>(26, 0);
      auto res  = (int)0;
      for (auto c : chars) {
        ++freq[c - 'a'];
      }
      for (auto &w : words) {
        auto can_form = true;
        auto cnt      = unordered_map<char, int>();
        for (auto c : w) {
          if (freq[c - 'a'] < ++cnt[c]) {
            can_form = false;
            break;
          }
        }
        if (can_form) {
          res += w.size();
        }
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1160, sample_input01) {
  solution             = new Solution();
  vector<string> words = {"cat", "bt", "hat", "tree"};
  string         chars = "atach";
  int            exp   = 6;
  int            act   = solution->countCharacters(words, chars);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1160, sample_input02) {
  solution             = new Solution();
  vector<string> words = {"hello", "world", "leetcode"};
  string         chars = "welldonehoneyr";
  int            exp   = 10;
  int            act   = solution->countCharacters(words, chars);
  EXPECT_EQ(act, exp);
  delete solution;
}