#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 1178.
 *       Number of Valid Words for Each Puzzle
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   With respect to a given ‘puzzle’ string, a ‘word’ is “valid” if both
 *   the following conditions are
 *       -  ‘word’ contains the first letter of ‘puzzle’
 *       - For each letter in ‘word’ , that letter is in ‘puzzle’
 *           - For example, if the puzzle is ‘'abcdefg'’ , then valid words
 *   are ‘'faced'’ , ‘'cabbage'’ , and ‘'baggage'’ ,
 *           - invalid words are ‘'beefed'’ (does not include ‘'a'’ ) and
 *   ‘'based'’ (includes ‘'s'’ which is not in the
 *      
 *   Return “an array ” ‘answer’ “, where ” ‘answer[i]’ “ is the number of
 *   words in the given word list ” ‘words’ “ that is valid with respect to
 *   the puzzle ” ‘puzzles[i]’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ words.length ≤ 10⁵’
 *   • ‘4 ≤ words[i].length ≤ 50’
 *   • ‘1 ≤ puzzles.length ≤ 10⁴’
 *   • ‘puzzles[i].length = 7’
 *   • ‘words[i]’ and ‘puzzles[i]’ consist of lowercase English letters.
 *   • Each ‘puzzles[i] ’ does not contain repeated characters.
 *
 */

struct q1178 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    constexpr static size_t kCharacterSize = 26;
    vector<vector<int>>     trie;
    vector<int>             count;
    int dfs_search(const string &p, int node, bool hasFirst) {
      int res = hasFirst ? count[node] : 0;
      for (const auto &c : p) {
        int i = c - 'a';
        if (trie[node][i]) {
          res += dfs_search(p, trie[node][i], hasFirst || c == p[0]);
        }
      }
      return res;
    }
   public:
    vector<int> findNumOfValidWords(vector<string> &words, vector<string> &puzzles) {
      vector<int> res;
      trie = {vector<int>(kCharacterSize)};
      count = {0};
      for (string s : words) {
        sort(s.begin(), s.end());
        s.erase(unique(s.begin(), s.end()), s.end());
        if (s.size() <= 7) {
          int node = 0;
          for (const auto &c : s) {
            int i = c - 'a';
            if (trie[node][i] == 0) {
              trie[node][i] = trie.size();
              trie.emplace_back(kCharacterSize);
              count.emplace_back(0);
            }
            node = trie[node][i];
          }
          ++count[node];
        }
      }
      for (const auto &p : puzzles)
        res.emplace_back(dfs_search(p, 0, false));
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1178, sample_input01) {
  solution = new Solution();
  vector<string> words = {"aaaa", "asas", "able", "ability", "actt", "actor", "access"};
  vector<string> puzzles = {"aboveyz", "abrodyz", "abslute", "absoryz", "actresz", "gaswxyz"};
  vector<int> exp = {1, 1, 3, 2, 4, 0};
  EXPECT_EQ(solution->findNumOfValidWords(words, puzzles), exp);
  delete solution;
}

TEST_F(q1178, sample_input02) {
  solution = new Solution();
  vector<string> words = {"apple", "pleas", "please"};
  vector<string> puzzles = {"aelwxyz", "aelpxyz", "aelpsxy", "saelpxy", "xaelpsy"};
  vector<int> exp = {0, 1, 3, 2, 0};
  EXPECT_EQ(solution->findNumOfValidWords(words, puzzles), exp);
  delete solution;
}