#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/anyorder.hpp>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1192.
 *       Critical Connections in a Network
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   There are ‘n’ servers numbered from ‘0’ to ‘n - 1’ connected by
 *   undirected server-to-server ‘connections’ forming a network where
 *   ‘connections[i] = [aᵢ, bᵢ]’ represents a connection between servers
 *   ‘aᵢ’ and ‘bᵢ’ . Any server can reach other servers directly or
 *   indirectly through the
 *   A “critical connection” is a connection that, if removed, will make
 *   some servers unable to reach some other
 *   Return all critical connections in the network in any order.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘2 ≤ n ≤ 10⁵’
 *   • ‘n - 1 ≤ connections.length ≤ 10⁵’
 *   • ‘0 ≤ aᵢ, bᵢ ≤ n - 1’
 *   • ‘aᵢ ≠ bᵢ’
 *   • There are no repeated connections.
 *
 */

struct q1192 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    vector<vector<int>> res;
    vector<vector<int>> graph;

    vector<int> first_time, min_time, visited;
    int time = 1;

    void helper(int node, int parent = -1) {
      first_time[node] = min_time[node] = time++;
      visited[node] = true;

      for (auto next : graph[node]) {
        if (next == parent) {
          continue;
        }

        if (!visited[next]) {
          helper(next, node);
        }

        min_time[node] = min(min_time[node], min_time[next]);

        if (first_time[node] < min_time[next]) {
          res.emplace_back(vector<int>{node, next});
        }
      }
    }

   public:
    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {
      first_time.resize(n, 0);
      min_time.resize(n, 0);
      visited.resize(n, 0);
      graph.resize(n);

      for (auto& b : connections) {
        graph[b[0]].emplace_back(b[1]);
        graph[b[1]].emplace_back(b[0]);
      }

      helper(0);

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1192, sample_input01) {
  solution = new Solution();
  int n = 4;
  vector<vector<int>> connections = {{0, 1}, {1, 2}, {2, 0}, {1, 3}};
  vector<vector<int>> exp = {{1, 3}};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->criticalConnections(n, connections), exp);
  delete solution;
}

TEST_F(q1192, sample_input02) {
  solution = new Solution();
  int n = 2;
  vector<vector<int>> connections = {{0, 1}};
  vector<vector<int>> exp = {{0, 1}};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->criticalConnections(n, connections), exp);
  delete solution;
}