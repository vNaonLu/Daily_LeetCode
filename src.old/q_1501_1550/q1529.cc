#include <gtest/gtest.h>
#include <iostream>
#include <string>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1529.
 *       Minimum Suffix Flips
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given a “0-indexed” binary string ‘target’ of length ‘n’ . You
 *   have another binary string ‘s’ of length ‘n’ that is initially set to
 *   all zeros. You want to make ‘s’ equal to ‘target’
 *   In one operation, you can pick an index ‘i’ where ‘0 ≤ i < n’ and flip
 *   all bits in the “inclusive” range ‘[i, n - 1]’ . Flip means changing
 *   ‘'0'’ to ‘'1'’ and ‘'1'’ to ‘'0'’
 *   Return “the minimum number of operations needed to make ” ‘s’ “ equal
 *   to ” ‘target’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = target.length’
 *   • ‘1 ≤ n ≤ 10⁵’
 *   • ‘target[i]’ is either ‘'0'’ or ‘'1'’ .
 *
 */

struct q1529 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int minFlips(string target) {
      int res = 0;
      char curr = '0';
      for (auto it = target.begin(); it != target.end(); ++it) {
        if (*it != curr) {
          curr = *it;
          ++res;
        }
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1529, sample_input01) {
  solution = new Solution();
  string target = "10111";
  int exp = 3;
  int act = solution->minFlips(target);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1529, sample_input02) {
  solution = new Solution();
  string target = "101";
  int exp = 3;
  int act = solution->minFlips(target);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1529, sample_input03) {
  solution = new Solution();
  string target = "00000";
  int exp = 0;
  int act = solution->minFlips(target);
  EXPECT_EQ(act, exp);
  delete solution;
}