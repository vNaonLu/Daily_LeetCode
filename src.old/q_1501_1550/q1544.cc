#include <gtest/gtest.h>
#include <iostream>
#include <string>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1544.
 *       Make The String Great
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a string ‘s’ of lower and upper case English
 *   A good string is a string which doesn't have “two adjacent characters”
 *   ‘s[i]’ and ‘s[i + 1]’
 *       -  ‘0 ≤ i ≤ s.length - 2’
 *       -  ‘s[i]’ is a lower-case letter and ‘s[i + 1]’ is the same letter
 *   but in upper-case or “vice-versa”
 *   To make the string good, you can choose “two adjacent” characters that
 *   make the string bad and remove them. You can keep doing this until the
 *   string becomes
 *   Return “the string” after making it good. The answer is guaranteed to
 *   be unique under the given
 *    “Notice” that an empty string is also good.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ s.length ≤ 100’
 *   • ‘s’ contains only lower and upper case English letters.
 *
 */

struct q1544 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    string makeGood(string s) {
      auto res = string();
      res.reserve(s.size());
      for (auto c : s) {
        if (res.empty()) {
          res.push_back(c);
        } else {
          auto prev = res.back();
          if ((c >= 'a' && c <= 'z' && prev >= 'A' && prev <= 'Z' &&
               prev - 'A' == c - 'a') ||
              (c >= 'A' && c <= 'Z' && prev >= 'a' && prev <= 'z' &&
               prev - 'a' == c - 'A')) {
            res.pop_back();
          } else {
            res.push_back(c);
          }
        }
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1544, sample_input01) {
  solution   = new Solution();
  string s   = "leEeetcode";
  string exp = "leetcode";
  string act = solution->makeGood(s);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1544, sample_input02) {
  solution   = new Solution();
  string s   = "abBAcC";
  string exp = "";
  string act = solution->makeGood(s);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1544, sample_input03) {
  solution   = new Solution();
  string s   = "s";
  string exp = "s";
  string act = solution->makeGood(s);
  EXPECT_EQ(act, exp);
  delete solution;
}