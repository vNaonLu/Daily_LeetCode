#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 1254.
 *       Number of Closed Islands
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a 2D ‘grid’ consists of ‘0s’ (land)and ‘1s’ (water). An “island”
 *   is a maximal 4-directionally connected group of ‘<font
 *   face="monospace">0</font>s’ and a “closed island” is an island
 *   “totally” (all left, top, right, bottom) surrounded by ‘1s.’
 *   Return the number of “closed islands” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ grid.length, grid[0].length ≤ 100’
 *   • ‘0 ≤ grid[i][j] ≤1’
 *
 */

struct q1254 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    vector<int> direct = {0, 1, 1, 0, 0, -1, -1, 0};
   public:
    int closedIsland(vector<vector<int>>& grid) {
      int m = grid.size(), n = grid[0].size();
      int res = 0;
      for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
          if (grid[i][j] == 0) {
            bool surround = true;
            queue<pair<int, int>> q;
            grid[i][j] = 1;
            q.emplace(i, j);
            while (!q.empty()) {
              auto cur = q.front();
              q.pop();
              for (int d = 0; d < direct.size(); ++d) {
                int x = cur.first + direct[d];
                int y = cur.second + direct[++d];
                if (x < 0 || x >= m || y < 0 || y >= n) {
                  surround = false;
                  continue;
                }
                if (grid[x][y] == 0) {
                  grid[x][y] = 1;
                  q.emplace(x, y);
                }
              }
            }
            if (surround) ++res;
          }
        }
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1254, sample_input01) {
  solution = new Solution();
  vector<vector<int>> grid = {{1, 1, 1, 1, 1, 1, 1, 0}, {1, 0, 0, 0, 0, 1, 1, 0}, {1, 0, 1, 0, 1, 1, 1, 0}, {1, 0, 0, 0, 0, 1, 0, 1}, {1, 1, 1, 1, 1, 1, 1, 0}};
  int exp = 2;
  EXPECT_EQ(solution->closedIsland(grid), exp);
  delete solution;
}

TEST_F(q1254, sample_input02) {
  solution = new Solution();
  vector<vector<int>> grid = {{0, 0, 1, 0, 0}, {0, 1, 0, 1, 0}, {0, 1, 1, 1, 0}};
  int exp = 1;
  EXPECT_EQ(solution->closedIsland(grid), exp);
  delete solution;
}

TEST_F(q1254, sample_input03) {
  solution = new Solution();
  vector<vector<int>> grid = {{1, 1, 1, 1, 1, 1, 1}, {1, 0, 0, 0, 0, 0, 1}, {1, 0, 1, 1, 1, 0, 1}, {1, 0, 1, 0, 1, 0, 1}, {1, 0, 1, 1, 1, 0, 1}, {1, 0, 0, 0, 0, 0, 1}, {1, 1, 1, 1, 1, 1, 1}};
  int exp = 2;
  EXPECT_EQ(solution->closedIsland(grid), exp);
  delete solution;
}