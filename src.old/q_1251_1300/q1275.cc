#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 1275.
 *       Find Winner on a Tic Tac Toe Game
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *    “Tic-tac-toe” is played by two players ‘A’ and ‘B’ on a ‘3 x 3’ grid.
 *   The rules of Tic-Tac-Toe
 *       - Players take turns placing characters into empty squares ‘' '’
 *       - The first player ‘A’ always places ‘'X'’ characters, while the
 *   second player ‘B’ always places ‘'O'’
 *       -  ‘'X'’ and ‘'O'’ characters are always placed into empty
 *   squares, never on filled
 *       - The game ends when there are “three” of the same (non-empty)
 *   character filling any row, column, or
 *       - The game also ends if all squares are
 *       - No more moves can be played if the game is
 *   Given a 2D integer array ‘moves’ where ‘moves[i] = [rowᵢ, colᵢ]’
 *   indicates that the ‘iᵗʰ’ move will be played on ‘grid[rowᵢ][colᵢ]’ .
 *   return “the winner of the game if it exists” ( ‘A’ or ‘B’ ). In case
 *   the game ends in a draw return ‘'Draw'’ . If there are still movements
 *   to play return ‘'Pending'’
 *   You can assume that ‘moves’ is valid (i.e., it follows the rules of
 *   “Tic-Tac-Toe” ), the grid is initially empty, and ‘A’ will play first.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ moves.length ≤ 9’
 *   • ‘moves[i].length = 2’
 *   • ‘0 ≤ rowᵢ, colᵢ ≤ 2’
 *   • There are no repeated elements on ‘moves’ .
 *   • ‘moves’ follow the rules of tic tac toe.
 *
 */

struct q1275 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    bool winner(const vector<vector<int>> &b, const int &r, const int &c) {
      if (b[r][0] == b[r][1] && b[r][1] == b[r][2]) return true;
      if (b[0][c] == b[1][c] && b[1][c] == b[2][c]) return true;
      if (c + r == 2 && b[2][0] == b[1][1] && b[1][1] == b[0][2]) return true;
      if (c == r && b[0][0] == b[1][1] && b[1][1] == b[2][2]) return true;
      return false;
    }
   public:
    string tictactoe(vector<vector<int>> &moves) {
      vector<vector<int>> board(3, vector<int>(3, 0));
      int val = 1;
      for (int i = 0; i < moves.size(); ++i) {
        board[moves[i][0]][moves[i][1]] = val;
        if (winner(board, moves[i][0], moves[i][1])) {
          return val == 1 ? "A" : "B";
        }
        val *= -1;
      }
      return moves.size() == 9 ? "Draw" : "Pending";
    }
  };

  class Solution *solution;
};

TEST_F(q1275, sample_input01) {
  solution = new Solution();
  vector<vector<int>> moves = {{0, 0}, {2, 0}, {1, 1}, {2, 1}, {2, 2}};
  string exp = "A";
  EXPECT_EQ(solution->tictactoe(moves), exp);
  delete solution;
}

TEST_F(q1275, sample_input02) {
  solution = new Solution();
  vector<vector<int>> moves = {{0, 0}, {1, 1}, {0, 1}, {0, 2}, {1, 0}, {2, 0}};
  string exp = "B";
  EXPECT_EQ(solution->tictactoe(moves), exp);
  delete solution;
}

TEST_F(q1275, sample_input03) {
  solution = new Solution();
  vector<vector<int>> moves = {{0, 0}, {1, 1}, {2, 0}, {1, 0}, {1, 2}, {2, 1}, {0, 1}, {0, 2}, {2, 2}};
  string exp = "Draw";
  EXPECT_EQ(solution->tictactoe(moves), exp);
  delete solution;
}

TEST_F(q1275, sample_input04) {
  solution = new Solution();
  vector<vector<int>> moves = {{0, 0}, {1, 1}};
  string exp = "Pending";
  EXPECT_EQ(solution->tictactoe(moves), exp);
  delete solution;
}