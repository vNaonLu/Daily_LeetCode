#include <gtest/gtest.h>
#include <iostream>
#include <queue>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 1286.
 *       Iterator for Combination
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Design the ‘CombinationIterator’
 *       -  ‘CombinationIterator(string characters, int combinationLength)’
 *   Initializes the object with a string ‘characters’ of “sorted distinct”
 *   lowercase English letters and a number ‘combinationLength’ as
 *       -  ‘next()’ Returns the next combination of length
 *   ‘combinationLength’ in “lexicographical order”
 *       -  ‘hasNext()’ Returns ‘true’ if and only if there exists a next
 *   combination.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ combinationLength ≤ characters.length ≤ 15’
 *   • All the characters of ‘characters’ are “unique” .
 *   • At most ‘10⁴’ calls will be made to ‘next’ and ‘hasNext’ .
 *   • It is guaranteed that all calls of the function ‘next’ are valid.
 *
 */

struct q1286 : public ::testing::Test {
  // Leetcode answer here
  class CombinationIterator {
   private:
    queue<string> _combine;
    void combine_helper(const string &s, int L, string &t, int beg = 0) {
      if (t.size() == L) {
        _combine.emplace(t);
      } else {
        for (int i = beg; i < s.size(); ++i) {
          t.push_back(s[i]);
          combine_helper(s, L, t, i + 1);
          t.pop_back();
        }
      }
    }
   public:
    CombinationIterator(string characters, int combinationLength) {
      string tmp;
      combine_helper(characters, combinationLength, tmp);
    }
    string next() {
      auto res = _combine.front();
      _combine.pop();
      return res;
    }
    bool hasNext() {
      return !_combine.empty();
    }
  };

  class CombinationIterator *combination_iterator;
};

TEST_F(q1286, sample_input01) {
  string characters = "abc";
  int combinationLength = 2;
  combination_iterator = new CombinationIterator(characters, combinationLength);
  EXPECT_EQ(combination_iterator->next(), "ab");
  EXPECT_EQ(combination_iterator->hasNext(), true);
  EXPECT_EQ(combination_iterator->next(), "ac");
  EXPECT_EQ(combination_iterator->hasNext(), true);
  EXPECT_EQ(combination_iterator->next(), "bc");
  EXPECT_EQ(combination_iterator->hasNext(), false);
  delete combination_iterator;
}