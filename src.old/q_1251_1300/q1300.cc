#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1300.
 *       Sum of Mutated Array Closest to Target
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an integer array ‘arr’ and a target value ‘target’ , return the
 *   integer ‘value’ such that when we change all the integers larger than
 *   ‘value’ in the given array to be equal to ‘value’ , the sum of the
 *   array gets as close as possible (in absolute difference) to ‘target’
 *   In case of a tie, return the minimum such
 *   Notice that the answer is not neccesarilly a number from ‘arr’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ arr.length ≤ 10⁴’
 *   • ‘1 ≤ arr[i], target ≤ 10⁵’
 *
 */

struct q1300 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    template <typename iterator, typename type>
    auto obtainDiff(iterator beg, iterator end, type threshold, type target) {
      auto res = 0;
      while (beg != end) {
        res += *(beg) > threshold ? threshold : *beg;
        ++beg;
      }

      return abs(res - target);
    }

  public:
    int findBestValue(vector<int> &arr, int target) {
      auto lo = 0;
      auto hi = *max_element(arr.begin(), arr.end());

      if (hi < lo) {

        return hi;
      }

      while (lo < hi) {
        auto mid = lo + (hi - lo) / 2;
        if (obtainDiff(arr.begin(), arr.end(), mid, target) <=
            obtainDiff(arr.begin(), arr.end(), mid + 1, target)) {
          hi = mid;
        } else {
          lo = mid + 1;
        }
      }

      return lo;
    }
  };

  class Solution *solution;
};

TEST_F(q1300, sample_input01) {
  solution = new Solution();
  vector<int> arr = {4, 9, 3};
  int target = 10;
  int exp = 3;
  int act = solution->findBestValue(arr, target);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1300, sample_input02) {
  solution = new Solution();
  vector<int> arr = {2, 3, 5};
  int target = 10;
  int exp = 5;
  int act = solution->findBestValue(arr, target);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1300, sample_input03) {
  solution = new Solution();
  vector<int> arr = {60864, 25176, 27249, 21296, 20204};
  int target = 56803;
  int exp = 11361;
  int act = solution->findBestValue(arr, target);
  EXPECT_EQ(act, exp);
  delete solution;
}