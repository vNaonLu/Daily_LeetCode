#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <string_view>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 468.
 *      Validate IP Address
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a string ‘queryIP’ , return ‘'IPv4'’ if IP is a valid IPv4
 *   address, ‘'IPv6'’ if IP is a valid IPv6 address or ‘'Neither'’ if IP
 *   is not a correct IP of any
 *    “A valid IPv4” address is an IP in the form ‘'x₁.x₂.x₃.x₄'’ where ‘0
 *   ≤ xᵢ ≤ 255’ and ‘xᵢ’ “cannot contain” leading zeros. For example,
 *   ‘'192.168.1.1'’ and ‘'192.168.1.0'’ are valid IPv4 addresses while
 *   ‘'192.168.01.1'’ , ‘'192.168.1.00'’ , and ‘'192.168@1.1'’ are invalid
 *   IPv4
 *    “A valid IPv6” address is an IP in the form
 *   ‘'x₁:x₂:x₃:x₄:x₅:x₆:x₇:x₈'’
 *       -  ‘1 ≤ xᵢ.length ≤ 4’
 *       -  ‘xᵢ’ is a “hexadecimal string” which may contain digits,
 *   lowercase English letter ( ‘'a'’ to ‘'f'’ ) and upper-case English
 *   letters ( ‘'A'’ to ‘'F'’
 *       - Leading zeros are allowed in ‘xᵢ’
 *   For example, ' ‘2001:0db8:85a3:0000:0000:8a2e:0370:7334'’ and '
 *   ‘2001:db8:85a3:0:0:8A2E:0370:7334'’ are valid IPv6 addresses, while '
 *   ‘2001:0db8:85a3::8A2E:037j:7334'’ and '
 *   ‘02001:0db8:85a3:0000:0000:8a2e:0370:7334'’ are invalid IPv6 addresses
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘queryIP’ consists only of English letters, digits and the characters
 * ‘'.'’ and ‘':'’ .
 *
 */

struct q468 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    template <typename Iterator> int toInt(Iterator beg, Iterator end) {
      auto res = 0;
      while (beg != end) {
        res *= 10;
        res += *beg++ - '0';
      }
      return res;
    }

    bool isValidIpv4(char x) { return (x >= '0' && x <= '9'); }

    bool isIpv4(string_view s) {
      auto find = 0;
      auto l    = s.begin();
      auto len  = 0;
      for (auto it = s.begin(); it != s.end(); ++it) {
        if (len > 3) {
          return false;
        }

        if (*it == '.') {
          auto x = toInt(l, it);
          if (x > 255 || (*l == '0' && len > 1) || it == l) {
            return false;
          }
          l   = it + 1;
          len = 0;
          ++find;
        } else if (it + 1 == s.end()) {
          auto x = toInt(l, s.end());
          if (x > 255 || (*l == '0' && (len + 1) > 1)) {
            return false;
          }
        } else if (!isValidIpv4(*it)) {
          return false;
        } else {
          ++len;
        }
      }

      return find == 3 && l != s.end();
    }

    bool isValidIpv6(char x) {
      return (x >= '0' && x <= '9') || (x >= 'a' && x <= 'f') ||
             (x >= 'A' && x <= 'F');
    }

    bool isIpv6(string_view s) {
      auto find = 0;
      auto l    = s.begin();
      auto len  = 0;

      for (auto it = s.begin(); it != s.end(); ++it) {
        if (len > 4) {
          return false;
        }

        if (*it == ':') {
          if (len == 0) {
            return false;
          }
          l = it + 1;
          ++find;
          len = 0;
        } else if (it + 1 == s.end()) {
          if ((len + 1) > 4) {
            return false;
          }
        } else if (!isValidIpv6(*it)) {
          return false;
        } else {
          ++len;
        }
      }

      return find == 7 && l != s.end();
    }

  public:
    string validIPAddress(string queryIP) {
      return isIpv4(queryIP) ? "IPv4" : isIpv6(queryIP) ? "IPv6" : "Neither";
    }
  };

  class Solution *solution;
};

TEST_F(q468, sample_input01) {
  solution       = new Solution();
  string queryIP = "172.16.254.1";
  string exp     = "IPv4";
  string act     = solution->validIPAddress(queryIP);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q468, sample_input02) {
  solution       = new Solution();
  string queryIP = "2001:0db8:85a3:0:0:8A2E:0370:7334";
  string exp     = "IPv6";
  string act     = solution->validIPAddress(queryIP);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q468, sample_input03) {
  solution       = new Solution();
  string queryIP = "256.256.256.256";
  string exp     = "Neither";
  string act     = solution->validIPAddress(queryIP);
  EXPECT_EQ(act, exp);
  delete solution;
}