#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 463.
 *      Island Perimeter
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given ‘row x col’  ‘grid’ representing a map where ‘grid[i][j]
 *   = 1’ representsland and ‘grid[i][j] = 0’ represents
 *   Grid cells are connected “horizontally/vertically” (not diagonally).
 *   The ‘grid’ is completely surrounded by water, and there is exactly one
 *   island (i.e., one or more connected land
 *   The island doesn't have 'lakes', meaning the water inside isn't
 *   connected to the water around the island. One cell is a square with
 *   side length 1. The grid is rectangular, width and height don't exceed
 *   100. Determine the perimeter of the island.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘row = grid.length’
 *   • ‘col = grid[i].length’
 *   • ‘1 ≤ row, col ≤ 100’
 *   • ‘grid[i][j]’ is ‘0’ or ‘1’ .
 *   • There is exactly one island in ‘grid’ .
 *
 */

struct q463 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    int m = 0;
    int n = 0;
    vector<int> direct = {1, 0, 0, 1, -1, 0, 0, -1};
    int helper(vector<vector<int>>& grid, int r, int c) {
      int res = 0;
      queue<pair<int, int>> q;
      q.push(make_pair(r, c));
      grid[r][c] = 2;
      while (!q.empty()) {
        auto top = q.front();
        q.pop();
        for (int i = 0; i < direct.size(); ++i) {
          int x = top.first + direct[i];
          int y = top.second + direct[++i];
          if (x >= 0 && x < m && y >= 0 && y < n) {
            if (grid[x][y] == 1) {
              q.push(make_pair(x, y));
              grid[x][y] = 2;
            } else if (grid[x][y] == 0) {
              ++res;
            }
          } else {
            ++res;
          }
        }
      }
      return res;
    }
   public:
    int islandPerimeter(vector<vector<int>>& grid) {
      m = grid.size();
      n = grid[0].size();
      for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
          if (grid[i][j] == 1) {
            return helper(grid, i, j);
          }
        }
      }
      return 0;
    }
  };

  class Solution *solution;
};

TEST_F(q463, sample_input01) {
  solution = new Solution();
  vector<vector<int>> grid = {{0, 1, 0, 0}, {1, 1, 1, 0}, {0, 1, 0, 0}, {1, 1, 0, 0}};
  int exp = 16;
  EXPECT_EQ(solution->islandPerimeter(grid), exp);
  delete solution;
}

TEST_F(q463, sample_input02) {
  solution = new Solution();
  vector<vector<int>> grid = {{1}};
  int exp = 4;
  EXPECT_EQ(solution->islandPerimeter(grid), exp);
  delete solution;
}

TEST_F(q463, sample_input03) {
  solution = new Solution();
  vector<vector<int>> grid = {{1, 0}};
  int exp = 4;
  EXPECT_EQ(solution->islandPerimeter(grid), exp);
  delete solution;
}