#include <gtest/gtest.h>
#include <iostream>
#include <string>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 10.
 *     Regular Expression Matching
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an input string ‘s’ and a pattern ‘p’ , implement regular
 *   expression matching with support for ‘'.'’ and ‘'×'’
 *       -  ‘'.'’ Matches any single
 *       -  ‘'×'’ Matches zero or more of the preceding
 *   The matching should cover the “entire” input string (not partial).
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ s.length≤ 20’
 *   • ‘1 ≤ p.length≤ 30’
 *   • ‘s’ contains only lowercase English letters.
 *   • ‘p’ contains only lowercase English letters, ‘'.'’ , and ‘'×'’ .
 *   • It is guaranteed for each appearance of the character ‘'×'’ , there will be a previous valid character to match.
 *
 */

struct q10 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    bool isMatch(string s, string p) {
      int m = s.size() + 1, n = p.size() + 1;
      vector<vector<bool>> dp(m, vector<bool>(n, false));
      dp[0][0] = true;
      for (int j = 0; j < n; ++j)
        if (p[j - 1] == '*')
          dp[0][j] = dp[0][j - 2];
      for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
          if (s[i - 1] == p[j - 1] || p[j - 1] == '.') {
            dp[i][j] = dp[i - 1][j - 1];
          } else if (p[j - 1] == '*') {
            if (s[i - 1] == p[j - 2] || p[j - 2] == '.')
              dp[i][j] = dp[i][j - 2] || dp[i - 1][j];
            else
              dp[i][j] = dp[i][j - 2];
          }
        }
      }
      return dp.back().back();
    }
  };

  class Solution *solution;
};

TEST_F(q10, sample_input01) {
  solution = new Solution();
  string s = "aa";
  string p = "a";
  bool exp = false;
  EXPECT_EQ(solution->isMatch(s, p), exp);
  delete solution;
}

TEST_F(q10, sample_input02) {
  solution = new Solution();
  string s = "aa";
  string p = "a*";
  bool exp = true;
  EXPECT_EQ(solution->isMatch(s, p), exp);
  delete solution;
}

TEST_F(q10, sample_input03) {
  solution = new Solution();
  string s = "ab";
  string p = ".*";
  bool exp = true;
  EXPECT_EQ(solution->isMatch(s, p), exp);
  delete solution;
}

TEST_F(q10, sample_input04) {
  solution = new Solution();
  string s = "aab";
  string p = "c*a*b";
  bool exp = true;
  EXPECT_EQ(solution->isMatch(s, p), exp);
  delete solution;
}

TEST_F(q10, sample_input05) {
  solution = new Solution();
  string s = "mississippi";
  string p = "mis*is*p*.";
  bool exp = false;
  EXPECT_EQ(solution->isMatch(s, p), exp);
  delete solution;
}