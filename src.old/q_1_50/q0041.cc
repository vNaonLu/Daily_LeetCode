#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 41.
 *     First Missing Positive
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an unsorted integer array ‘nums’ , return the smallest missing
 *   positive
 *   You must implement an algorithm that runs in ‘O(n)’ time and uses
 *   constant extra space.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ nums.length ≤ 5 × 10⁵’
 *   • ‘-2³¹ ≤ nums[i] ≤ 2³¹ - 1’
 *
 */

struct q41 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int firstMissingPositive(vector<int>& nums) {
      int n = nums.size();
      int beg = 0, R = n - 1;
      while (beg <= R) {
        if (nums[beg] <= 0) {
          ++beg;
        } else if (nums[R] > 0) {
          --R;
        } else {
          swap(nums[beg++], nums[R--]);
        }
      }
      for (int i = beg; i < n; ++i) {
        int val = abs(nums[i]);
        if (val > n - beg) continue;
        if (nums[beg + val - 1] > 0) {
          nums[beg + val - 1] *= -1;
        }
      }
      for (int i = beg; i < n; ++i) {
        if (nums[i] > 0) {
          return i - beg + 1;
        }
      }
      return n - beg + 1;
    }
  };

  class Solution *solution;
};

TEST_F(q41, sample_input01) {
  solution = new Solution();
  vector<int> nums = {1, 2, 0};
  int exp = 3;
  EXPECT_EQ(solution->firstMissingPositive(nums), exp);
  delete solution;
}

TEST_F(q41, sample_input02) {
  solution = new Solution();
  vector<int> nums = {3, 4, -1, 1};
  int exp = 2;
  EXPECT_EQ(solution->firstMissingPositive(nums), exp);
  delete solution;
}

TEST_F(q41, sample_input03) {
  solution = new Solution();
  vector<int> nums = {7, 8, 9, 11, 12};
  int exp = 1;
  EXPECT_EQ(solution->firstMissingPositive(nums), exp);
  delete solution;
}