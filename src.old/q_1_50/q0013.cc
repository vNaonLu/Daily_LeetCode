#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <unordered_map>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 13.
 *     Roman to Integer
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Roman numerals are represented by seven different symbols: ‘I’ , ‘V’ ,
 *   ‘X’ , ‘L’ , ‘C’ , ‘D’ and ‘M’
 *    “Symbol”  “Value”
 *   I            
 *   V            
 *   X            
 *   L            
 *   C            
 *   D            
 *   M            
 *   For example, ‘2’ is written as ‘II’ in Roman numeral, just two one's
 *   added together. ‘12’ is written as ‘XII’ , which is simply ‘X + II’ .
 *   The number ‘27’ is written as ‘XXVII’ , which is ‘XX + V + II’
 *   Roman numerals are usually written largest to smallest from left to
 *   right. However, the numeral for four is not ‘IIII’ . Instead, the
 *   number four is written as ‘IV’ . Because the one is before the five we
 *   subtract it making four. The same principle applies to the number
 *   nine, which is written as ‘IX’ . There are six instances where
 *   subtraction is
 *       -  ‘I’ can be placed before ‘V’ (5) and ‘X’ (10) to make 4 and
 *       -  ‘X’ can be placed before ‘L’ (50) and ‘C’ (100) to make 40 and
 *       -  ‘C’ can be placed before ‘D’ (500) and ‘M’ (1000) to make 400
 *   and
 *   Given a roman numeral, convert it to an integer.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ s.length ≤ 15’
 *   • ‘s’ contains onlythe characters ‘('I', 'V', 'X', 'L', 'C', 'D', 'M')’ .
 *   • It is “guaranteed” that ‘s’ is a valid roman numeral in the range ‘[1, 3999]’ .
 *
 */

struct q13 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    unordered_map<char, int> symbol = {{'I', 1},
                                       {'V', 5},
                                       {'X', 10},
                                       {'L', 50},
                                       {'C', 100},
                                       {'D', 500},
                                       {'M', 1000}};
   public:
    int romanToInt(string s) {
      int res = 0;
      for (int i = 0; i < s.size(); ++i) {
        res += symbol[s[i]];
        if (i > 0 && symbol[s[i]] > symbol[s[i - 1]]) {
          res -= 2 * symbol[s[i - 1]];
        }
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q13, sample_input01) {
  solution = new Solution();
  string s = "III";
  int exp = 3;
  EXPECT_EQ(solution->romanToInt(s), exp);
  delete solution;
}

TEST_F(q13, sample_input02) {
  solution = new Solution();
  string s = "IV";
  int exp = 4;
  EXPECT_EQ(solution->romanToInt(s), exp);
  delete solution;
}

TEST_F(q13, sample_input03) {
  solution = new Solution();
  string s = "IX";
  int exp = 9;
  EXPECT_EQ(solution->romanToInt(s), exp);
  delete solution;
}

TEST_F(q13, sample_input04) {
  solution = new Solution();
  string s = "LVIII";
  int exp = 58;
  EXPECT_EQ(solution->romanToInt(s), exp);
  delete solution;
}

TEST_F(q13, sample_input05) {
  solution = new Solution();
  string s = "MCMXCIV";
  int exp = 1994;
  EXPECT_EQ(solution->romanToInt(s), exp);
  delete solution;
}