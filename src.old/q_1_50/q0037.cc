#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 37.
 *     Sudoku Solver
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Write a program to solve a Sudoku puzzle by filling the empty
 *   A sudoku solution must satisfy “all of the following rules”
 *       1. Each of the digits ‘1-9’ must occur exactly once in each
 *       2. Each of the digits ‘1-9’ must occur exactly once in each
 *       3. Each of the digits ‘1-9’ must occur exactly once in each of the
 *   9 ‘3x3’ sub-boxes of the
 *   The ‘'.'’ character indicates empty cells.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘board.length = 9’
 *   • ‘board[i].length = 9’
 *   • ‘board[i][j]’ is a digit or ‘'.'’ .
 *   • It is “guaranteed” that the input board has only one solution.
 *
 */

struct q37 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    bool valid(vector<vector<char>> &b, int r, int c) {
      char keep = b[r][c];
      for (int i = 0; i < 9; ++i) {
        if (b[i][c] == keep && i != r) return false;
        if (b[r][i] == keep && i != c) return false;
      }
      int row_block = r / 3 * 3;
      int col_block = c / 3 * 3;
      for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
          if (row_block + i == r && col_block + j == c) continue;
          if (b[row_block + i][col_block + j] == keep) return false;
        }
      }
      return true;
    }
    bool helper(vector<vector<char>> &b, int r = 0, int c = 0) {
      if (c == 9)
        return helper(b, r + 1, 0);
      else if (r == 9)
        return true;
      if (b[r][c] != '.') return helper(b, r, c + 1);
      for (char i = '1'; i <= '9'; ++i) {
        b[r][c] = i;
        if (valid(b, r, c) && helper(b, r, c + 1))
          return true;
      }
      b[r][c] = '.';
      return false;
    }
   public:
    void solveSudoku(vector<vector<char>> &board) {
      helper(board);
    }
  };

  class Solution *solution;
};

TEST_F(q37, sample_input01) {
  solution = new Solution();
  vector<vector<char>> board = {{'5', '3', '.', '.', '7', '.', '.', '.', '.'}, {'6', '.', '.', '1', '9', '5', '.', '.', '.'}, {'.', '9', '8', '.', '.', '.', '.', '6', '.'}, {'8', '.', '.', '.', '6', '.', '.', '.', '3'}, {'4', '.', '.', '8', '.', '3', '.', '.', '1'}, {'7', '.', '.', '.', '2', '.', '.', '.', '6'}, {'.', '6', '.', '.', '.', '.', '2', '8', '.'}, {'.', '.', '.', '4', '1', '9', '.', '.', '5'}, {'.', '.', '.', '.', '8', '.', '.', '7', '9'}};
  vector<vector<char>> exp = {{'5', '3', '4', '6', '7', '8', '9', '1', '2'}, {'6', '7', '2', '1', '9', '5', '3', '4', '8'}, {'1', '9', '8', '3', '4', '2', '5', '6', '7'}, {'8', '5', '9', '7', '6', '1', '4', '2', '3'}, {'4', '2', '6', '8', '5', '3', '7', '9', '1'}, {'7', '1', '3', '9', '2', '4', '8', '5', '6'}, {'9', '6', '1', '5', '3', '7', '2', '8', '4'}, {'2', '8', '7', '4', '1', '9', '6', '3', '5'}, {'3', '4', '5', '2', '8', '6', '1', '7', '9'}};
  solution->solveSudoku(board);
  // Assume the first argument is answer.
  EXPECT_EQ(board, exp);
  delete solution;
}