#include <gtest/gtest.h>
#include <iostream>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 1032.
 *       Stream of Characters
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Design an algorithm that accepts a stream of characters and checks if
 *   a suffix of these characters is a string of a given array of strings
 *   ‘words’
 *   For example, if ‘words = ['abc', 'xyz']’ and the stream added the four
 *   characters (one by one) ‘'a'’ , ‘'x'’ , ‘'y'’ , and ‘'z'’ , your
 *   algorithm should detect that the suffix ‘'xyz'’ of the characters
 *   ‘'axyz'’ matches ‘'xyz'’ from ‘words’
 *   Implement the ‘StreamChecker’
 *       -  ‘StreamChecker(String[] words)’ Initializes the object with the
 *   strings array ‘words’
 *       -  ‘boolean query(char letter)’ Accepts a new character from the
 *   stream and returns ‘true’ if any non-empty suffix from the stream
 *   forms a word that is in ‘words’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ words.length ≤ 2000’
 *   • ‘1 ≤ words[i].length ≤ 2000’
 *   • ‘words[i]’ consists of lowercase English letters.
 *   • ‘letter’ is a lowercase English letter.
 *   • At most ‘4 × 10⁴’ calls will be made to query.
 *
 */

struct q1032 : public ::testing::Test {
  // Leetcode answer here
  class StreamChecker {
   private:
    struct trie {
      vector<optional<trie>> next;
      bool is_end;
      trie() : is_end{false} {
        next.resize(26);
      }
    };
    trie _head;
    vector<char> _queries;
    size_t max_length{0};
   public:
    StreamChecker(vector<string> &words) {
      for (const auto &s : words) {
        auto *node = &_head;
        for (auto it = s.rbegin(); it != s.rend(); ++it) {
          int idx = *it - 'a';
          if (!node->next[idx])
            node->next[idx] = trie{};
          node = &node->next[idx].value();
        }
        node->is_end = true;
        max_length = max(max_length, s.size());
      }
    }
    bool query(char letter) {
      _queries.insert(_queries.begin(), letter);
      if (_queries.size() > max_length) _queries.pop_back();
      auto *node = &_head;
      for (auto it = _queries.begin(); it != _queries.end(); ++it) {
        if (node->is_end) return true;
        if (!node->next[*it - 'a']) return false;
        node = &node->next[*it - 'a'].value();
      }
      return node->is_end;
    }
  };

  class StreamChecker *stream_checker;
};

TEST_F(q1032, sample_input01) {
  vector<string> words = {"cd", "f", "kl"};
  stream_checker = new StreamChecker(words);
  EXPECT_EQ(stream_checker->query('a'), false);
  EXPECT_EQ(stream_checker->query('b'), false);
  EXPECT_EQ(stream_checker->query('c'), false);
  EXPECT_EQ(stream_checker->query('d'), true);
  EXPECT_EQ(stream_checker->query('e'), false);
  EXPECT_EQ(stream_checker->query('f'), true);
  EXPECT_EQ(stream_checker->query('g'), false);
  EXPECT_EQ(stream_checker->query('h'), false);
  EXPECT_EQ(stream_checker->query('i'), false);
  EXPECT_EQ(stream_checker->query('j'), false);
  EXPECT_EQ(stream_checker->query('k'), false);
  EXPECT_EQ(stream_checker->query('l'), true);
  delete stream_checker;
}