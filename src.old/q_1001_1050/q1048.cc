#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1048.
 *       Longest String Chain
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given an array of ‘words’ where each word consists of
 *   lowercase English
 *    ‘word⎽(A)’ is a “predecessor” of ‘word⎽(B)’ if and only if we can
 *   insert “exactly one” letter anywhere in ‘word⎽(A)’ “without changing
 *   the order of the other characters” to make it equal to ‘word⎽(B)’
 *       - For example, ‘'abc'’ is a “predecessor” of ‘'ab<u>a</u>c'’ ,
 *   while ‘'cba'’ is not a “predecessor” of ‘'bcad'’
 *   A “word chain” “ ” is a sequence of words ‘[word₁, word₂, ..., wordₖ]’
 *   with ‘k ≥ 1’ , where ‘word₁’ is a “predecessor” of ‘word₂’ , ‘word₂’
 *   is a “predecessor” of ‘word₃’ , and so on. A single word is trivially
 *   a “word chain” with ‘k = 1’
 *   Return “the “length” of the “longest possible word chain” with words
 *   chosen from the given list of ” ‘words’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ words.length ≤ 1000’
 *   • ‘1 ≤ words[i].length ≤ 16’
 *   • ‘words[i]’ only consists of lowercase English letters.
 *
 */

struct q1048 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int longestStrChain(vector<string> &words) {
      sort(words.begin(), words.end(), [](auto &x, auto &y) {
        return x.size() < y.size();
      });

      unordered_map<string, int> mp;
      int res = 0;

      for (auto &s : words) {
        int local = 0;
        for (int i = 0; i < s.size(); ++i) {
          auto sub = s.substr(0, i) + s.substr(i + 1, s.size() + 1);
          local = max(local, mp[sub] + 1);
        }
        mp[s] = local;
        res = max(res, local);
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1048, sample_input01) {
  solution = new Solution();
  vector<string> words = {"a", "b", "ba", "bca", "bda", "bdca"};
  int exp = 4;
  int act = solution->longestStrChain(words);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1048, sample_input02) {
  solution = new Solution();
  vector<string> words = {"xbc", "pcxbcf", "xb", "cxbc", "pcxbc"};
  int exp = 5;
  int act = solution->longestStrChain(words);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1048, sample_input03) {
  solution = new Solution();
  vector<string> words = {"abcd", "dbqca"};
  int exp = 1;
  int act = solution->longestStrChain(words);
  EXPECT_EQ(act, exp);
  delete solution;
}