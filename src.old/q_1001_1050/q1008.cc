#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 1008.
 *       Construct Binary Search Tree from Preorder Traversal
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an array of integers preorder, which represents the “preorder
 *   traversal” of a BST (i.e., “binary search tree” ), construct the tree
 *   and return “its root”
 *   It is “guaranteed” that there is always possible to find a binary
 *   search tree with the given requirements for the given test
 *   A “binary search tree” is a binary tree where for every node, any
 *   descendant of ‘Node.left’ has a value “strictly less than” ‘Node.val’
 *   , and any descendant of ‘Node.right’ has a value “strictly greater
 *   than” ‘Node.val’
 *   A “preorder traversal” of a binary tree displays the value of the node
 *   first, then traverses ‘Node.left’ , then traverses ‘Node.right’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ preorder.length ≤ 100’
 *   • ‘1 ≤ preorder[i] ≤ 1000’
 *   • All the values of ‘preorder’ are “unique” .
 *
 */

struct q1008 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    TreeNode* build_tree(vector<int>& v, int &idx, int bound = numeric_limits<int>::max()) {
      if(idx == v.size() || v[idx] > bound) return nullptr;
      TreeNode* p = new TreeNode(v[idx++]);
      p->left = build_tree(v, idx, p->val);
      p->right = build_tree(v, idx, bound);
      return p;
    }
   public:
    TreeNode* bstFromPreorder(vector<int>& preorder) {
      int i = 0;
      return build_tree(preorder, i);
    }
  };

  class Solution *solution;
};

TEST_F(q1008, sample_input01) {
  solution = new Solution();
  vector<int> preorder = {8, 5, 1, 7, 10, 12};
  TreeNode* exp = TreeNode::generate({8, 5, 10, 1, 7, NULL_TREENODE, 12});
  TreeNode* act = solution->bstFromPreorder(preorder);
  EXPECT_TREENODE_EQ(act, exp);
  TreeNode::release(exp, act);
  delete solution;
}

TEST_F(q1008, sample_input02) {
  solution = new Solution();
  vector<int> preorder = {1, 3};
  TreeNode* exp = TreeNode::generate({1, NULL_TREENODE, 3});
  TreeNode* act = solution->bstFromPreorder(preorder);
  EXPECT_TREENODE_EQ(act, exp);
  TreeNode::release(exp, act);
  delete solution;
}