#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/listnode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 2095.
 *       Delete the Middle Node of a Linked List
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given the ‘head’ of a linked list. “Delete” the “middle node”
 *   , and return “the” ‘head’ “of the modified linked list”
 *   The “middle node” of a linked list of size ‘n’ is the ‘&lfloor;n /
 *   2&rfloor;ᵗʰ’ node from the “start” using “0-based indexing” , where
 *   ‘&lfloor;x&rfloor;’ denotes the largest integer less than or equal to
 *   ‘x’
 *       - For ‘n’ = ‘1’ , ‘2’ , ‘3’ , ‘4’ , and ‘5’ , the middle nodes are
 *   ‘0’ , ‘1’ , ‘1’ , ‘2’ , and ‘2’ , respectively.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the list is in the range ‘[1, 10⁵]’ .
 *   • ‘1 ≤ Node.val ≤ 10⁵’
 *
 */

struct q2095 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    ListNode *deleteMiddle(ListNode *head) {
      auto dummy = ListNode(0, head);
      auto lo    = &dummy;
      auto hi    = dummy.next;
      while (nullptr != hi && nullptr != hi->next) {
        hi = hi->next->next;
        lo = lo->next;
      }
      lo->next = lo->next->next;
      return dummy.next;
    }
  };

  class Solution *solution;
};

TEST_F(q2095, sample_input01) {
  solution       = new Solution();
  ListNode *head = ListNode::generate({1, 3, 4, 7, 1, 2, 6});
  ListNode *exp  = ListNode::generate({1, 3, 4, 1, 2, 6});
  ListNode *act  = solution->deleteMiddle(head);
  EXPECT_LISTNODE_EQ(act, exp);
  ListNode::release(head, exp, act);
  delete solution;
}

TEST_F(q2095, sample_input02) {
  solution       = new Solution();
  ListNode *head = ListNode::generate({1, 2, 3, 4});
  ListNode *exp  = ListNode::generate({1, 2, 4});
  ListNode *act  = solution->deleteMiddle(head);
  EXPECT_LISTNODE_EQ(act, exp);
  ListNode::release(head, exp, act);
  delete solution;
}

TEST_F(q2095, sample_input03) {
  solution       = new Solution();
  ListNode *head = ListNode::generate({2, 1});
  ListNode *exp  = ListNode::generate({2});
  ListNode *act  = solution->deleteMiddle(head);
  EXPECT_LISTNODE_EQ(act, exp);
  ListNode::release(head, exp, act);
  delete solution;
}