#include <gtest/gtest.h>
#include <iostream>
#include <unordered_map>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 211.
 *      Design Add and Search Words Data Structure
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Design a data structure that supports adding new words and finding if
 *   a string matches any previously added
 *   Implement the ‘WordDictionary’
 *       -  ‘WordDictionary()’ Initializes the
 *       -  ‘void addWord(word)’ Adds ‘word’ to the data structure, it can
 *   be matched
 *       -  ‘bool search(word)’ Returns ‘true’ if there is any string in
 *   the data structure that matches ‘word’ or ‘false’ otherwise. ‘word’
 *   may contain dots ‘'.'’ where dots can be matched with any letter.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ word.length ≤ 500’
 *   • ‘word’ in ‘addWord’ consists lower-case English letters.
 *   • ‘word’ in ‘search’ consist of ‘'.'’ or lower-case English letters.
 *   • At most ‘50000’ calls will be made to ‘addWord’ and ‘search’ .
 *
 */

struct q211 : public ::testing::Test {
  // Leetcode answer here
  class WordDictionary {
   private:
    struct trie {
      unordered_map<char, trie *> next;
      bool is_end = false;
    } *head = nullptr;

    bool searchHelper(string_view s, trie *p, size_t i = 0) {
      if (i == s.size() && p->is_end) return true;
      auto c = s[i];
      if (c != '.' && !p->next.count(c))
        return false;
      else if (c != '.')
        return searchHelper(s, p->next[c], i + 1);
      else {
        for (auto &[k, v] : p->next) {
          if (searchHelper(s, v, i + 1)) return true;
        }
        return false;
      }
    }

   public:
    WordDictionary() {
      head = new trie();
    }

    void addWord(string word) {
      trie *p = head;
      for (const auto &c : word) {
        if (!p->next.count(c)) {
          p->next[c] = new trie();
        }
        p = p->next[c];
      }
      p->is_end = true;
    }

    bool search(string word) {
      return searchHelper(word, head);
    }
  };

  /**
   * Your WordDictionary object will be instantiated and called as such:
   * WordDictionary* obj = new WordDictionary();
   * obj->addWord(word);
   * bool param_2 = obj->search(word);
   */

  class WordDictionary *word_dictionary;
};

TEST_F(q211, sample_input01) {
  word_dictionary = new WordDictionary();
  word_dictionary->addWord("bad");
  word_dictionary->addWord("dad");
  word_dictionary->addWord("mad");
  EXPECT_EQ(word_dictionary->search("pad"), false);
  EXPECT_EQ(word_dictionary->search("bad"), true);
  EXPECT_EQ(word_dictionary->search(".ad"), true);
  EXPECT_EQ(word_dictionary->search("b.."), true);
  delete word_dictionary;
}