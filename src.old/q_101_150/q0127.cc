#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <string>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 127.
 *      Word Ladder
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   A “transformation sequence” from word ‘beginWord’ to word ‘endWord’
 *   using a dictionary ‘wordList’ is a sequence of words ‘beginWord -> s₁
 *   -> s₂ -> ... -> sₖ’ such
 *       - Every adjacent pair of words differs by a single
 *       - Every ‘sᵢ’ for ‘1 ≤ i ≤ k’ is in ‘wordList’ . Note that
 *   ‘beginWord’ does not need to be in ‘wordList’
 *       -  ‘sₖ = endWord’
 *   Given two words, ‘beginWord’ and ‘endWord’ , and a dictionary
 *   ‘wordList’ , return “the “number of words” in the “shortest
 *   transformation sequence” from” ‘beginWord’ “to” ‘endWord’ “, or ” ‘0’
 *   “ if no such sequence exists.” 
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ beginWord.length ≤ 10’
 *   • ‘endWord.length = beginWord.length’
 *   • ‘1 ≤ wordList.length ≤ 5000’
 *   • ‘wordList[i].length = beginWord.length’
 *   • ‘beginWord’ , ‘endWord’ , and ‘wordList[i]’ consist of lowercase English letters.
 *   • ‘beginWord ≠ endWord’
 *   • All the words in ‘wordList’ are “unique” .
 *
 */

struct q127 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
      unordered_set<string> words(wordList.begin(), wordList.end());
      unordered_set<string> memos;
      queue<string>         step;
      int                   res = 0;
      step.emplace(move(beginWord));
      memos.insert(step.front());
      while (true != step.empty()) {
        queue<string> curr = move(step);
        ++res;
        while (true != curr.empty()) {
          auto s = curr.front(); curr.pop();
          if (s == endWord) return res;
          for (int i = 0; i < s.size(); ++i) {
            string new_word = s;
            for (char c = 'a'; c <= 'z'; ++c) {
              new_word[i] = c;
              if (memos.find(new_word) == memos.end() && words.find(new_word) != words.end()) {
                memos.insert(new_word);
                step.emplace(new_word);
              }
            }
          }
        }
      }
      return 0;
    }
  };

  class Solution *solution;
};

TEST_F(q127, sample_input01) {
  solution = new Solution();
  string beginWord = "hit";
  string endWord = "cog";
  vector<string> wordList = {"hot", "dot", "dog", "lot", "log", "cog"};
  int exp = 5;
  int act = solution->ladderLength(beginWord, endWord, wordList);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q127, sample_input02) {
  solution = new Solution();
  string beginWord = "hit";
  string endWord = "cog";
  vector<string> wordList = {"hot", "dot", "dog", "lot", "log"};
  int exp = 0;
  int act = solution->ladderLength(beginWord, endWord, wordList);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q127, input01) {
  solution = new Solution();
  string beginWord = "a";
  string endWord = "c";
  vector<string> wordList = {"a", "b", "c"};
  int exp = 2;
  int act = solution->ladderLength(beginWord, endWord, wordList);
  EXPECT_EQ(act, exp);
  delete solution;
}