#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 131.
 *      Palindrome Partitioning
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a string ‘s’ , partition ‘s’ such that every substring of the
 *   partition is a “palindrome” . Return all possible palindrome
 *   partitioning of ‘s’
 *   A “palindrome” string is a string that reads the same backward as
 *   forward.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ s.length ≤ 16’
 *   • ‘s’ contains only lowercase English letters.
 *
 */

struct q131 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    inline bool is_palindrome(const string &s, size_t l, size_t r) {
      while (l < r) if (s[l++] != s[r--]) return false;
      return true;
    }

    inline void dfs(vector<vector<string>> &res, const string &s, size_t beg, vector<string> &current) {
      if (beg >= s.size()) res.push_back(current);
      for (size_t R = beg; R < s.size(); ++R) {
        if (is_palindrome(s, beg, R)) {
          current.emplace_back(s.substr(beg, R - beg + 1));
          dfs(res, s, R + 1, current);
          current.pop_back();
        }
      }
    }

   public:
    vector<vector<string>> partition(string s) {
      vector<vector<string>> res;
      vector<string>         tmp;
      dfs(res, s, 0, tmp);
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q131, sample_input01) {
  solution = new Solution();
  string s = "aab";
  vector<vector<string>> exp = {{"a", "a", "b"}, {"aa", "b"}};
  vector<vector<string>> act = solution->partition(s);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q131, sample_input02) {
  solution = new Solution();
  string s = "a";
  vector<vector<string>> exp = {{"a"}};
  vector<vector<string>> act = solution->partition(s);
  EXPECT_EQ(act, exp);
  delete solution;
}