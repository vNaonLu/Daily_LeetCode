#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 130.
 *      Surrounded Regions
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an ‘m x n’ matrix ‘board’ containing ‘'X'’ and ‘'O'’ , “capture
 *   all regions that are 4-directionallysurrounded by” ‘'X'’
 *   A region is “captured” by flipping all ‘'O'’ s into ‘'X'’ s in that
 *   surrounded region.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘m = board.length’
 *   • ‘n = board[i].length’
 *   • ‘1 ≤ m, n ≤ 200’
 *   • ‘board[i][j]’ is ‘'X'’ or ‘'O'’ .
 *
 */

struct q130 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    int m = 0, n = 0;
    vector<int> direct = {1, 0, 0, 1, -1, 0, 0, -1};
    vector<vector<bool>> visit;
    bool isSurreounded(const vector<vector<char>>& board, vector<pair<int, int>>& path) {
      bool res = true;
      int beg = 0;
      char val = board[path[0].first][path[0].second];
      visit[path[0].first][path[0].second] = true;
      while (beg < path.size()) {
        int len = path.size() - beg;
        while (len--) {
          auto c = path[beg++];
          if (c.first == 0 || c.first == m - 1 || c.second == 0 || c.second == n - 1)
            res = false;
          for (int i = 0; i < direct.size(); i++) {
            int x = c.first + direct[i];
            int y = c.second + direct[++i];
            if (x >= 0 && x < m &&
                y >= 0 && y < n &&
                board[x][y] == val && !visit[x][y]) {
              visit[x][y] = true;
              path.emplace_back(x, y);
            }
          }
        }
      }
      return res;
    }
   public:
    void solve(vector<vector<char>>& board) {
      m = board.size();
      n = board[0].size();
      visit.resize(m, vector<bool>(n, false));
      for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
          if (i > 0 && i < m - 1 && j > 0 && j < n - 1 && board[i][j] == 'O' && !visit[i][j]) {
            int beg = 0;
            vector<pair<int, int>> path;
            path.emplace_back(i, j);
            if (isSurreounded(board, path)) {
              for (const auto& cur : path) {
                board[cur.first][cur.second] = 'X';
              }
            }
          }
        }
      }
    }
  };

  class Solution *solution;
};

TEST_F(q130, sample_input01) {
  solution = new Solution();
  vector<vector<char>> board = {{'X', 'X', 'X', 'X'}, {'X', 'O', 'O', 'X'}, {'X', 'X', 'O', 'X'}, {'X', 'O', 'X', 'X'}};
  vector<vector<char>> exp = {{'X', 'X', 'X', 'X'}, {'X', 'X', 'X', 'X'}, {'X', 'X', 'X', 'X'}, {'X', 'O', 'X', 'X'}};
  solution->solve(board);
  // Assume the first argument is answer.
  EXPECT_EQ(board, exp);
  delete solution;
}

TEST_F(q130, sample_input02) {
  solution = new Solution();
  vector<vector<char>> board = {{'X'}};
  vector<vector<char>> exp = {{'X'}};
  solution->solve(board);
  // Assume the first argument is answer.
  EXPECT_EQ(board, exp);
  delete solution;
}