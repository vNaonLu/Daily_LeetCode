#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <unordered_map>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 138.
 *      Copy List with Random Pointer
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   A linked list of length ‘n’ is given such that each node contains an
 *   additional random pointer, which could point to any node in the list,
 *   or ‘null’
 *   Construct a <a
 *   href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy"
 *   target="_blank"> “deep copy” </a> of the list. The deep copy should
 *   consist of exactly ‘n’ “brand new” nodes, where each new node has its
 *   value set to the value of its corresponding original node. Both the
 *   ‘next’ and ‘random’ pointer of the new nodes should point to new nodes
 *   in the copied list such that the pointers in the original list and
 *   copied list represent the same list state. “None of the pointers in
 *   the new list should point to nodes in the original list”
 *   For example, if there are two nodes ‘X’ and ‘Y’ in the original list,
 *   where ‘X.random --> Y’ , then for the corresponding two nodes ‘x’ and
 *   ‘y’ in the copied list, ‘x.random --> y’
 *   Return “the head of the copied linked list”
 *   The linked list is represented in the input/output as a list of ‘n’
 *   nodes. Each node is represented as a pair of ‘[val, random_index]’
 *       -  ‘val’ : an integer representing ‘Node.val’
 *       -  ‘random_index’ : the index of the node (range from ‘0’ to ‘n-1’
 *   ) that the ‘random’ pointer points to, or ‘null’ if it does not point
 *   to any
 *   Your code will “only” be given the ‘head’ of the original linked list.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘0 ≤ n ≤ 1000’
 *   • ‘-10⁴ ≤ Node.val ≤ 10⁴’
 *   • ‘Node.random’ is ‘null’ or is pointing to some node in the linked list.
 *
 */

struct q138 : public ::testing::Test {
  // Leetcode answer here
  // Definition for a Node.
  class Node {
  public:
      int   val;
      Node* next;
      Node* random;

      Node(int _val) {
          val = _val;
          next = NULL;
          random = NULL;
      }
  };

  class Solution {
   public:
    Node* copyRandomList(Node* head) {
      unordered_map<Node*, pair<int, int>> pos_rdpos;
      queue<Node*>                         nodes;
      vector<Node*>                        res;
      int                                  idx = 0;
      Node                                 *p = head;
      while (nullptr != p) {
        pos_rdpos[p].first = idx++;
        res.emplace_back(new Node(p->val));
        p = p->next;
      }
      res.emplace_back(nullptr);
      pos_rdpos[nullptr] = make_pair(idx, -1);
      p = head;
      while (nullptr != p) {
        pos_rdpos[p].second = pos_rdpos[p->random].first;
        nodes.emplace(p);
        p = p->next;
      }

      for (int i = 0; i < res.size() - 1; ++i) {
        auto curr = res[i];
        curr->next = res[i + 1];
        curr->random = res[pos_rdpos[head].second];
        head = head->next;
      }

      return res.front();
    }
  };

  class Solution *solution;
};

TEST_F(q138, NOT_IMPLEMENT) {
   EXPECT_TRUE("NOT IMPLEMENT");
}