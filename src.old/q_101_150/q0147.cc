#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/listnode.hpp>
#include <set>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 147.
 *      Insertion Sort List
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘head’ of a singly linked list, sort the list using
 *   “insertion sort” , and return “the sorted list's head”
 *   The steps of the “insertion sort”
 *       1. Insertion sort iterates, consuming one input element each
 *   repetition and growing a sorted output
 *       2. At each iteration, insertion sort removes one element from the
 *   input data, finds the location it belongs within the sorted list and
 *   inserts it
 *       3. It repeats until no input elements
 *   The following is a graphical example of the insertion sort algorithm.
 *   The partially sorted list (black) initially contains only the first
 *   element in the list. One element (red) is removed from the input data
 *   and inserted in-place into the sorted list with each iteration.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the list is in the range ‘[1, 5000]’ .
 *   • ‘-5000 ≤ Node.val ≤ 5000’
 *
 */

struct q147 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    struct _compare {
      inline bool operator()(const ListNode* lhs, const ListNode* rhs) const noexcept {
        return lhs->val < rhs->val;
      }
    };

   public:
    ListNode* insertionSortList(ListNode* head) {
      if (nullptr == head) return nullptr;
      multiset<ListNode*, _compare> sort_map;
      while (head != nullptr) {
        auto p = head;
        sort_map.insert(new ListNode(p->val));
        head = head->next;
      }
      /// link
      for (auto it = sort_map.begin(); it != sort_map.end(); ++it) {
        auto next = it;
        if (++next != sort_map.end())
          (*it)->next = *(next);
      }
      return *(sort_map.begin());
    }
  };

  class Solution *solution;
};

TEST_F(q147, sample_input01) {
  solution = new Solution();
  ListNode* head = ListNode::generate({4, 2, 1, 3});
  ListNode* exp = ListNode::generate({1, 2, 3, 4});
  EXPECT_LISTNODE_EQ(solution->insertionSortList(head), exp);
  delete solution;
}

TEST_F(q147, sample_input02) {
  solution = new Solution();
  ListNode* head = ListNode::generate({-1, 5, 3, 4, 0});
  ListNode* exp = ListNode::generate({-1, 0, 3, 4, 5});
  EXPECT_LISTNODE_EQ(solution->insertionSortList(head), exp);
  delete solution;
}