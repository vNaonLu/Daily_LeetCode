#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/listnode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 142.
 *      Linked List Cycle II
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘head’ of a linked list, return “the node where the cycle
 *   begins. If there is no cycle, return ” ‘null’
 *   There is a cycle in a linked list if there is some node in the list
 *   that can be reached again by continuously following the ‘next’
 *   pointer. Internally, ‘pos’ is used to denote the index of the node
 *   that tail's ‘next’ pointer is connected to ( “0-indexed” ). It is ‘-1’
 *   if there is no cycle. “Note that” ‘pos’ “is not passed as a parameter”
 *    “Do not modify” the linked list.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of the nodes in the list is in the range ‘[0, 10⁴]’ .
 *   • ‘-10⁵ ≤ Node.val ≤ 10⁵’
 *   • ‘pos’ is ‘-1’ or a “valid index” in the linked-list.
 *
 */

struct q142 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    ListNode *detectCycle(ListNode *head) {
      auto p = head, tmp = head;
      while (p != nullptr) {
        p   = p->next;
        tmp = tmp->next;
        if (p) {
          p = p->next;
          if (tmp == p) {
            tmp = head;
            break;
          }
        }
      }
      while (p != nullptr && p != tmp) {
        p   = p->next;
        tmp = tmp->next;
      }
      return p;
    }
  };

  class Solution *solution;
};

TEST_F(q142, NOT_IMPLEMENT) { EXPECT_TRUE("NOT IMPLEMENT"); }