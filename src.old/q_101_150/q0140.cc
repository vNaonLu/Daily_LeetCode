#include <gtest/gtest.h>
#include <array>
#include <iostream>
#include <leetcode/anyorder.hpp>
#include <memory>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 140.
 *      Word Break II
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a string ‘s’ and a dictionary of strings ‘wordDict’ , add spaces
 *   in ‘s’ to construct a sentence where each word is a valid dictionary
 *   word. Return all such possible sentences in “any order”
 *    “Note” that the same word in the dictionary may be reused multiple
 *   times in the segmentation.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ s.length ≤ 20’
 *   • ‘1 ≤ wordDict.length ≤ 1000’
 *   • ‘1 ≤ wordDict[i].length ≤ 10’
 *   • ‘s’ and ‘wordDict[i]’ consist of only lowercase English letters.
 *   • All the strings of ‘wordDict’ are “unique” .
 *
 */

struct q140 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    struct trie {
      array<unique_ptr<trie>, 26> next;
      bool end = false;
    };
    unique_ptr<trie> root;

    void build_trie(const string &word) {
      auto p = root.get();

      for (auto &c : word) {
        auto &node = p->next[c - 'a'];
        if (node == nullptr) {
          node = make_unique<trie>();
        }
        p = node.get();
      }

      p->end = true;
    }

    void build_trie(const vector<string> &dict) {
      root = make_unique<trie>();
      for (auto &s : dict) {
        build_trie(s);
      }
    }

    string append(const string &s, string &&next) {
      return (s.empty() ? "" : (s + " ")) + std::move(next);
    }

    template <typename iterator>
    void helper(iterator beg, iterator end, string cr, trie *ct, vector<string> &res) {
      auto it = beg;
      auto p = ct;
      while (it != end) {
        p = p->next[*(it++) - 'a'].get();
        if (p == nullptr) {
          break;
        } else {
          if (p->end) {
            helper(it, end,
                   append(cr, string(beg, it)),
                   root.get(), res);
          }
        }
      }

      if (nullptr != p && p->end) {
        res.emplace_back(append(cr, string(beg, it)));
      }
    }

   public:
    vector<string> wordBreak(string s, vector<string> &wordDict) {
      vector<string> res;
      build_trie(wordDict);
      helper(s.begin(), s.end(), "", root.get(), res);

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q140, sample_input01) {
  solution = new Solution();
  string s = "catsanddog";
  vector<string> wordDict = {"cat", "cats", "and", "sand", "dog"};
  vector<string> exp = {"cats and dog", "cat sand dog"};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->wordBreak(s, wordDict), exp);
  delete solution;
}

TEST_F(q140, sample_input02) {
  solution = new Solution();
  string s = "pineapplepenapple";
  vector<string> wordDict = {"apple", "pen", "applepen", "pine", "pineapple"};
  vector<string> exp = {"pine apple pen apple", "pineapple pen apple", "pine applepen apple"};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->wordBreak(s, wordDict), exp);
  delete solution;
}

TEST_F(q140, sample_input03) {
  solution = new Solution();
  string s = "catsandog";
  vector<string> wordDict = {"cats", "dog", "sand", "and", "cat"};
  vector<string> exp = {};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->wordBreak(s, wordDict), exp);
  delete solution;
}