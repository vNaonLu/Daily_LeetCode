#include <gtest/gtest.h>
#include <iostream>
#include <string>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1419.
 *       Minimum Number of Frogs Croaking
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given the string ‘croakOfFrogs’ , which represents a
 *   combination of the string ‘'croak'’ from different frogs, that is,
 *   multiple frogs can croak at the same time, so multiple ‘'croak'’ are
 *    “Return the minimum number of ” different “ frogs to finish all the
 *   croaks in the given string.”
 *   A valid ‘'croak'’ means a frog is printing five letters ‘'c'’ , ‘'r'’
 *   , ‘'o'’ , ‘'a'’ , and ‘'k'’ “sequentially” . The frogs have to print
 *   all five letters to finish a croak. If the given string is not a
 *   combination of a valid ‘'croak'’ return ‘-1’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ croakOfFrogs.length ≤ 10⁵’
 *   • ‘croakOfFrogs’ is either ‘'c'’ , ‘'r'’ , ‘'o'’ , ‘'a'’ , or ‘'k'’ .
 *
 */

struct q1419 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int minNumberOfFrogs(string croakOfFrogs) {
      if (croakOfFrogs.size() % 5 != 0 || croakOfFrogs.back() != 'k') return -1;
      vector<int> croak(5, 0);
      for (const auto &c : croakOfFrogs) {
        switch (c) {
          case 'c':
            ++croak[0];
            if (croak[4] != 0) --croak[4];
            break;
          case 'r':
            ++croak[1];
            if (croak[0] <= 0) return -1;
            --croak[0];
            break;
          case 'o':
            ++croak[2];
            if (croak[1] <= 0) return -1;
            --croak[1];
            break;
          case 'a':
            ++croak[3];
            if (croak[2] <= 0) return -1;
            --croak[2];
            break;
          case 'k':
            ++croak[4];
            if (croak[3] <= 0) return -1;
            --croak[3];
            break;
          default:
            return -1;
        }
      }
      for (int i = 0; i < 4; ++i) if (croak[i] != 0) return -1;
      return croak.back();
    }
  };

  class Solution *solution;
};

TEST_F(q1419, sample_input01) {
  solution = new Solution();
  string croakOfFrogs = "croakcroak";
  int exp = 1;
  int act = solution->minNumberOfFrogs(croakOfFrogs);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1419, sample_input02) {
  solution = new Solution();
  string croakOfFrogs = "crcoakroak";
  int exp = 2;
  int act = solution->minNumberOfFrogs(croakOfFrogs);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1419, sample_input03) {
  solution = new Solution();
  string croakOfFrogs = "croakcrook";
  int exp = -1;
  int act = solution->minNumberOfFrogs(croakOfFrogs);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1419, input01) {
  solution = new Solution();
  string croakOfFrogs = "crocakcroraoakk";
  int exp = 2;
  int act = solution->minNumberOfFrogs(croakOfFrogs);
  EXPECT_EQ(act, exp);
  delete solution;
}