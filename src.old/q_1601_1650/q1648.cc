#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/anyorder.hpp>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1648.
 *       Sell Diminishing-Valued Colored Balls
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You have an ‘inventory’ of different colored balls, and there is a
 *   customer that wants ‘orders’ balls of “any”
 *   The customer weirdly values the colored balls. Each colored ball's
 *   value is the number of balls “of that color” you currently have in
 *   your ‘inventory’ . For example, if you own ‘6’ yellow balls, the
 *   customer would pay ‘6’ for the first yellow ball. After the
 *   transaction, there are only ‘5’ yellow balls left, so the next yellow
 *   ball is then valued at ‘5’ (i.e., the value of the balls decreases as
 *   you sell more to the
 *   You are given an integer array, ‘inventory’ , where ‘inventory[i]’
 *   represents the number of balls of the ‘iᵗʰ’ color that you initially
 *   own. You are also given an integer ‘orders’ , which represents the
 *   total number of balls that the customer wants. You can sell the balls
 *   “in any order”
 *   Return “the “maximum” total value that you can attain after selling ”
 *   ‘orders’ “ colored balls” . As the answer may be too large, return it
 *   “modulo ” ‘10^(9 )+ 7’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ inventory.length ≤ 10⁵’
 *   • ‘1 ≤ inventory[i] ≤ 10⁹’
 *   • ‘1 ≤ orders ≤ min(sum(inventory[i]), 10⁹)’
 *
 */

struct q1648 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    inline constexpr static int kMod = 1e9 + 7;

  public:
    int maxProfit(vector<int> &inventory, int orders) {
      inventory.emplace_back(0);
      sort(inventory.begin(), inventory.end());
      int hi = inventory.size() - 1, nondecreasing = 1;
      int64_t res = 0;
      while (orders > 0) {
        while (inventory[hi] == inventory[hi - 1]) {
          ++nondecreasing;
          --hi;
        }

        auto d = inventory[hi] - inventory[hi - 1];
        auto c = (orders - 1) / nondecreasing;
        auto r = (orders - 1) % nondecreasing;
        if (c >= d) {
          c = d - 1;
          r = nondecreasing - 1;
        }

        res += ((int64_t)(inventory[hi] + inventory[hi] - c) * (c + 1)) / 2 * nondecreasing;
        res -= (int64_t)(nondecreasing - 1 - r) * (inventory[hi] - c);
        res %= kMod;
        orders -= (c + 1) * nondecreasing;
        --hi;
        ++nondecreasing;
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1648, sample_input01) {
  solution = new Solution();
  vector<int> inventory = {2, 5};
  int orders = 4;
  int exp = 14;
  int act = solution->maxProfit(inventory, orders);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1648, sample_input02) {
  solution = new Solution();
  vector<int> inventory = {3, 5};
  int orders = 6;
  int exp = 19;
  int act = solution->maxProfit(inventory, orders);
  EXPECT_EQ(act, exp);
  delete solution;
}