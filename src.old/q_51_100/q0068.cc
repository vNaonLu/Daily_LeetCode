#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 68.
 *     Text Justification
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an array of strings ‘words’ and a width ‘maxWidth’ , format the
 *   text such that each line has exactly ‘maxWidth’ characters and is
 *   fully (left and right)
 *   You should pack your words in a greedy approach; that is, pack as many
 *   words as you can in each line. Pad extra spaces ‘' '’ when necessary
 *   so that each line has exactly ‘maxWidth’
 *   Extra spaces between words should be distributed as evenly as
 *   possible. If the number of spaces on a line does not divide evenly
 *   between words, the empty slots on the left will be assigned more
 *   spaces than the slots on the
 *   For the last line of text, it should be left-justified and no extra
 *   space is inserted between
 *    “Note:”
 *       - A word is defined as a character sequence consisting of
 *   non-space characters
 *       - Each word's length is guaranteed to be greater than 0 and not
 *   exceed
 *       - The input array ‘words’ contains at least one word.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ words.length ≤ 300’
 *   • ‘1 ≤ words[i].length ≤ 20’
 *   • ‘words[i]’ consists of only English letters and symbols.
 *   • ‘1 ≤ maxWidth ≤ 100’
 *   • ‘words[i].length ≤ maxWidth’
 *
 */

struct q68 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    int max_width;

    template <typename Iterator>
    inline pair<int, int> getWordCountLength(Iterator beg, Iterator end) {
      int count = 0,
          length = 0;
      while (beg != end) {
        length += (*beg++).size();
        ++count;
      }
      return make_pair(count, length);
    }

    template <typename Iterator>
    string centerJustified(Iterator &p, Iterator end) {
      auto [cnt, len] = getWordCountLength(p, end);
      if (cnt == 1) return leftJustified(p, end);
      string res;
      res.resize(max_width, ' ');
      int remain_space = max_width - len,
          gap = cnt - 1,
          each_space = remain_space / gap,
          mod = remain_space % gap;
      int idx = 0;
      while (p != end) {
        for (const auto &c : *p) {
          res[idx++] = c;
        }
        idx += each_space + (--mod >= 0 ? 1 : 0);
        ++p;
      }
      return res;
    }

    template <typename Iterator>
    string leftJustified(Iterator &p, Iterator end) {
      int idx = 0;
      string res;
      res.resize(max_width, ' ');
      while (p != end) {
        for (const auto &c : *p) {
          res[idx++] = c;
        }
        ++idx;  /// space
        ++p;
      }
      return res;
    }

   public:
    vector<string> fullJustify(vector<string> &words, int maxWidth) {
      vector<string>::iterator left = words.begin();
      vector<string> res;
      int curr_length = 0;
      this->max_width = maxWidth;
      for (auto it = words.begin(); it != words.end(); ++it) {
        if (curr_length > max_width - (int)(*it).size()) {
          res.push_back(centerJustified(left, it));
          curr_length = 0;
        }
        curr_length += (*it).size();
        ++curr_length;  /// at least one space
      }
      if (left != words.end()) {
        res.push_back(leftJustified(left, words.end()));
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q68, sample_input01) {
  solution = new Solution();
  vector<string> words = {"This", "is", "an", "example", "of", "text", "justification."};
  int maxWidth = 16;
  vector<string> exp = {"This    is    an", "example  of text", "justification.  "};
  vector<string> act = solution->fullJustify(words, maxWidth);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q68, sample_input02) {
  solution = new Solution();
  vector<string> words = {"What", "must", "be", "acknowledgment", "shall", "be"};
  int maxWidth = 16;
  vector<string> exp = {"What   must   be", "acknowledgment  ", "shall be        "};
  vector<string> act = solution->fullJustify(words, maxWidth);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q68, sample_input03) {
  solution = new Solution();
  vector<string> words = {"Science", "is", "what", "we", "understand", "well", "enough", "to", "explain", "to", "a", "computer.", "Art", "is", "everything", "else", "we", "do"};
  int maxWidth = 20;
  vector<string> exp = {"Science  is  what we", "understand      well", "enough to explain to", "a  computer.  Art is", "everything  else  we", "do                  "};
  vector<string> act = solution->fullJustify(words, maxWidth);
  EXPECT_EQ(act, exp);
  delete solution;
}