#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/anyorder.hpp>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 77.
 *     Combinations
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given two integers ‘n’ and ‘k’ , return “all possible combinations of”
 *   ‘k’ “numbers out of the range” ‘[1, n]’
 *   You may return the answer in “any order” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n ≤ 20’
 *   • ‘1 ≤ k ≤ n’
 *
 */

struct q77 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    void helper(const int &n, const int &k, vector<vector<int>> &r, vector<int> &cur, int c = 1) {
      if (cur.size() == k) {
        r.push_back(cur);
        return;
      }
      if (c > n) return;
      cur.reserve(k);
      for (int i = c; i <= n; ++i) {
        cur.push_back(i);
        helper(n, k, r, cur, i + 1);
        cur.pop_back();
      }
    }
   public:
    vector<vector<int>> combine(int n, int k) {
      vector<vector<int>> res;
      vector<int> tmp;
      helper(n, k, res, tmp);
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q77, sample_input01) {
  solution = new Solution();
  int n = 1;
  int k = 1;
  vector<vector<int>> exp = {{1}};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->combine(n, k), exp);
  delete solution;
}