#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 63.
 *     Unique Paths II
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   A robot is located at the top-left corner of a ‘m x n’ grid (marked
 *   'Start' in the diagram
 *   The robot can only move either down or right at any point in time. The
 *   robot is trying to reach the bottom-right corner of the grid (marked
 *   'Finish' in the diagram
 *   Now consider if some obstacles are added to the grids. How many unique
 *   paths would there
 *   An obstacle and space is marked as ‘1’ and ‘0’ respectively in the
 *   grid.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘m =obstacleGrid.length’
 *   • ‘n =obstacleGrid[i].length’
 *   • ‘1 ≤ m, n ≤ 100’
 *   • ‘obstacleGrid[i][j]’ is ‘0’ or ‘1’ .
 *
 */

struct q63 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
      int m = obstacleGrid.size(),
          n = obstacleGrid[0].size();
      vector<vector<int>> dp(m, vector<int>(n, 0));
      dp[0][0] = obstacleGrid[0][0] == 1 ? 0 : 1;
      for (int i = 1; i < m; ++i) dp[i][0] = obstacleGrid[i][0] == 1 ? 0 : dp[i - 1][0];
      for (int j = 1; j < n; ++j) dp[0][j] = obstacleGrid[0][j] == 1 ? 0 : dp[0][j - 1];
      for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
          if (obstacleGrid[i][j] == 1) {
            dp[i][j] = 0;
          } else {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
          }
        }
      }
      return dp.back().back();
    }
  };

  class Solution *solution;
};

TEST_F(q63, sample_input01) {
  solution = new Solution();
  vector<vector<int>> obstacleGrid = {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};
  int exp = 2;
  EXPECT_EQ(solution->uniquePathsWithObstacles(obstacleGrid), exp);
  delete solution;
}

TEST_F(q63, sample_input02) {
  solution = new Solution();
  vector<vector<int>> obstacleGrid = {{0, 1}, {0, 0}};
  int exp = 1;
  EXPECT_EQ(solution->uniquePathsWithObstacles(obstacleGrid), exp);
  delete solution;
}