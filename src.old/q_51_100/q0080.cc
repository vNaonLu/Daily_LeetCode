#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 80.
 *     Remove Duplicates from Sorted Array II
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an integer array ‘nums’ sorted in “non-decreasing order” ,
 *   remove some duplicates <a
 *   href="https://en.wikipedia.org/wiki/In-place_algorithm"
 *   target="_blank"> “in-place” </a> such that each unique element appears
 *   “at most twice” . The “relative order” of the elements should be kept
 *   the “same”
 *   Since it is impossible to change the length of the array in some
 *   languages, you must instead have the result be placed in the “first
 *   part” of the array ‘nums’ . More formally, if there are ‘k’ elements
 *   after removing the duplicates, then the first ‘k’ elements of ‘nums’
 *   should hold the final result. It does not matter what you leave beyond
 *   the first ‘k’
 *   Return ‘k’ “ after placing the final result in the first ” ‘k’ “ slots
 *   of ” ‘nums’
 *   Do “not” allocate extra space for another array. You must do this by
 *   “modifying the input array <a
 *   href="https://en.wikipedia.org/wiki/In-place_algorithm"
 *   target="_blank">in-place</a>” with O(1) extra
 *    “Custom Judge:”
 *   The judge will test your solution with the following
 *   int[] nums = [...]; // Input
 *   int[] expectedNums = [...]; // The expected answer with correct
 *   int k = removeDuplicates(nums); // Calls your
 *   assert k ==
 *   for (int i = 0; i < k; i++)
 *       assert nums[i] ==
 *   If all assertions pass, then your solution will be “accepted” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ nums.length ≤ 3 × 10⁴’
 *   • ‘-10⁴ ≤ nums[i] ≤ 10⁴’
 *   • ‘nums’ is sorted in “non-decreasing” order.
 *
 */

struct q80 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int removeDuplicates(vector<int>& nums) {
      if (nums.size() <= 2) return nums.size();
      int j = 2;
      for (int i = 2; i < nums.size(); ++i) {
        if (nums[i] != nums[j - 2]) {
          nums[j] = nums[i];
          ++j;
        }
      }
      return j;
    }
  };

  class Solution *solution;
};

TEST_F(q80, sample_input01) {
  solution = new Solution();
  vector<int> nums = {1, 1, 1, 2, 2, 3};
  int exp = 5;
  int act = solution->removeDuplicates(nums);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q80, sample_input02) {
  solution = new Solution();
  vector<int> nums = {0, 0, 1, 1, 1, 1, 2, 3, 3};
  int exp = 7;
  int act = solution->removeDuplicates(nums);
  EXPECT_EQ(act, exp);
  delete solution;
}