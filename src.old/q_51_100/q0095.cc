#include <gtest/gtest.h>

#include <iostream>
#include <leetcode/treenode.hpp>
#include <map>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 95.
 *     Unique Binary Search Trees II
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an integer ‘n’ , return “all the structurally unique “BST'” s
 *   (binary search trees), which has exactly ” ‘n’ “ nodes of unique
 *   values from” ‘1’ “to” ‘n’ . Return the answer in “any order” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n ≤ 8’
 *
 */

struct q95 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    vector<TreeNode *> helper(int beg, int end, map<pair<int, int>, vector<TreeNode *>> &dp) {
      vector<TreeNode *> res;
      if (beg > end) {
        res.push_back(nullptr);
        return res;
      }

      if (dp.count({beg, end})) return dp[{beg, end}];

      for (int i = beg; i <= end; ++i) {
        auto left = helper(beg, i - 1, dp);
        auto right = helper(i + 1, end, dp);
        for (auto l : left) {
          for (auto r : right) {
            TreeNode *p = new TreeNode(i, l, r);
            res.push_back(p);
          }
        }
      }

      dp[{beg, end}] = res;
      return res;
    }

   public:
    vector<TreeNode *> generateTrees(int n) {
      map<pair<int, int>, vector<TreeNode *>> dp;
      return helper(1, n, dp);
    }
  };

  class Solution *solution;
};

TEST_F(q95, sample_input01) {
  solution = new Solution();
  int n = 3;
  vector<TreeNode *> exp = {TreeNode::generate({1, NULL_TREENODE, 2, NULL_TREENODE, 3}),
                            TreeNode::generate({1, NULL_TREENODE, 3, 2}),
                            TreeNode::generate({2, 1, 3}),
                            TreeNode::generate({3, 1, NULL_TREENODE, NULL_TREENODE, 2}),
                            TreeNode::generate({3, 2, NULL_TREENODE, 1})};
  vector<TreeNode*> act = solution->generateTrees(n);
  ASSERT_EQ(exp.size(), act.size());
  for (int i = 0; i < exp.size(); ++i) {
    EXPECT_TREENODE_EQ(act[i], exp[i]);
  }
  delete solution;
}

TEST_F(q95, sample_input02) {
  solution = new Solution();
  int n = 1;
  vector<TreeNode *> exp = {TreeNode::generate({1})};
  vector<TreeNode *> act = solution->generateTrees(n);
  ASSERT_EQ(exp.size(), act.size());
  for (int i = 0; i < exp.size(); ++i) {
    EXPECT_TREENODE_EQ(act[i], exp[i]);
  }
  delete solution;
}