#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/anyorder.hpp>
#include <string>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 51.
 *     N-Queens
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   The “n-queens” puzzle is the problem of placing ‘n’ queens on an ‘n x
 *   n’ chessboard such that no two queens attack each
 *   Given an integer ‘n’ , return “all distinct solutions to the “n-queens
 *   puzzle” ” . You may return the answer in “any order”
 *   Each solution contains a distinct board configuration of the n-queens'
 *   placement, where ‘'Q'’ and ‘'.'’ both indicate a queen and an empty
 *   space, respectively.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n ≤ 9’
 *
 */

struct q51 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    int                    n;
    vector<vector<string>> res;
    unordered_set<int>     occupy_col;
    bool validate(vector<string> &curr, int x, int y) {
      /// check diagonal
      int dx = x - 1, dy = y - 1;
      while (dx >= 0 && dy >= 0) {
        if (curr[dx][dy] != '.') return false;
        --dx;
        --dy;
      }
      dx = x + 1, dy = y + 1;
      while (dx < n && dy < n) {
        if (curr[dx][dy] != '.') return false;
        ++dx;
        ++dy;
      }
      dx = x - 1, dy = y + 1;
      while (dx >= 0 && dy < n) {
        if (curr[dx][dy] != '.') return false;
        --dx;
        ++dy;
      }
      dx = x + 1, dy = y - 1;
      while (dx < n && dy >= 0) {
        if (curr[dx][dy] != '.') return false;
        ++dx;
        --dy;
      }
      return true;
    }

    void solver(vector<string> &curr, int queens = 0, int row = 0) {
      if (queens == n) {
        res.emplace_back(curr);
        return;
      }

      for (int i = 0; i < n; ++i) {
        if (occupy_col.count(i)) continue;
        curr[row][i] = 'Q';
        if (queens == 0 || validate(curr, row, i)) {
          occupy_col.emplace(i);
          solver(curr, queens + 1, row + 1);
          occupy_col.erase(i);
        }
        curr[row][i] = '.';
      }
    }

   public:
    vector<vector<string>> solveNQueens(int n) {
      res.clear();
      this->n = n;

      string temp;
      for (int i = 0; i < n; ++i) {
        temp.push_back('.');
      }
      vector<string> board(n, temp);
      solver(board);

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q51, sample_input01) {
  solution = new Solution();
  int n = 4;
  vector<vector<string>> exp = {{".Q..", "...Q", "Q...", "..Q."}, {"..Q.", "Q...", "...Q", ".Q.."}};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->solveNQueens(n), exp);
  delete solution;
}

TEST_F(q51, sample_input02) {
  solution = new Solution();
  int n = 1;
  vector<vector<string>> exp = {{"Q"}};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->solveNQueens(n), exp);
  delete solution;
}