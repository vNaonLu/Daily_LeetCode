#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 93.
 *     Restore IP Addresses
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   A “valid IP address” consists of exactly four integers separated by
 *   single dots. Each integer is between ‘0’ and ‘255’ ( “inclusive” ) and
 *   cannot have leading
 *       - For example, ‘'0.1.2.201'’ and ‘'192.168.1.1'’ are “valid” IP
 *   addresses, but ‘'0.011.255.245'’ , ‘'192.168.1.312'’ and
 *   ‘'192.168@1.1'’ are “invalid” IP
 *   Given a string ‘s’ containing only digits, return “all possible valid
 *   IP addresses that can be formed by inserting dots into ” ‘s’ . You are
 *   “not” allowed to reorder or remove any digits in ‘s’ . You may return
 *   the valid IP addresses in “any” order.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘0 ≤ s.length ≤ 20’
 *   • ‘s’ consists of digits only.
 *
 */

struct q93 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    bool valid_ip(const string &s) {
      int num = 0;
      for (const auto &c : s) num = num * 10 + (c - '0');
      if (num != 0 && s[0] == '0') return false;
      if (num == 0 && s.size() > 1) return false;
      return num >= 0 && num <= 255;
    }
    void helper(const string &s, string ip, vector<string> &r, int ip_cnt = 0, int beg = 0) {
      if (ip_cnt == 4 && beg == s.size()) {
        r.push_back(ip);
      } else if (ip_cnt < 4) {
        for (int i = 1; i < 4 && beg + i <= s.size(); ++i) {
          string current = s.substr(beg, i);
          if (valid_ip(current)) {
            if (ip_cnt == 0) {
              helper(s, current, r, ip_cnt + 1, beg + i);
            } else {
              helper(s, ip + "." + current, r, ip_cnt + 1, beg + i);
            }
          }
        }
      }
    }
   public:
    vector<string> restoreIpAddresses(string s) {
      vector<string> res;
      if (s.size() > 12) return res;
      helper(s, "", res);
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q93, sample_input01) {
  solution = new Solution();
  string s = "25525511135";
  vector<string> exp = {"255.255.11.135", "255.255.111.35"};
  EXPECT_EQ(solution->restoreIpAddresses(s), exp);
  delete solution;
}

TEST_F(q93, sample_input02) {
  solution = new Solution();
  string s = "0000";
  vector<string> exp = {"0.0.0.0"};
  EXPECT_EQ(solution->restoreIpAddresses(s), exp);
  delete solution;
}

TEST_F(q93, sample_input03) {
  solution = new Solution();
  string s = "1111";
  vector<string> exp = {"1.1.1.1"};
  EXPECT_EQ(solution->restoreIpAddresses(s), exp);
  delete solution;
}

TEST_F(q93, sample_input04) {
  solution = new Solution();
  string s = "010010";
  vector<string> exp = {"0.10.0.10", "0.100.1.0"};
  EXPECT_EQ(solution->restoreIpAddresses(s), exp);
  delete solution;
}

TEST_F(q93, sample_input05) {
  solution = new Solution();
  string s = "101023";
  vector<string> exp = {"1.0.10.23", "1.0.102.3", "10.1.0.23", "10.10.2.3", "101.0.2.3"};
  EXPECT_EQ(solution->restoreIpAddresses(s), exp);
  delete solution;
}