#include <gtest/gtest.h>
#include <iostream>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 278.
 *      First Bad Version
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are a product manager and currently leading a team to develop a
 *   new product. Unfortunately, the latest version of your product fails
 *   the quality check. Since each version is developed based on the
 *   previous version, all the versions after a bad version are also
 *   Suppose you have ‘n’ versions ‘[1, 2, ..., n]’ and you want to find
 *   out the first bad one, which causes all the following ones to be
 *   You are given an API ‘bool isBadVersion(version)’ which returns
 *   whether ‘version’ is bad. Implement a function to find the first bad
 *   version. You should minimize the number of calls to the API.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ bad ≤ n ≤ 2³¹ - 1’
 *
 */

int exp;
bool isBadVersion(int x) {
  return x >= exp;
}

struct q278 : public ::testing::Test {
  // Leetcode answer here

  class Solution {
   public:
    int firstBadVersion(int n) {
      int l = 1, r = n;
      while (l < r) {
        int mid = l + (r - l) / 2;
        if (isBadVersion(mid))
          r = mid;
        else
          l = mid + 1;
      }
      return l;
    }
  };

  class Solution *solution;
};

TEST_F(q278, sample_input01) {
  solution = new Solution{};
  int n = 5;
  exp = 4;
  int act = solution->firstBadVersion(n);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q278, sample_input02) {
  solution = new Solution{};
  int n = 1;
  exp = 1;
  int act = solution->firstBadVersion(n);
  EXPECT_EQ(act, exp);
  delete solution;
}