#include <gtest/gtest.h>
#include <leetcode/anyorder.hpp>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 282.
 *      Expression Add Operators
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a string ‘num’ that contains only digits and an integer ‘target’
 *   , return “ “all possibilities” to insert the binary operators ” ‘'+'’
 *   “, ” ‘'-'’ “, and/or ” ‘'×'’ “ between the digits of ” ‘num’ “ so that
 *   the resultant expression evaluates to the ” ‘target’ “ value”
 *   Note that operands in the returned expressions “should not” contain
 *   leading zeros.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ num.length ≤ 10’
 *   • ‘num’ consists of only digits.
 *   • ‘-2³¹ ≤ target ≤ 2³¹ - 1’
 *
 */

struct q282 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    long T;
    void helper(vector<string> &r, string &s, int beg, long prev, long res, string cur = "") {
      if (beg == s.size() && res == T) {
        r.push_back(cur);
        return;
      }
      string sbs = "";
      long number = 0;
      for (int i = beg; i < s.size(); ++i) {
        sbs += s[i];
        number = number * 10 + (s[i] - '0');
        if (sbs.size() > 1 && sbs[0] == '0') break;
        if (beg == 0) {
          helper(r, s, i + 1, number, number, sbs);
        } else {
          helper(r, s, i + 1, number, number + res, cur + "+" + sbs);
          helper(r, s, i + 1, -number, res - number, cur + "-" + sbs);
          helper(r, s, i + 1, number * prev, (prev * number) + (res - prev), cur + "*" + sbs);
        }
      }
    }
   public:
    vector<string> addOperators(string num, int target) {
      vector<string> res;
      T = target;
      helper(res, num, 0, 0, 0);
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q282, sample_input01) {
  solution = new Solution();
  string num = "123";
  int target = 6;
  vector<string> exp = {"1*2*3", "1+2+3"};
  EXPECT_EQ_ANY_ORDER(solution->addOperators(num, target), exp);
  delete solution;
}

TEST_F(q282, sample_input02) {
  solution = new Solution();
  string num = "232";
  int target = 8;
  vector<string> exp = {"2*3+2", "2+3*2"};
  EXPECT_EQ_ANY_ORDER(solution->addOperators(num, target), exp);
  delete solution;
}

TEST_F(q282, sample_input03) {
  solution = new Solution();
  string num = "105";
  int target = 5;
  vector<string> exp = {"1*0+5", "10-5"};
  EXPECT_EQ_ANY_ORDER(solution->addOperators(num, target), exp);
  delete solution;
}

TEST_F(q282, sample_input04) {
  solution = new Solution();
  string num = "00";
  int target = 0;
  vector<string> exp = {"0*0", "0+0", "0-0"};
  EXPECT_EQ_ANY_ORDER(solution->addOperators(num, target), exp);
  delete solution;
}

TEST_F(q282, sample_input05) {
  solution = new Solution();
  string num = "3456237490";
  int target = 9191;
  vector<string> exp = {};
  EXPECT_EQ_ANY_ORDER(solution->addOperators(num, target), exp);
  delete solution;
}