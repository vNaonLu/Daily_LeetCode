#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <unordered_map>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 290.
 *      Word Pattern
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a ‘pattern’ and a string ‘s’ , find if ‘s’ follows the same
 *   Here “follow” means a full match, such that there is a bijection
 *   between a letter in ‘pattern’ and a “non-empty” word in ‘s’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ pattern.length ≤ 300’
 *   • ‘pattern’ contains only lower-case English letters.
 *   • ‘1 ≤ s.length ≤ 3000’
 *   • ‘s’ contains only lower-case English letters and spaces ‘' '’ .
 *   • ‘s’ “does not contain” any leading or trailing spaces.
 *   • All the words in ‘s’ are separated by a “single space” .
 *
 */

struct q290 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    bool wordPattern(string pattern, string s) {
      vector<string> words;
      for (int i = 0, l = 0; i < s.size(); ++i) {
        if (s[i] == ' ') {
          string word = s.substr(l, i - l);
          if (!word.empty()) words.push_back(word);
          l = i + 1;
        } else if (i == s.size() - 1) {
          string word = s.substr(l, i - l + 1);
          if (!word.empty()) words.push_back(word);
        }
      }
      if (pattern.size() != words.size()) return false;
      unordered_map<char, string> p2w;
      unordered_map<string, char> w2p;
      for (int i = 0; i < pattern.size(); ++i) {
        if ((p2w.count(pattern[i]) && p2w[pattern[i]] == words[i] &&
             w2p.count(words[i]) && w2p[words[i]] == pattern[i]) ||
            (!p2w.count(pattern[i]) && !w2p.count(words[i]))) {
          p2w[pattern[i]] = words[i];
          w2p[words[i]] = pattern[i];
        } else {
          return false;
        }
      }
      return true;
    }
  };

  class Solution *solution;
};

TEST_F(q290, sample_input01) {
  solution = new Solution();
  string pattern = "abba";
  string s = "dog cat cat dog";
  bool exp = true;
  EXPECT_EQ(solution->wordPattern(pattern, s), exp);
  delete solution;
}

TEST_F(q290, sample_input02) {
  solution = new Solution();
  string pattern = "abba";
  string s = "dog cat cat fish";
  bool exp = false;
  EXPECT_EQ(solution->wordPattern(pattern, s), exp);
  delete solution;
}

TEST_F(q290, sample_input03) {
  solution = new Solution();
  string pattern = "aaaa";
  string s = "dog cat cat dog";
  bool exp = false;
  EXPECT_EQ(solution->wordPattern(pattern, s), exp);
  delete solution;
}

TEST_F(q290, sample_input04) {
  solution = new Solution();
  string pattern = "abba";
  string s = "dog dog dog dog";
  bool exp = false;
  EXPECT_EQ(solution->wordPattern(pattern, s), exp);
  delete solution;
}