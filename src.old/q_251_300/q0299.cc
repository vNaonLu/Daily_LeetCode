#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <unordered_map>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 299.
 *      Bulls and Cows
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are playing the “<a
 *   href="https://en.wikipedia.org/wiki/Bulls_and_Cows"
 *   target="_blank">Bulls and Cows</a>” game with your
 *   You write down a secret number and ask your friend to guess what the
 *   number is. When your friend makes a guess, you provide a hint with the
 *   following
 *       - The number of 'bulls', which are digits in the guess that are in
 *   the correct
 *       - The number of 'cows', which are digits in the guess that are in
 *   your secret number but are located in the wrong position.
 *   Specifically, the non-bull digits in the guess that could be
 *   rearranged such that they become
 *   Given the secret number ‘secret’ and your friend's guess ‘guess’ ,
 *   return “the hint for your friend's guess”
 *   The hint should be formatted as ‘'xAyB'’ , where ‘x’ is the number of
 *   bulls and ‘y’ is the number of cows. Note that both ‘secret’ and
 *   ‘guess’ may contain duplicate digits.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ secret.length, guess.length ≤ 1000’
 *   • ‘secret.length = guess.length’
 *   • ‘secret’ and ‘guess’ consist of digits only.
 *
 */

struct q299 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    string getHint(string secret, string guess) {
      auto a    = (int)0;
      auto b    = (int)0;
      auto memo = unordered_map<char, int>();
      for (auto c : secret) {
        ++memo[c];
      }
      for (auto c : guess) {
        auto find = memo.find(c);
        if (find != memo.end() && find->second-- > 0) {
          ++b;
        }
      }
      auto s_beg = secret.begin();
      auto g_beg = guess.begin();
      while (s_beg != secret.end()) {
        if (*s_beg++ == *g_beg++) {
          ++a;
          --b;
        }
      }
      return to_string(a) + "A" + to_string(b) + "B";
    }
  };

  class Solution *solution;
};

TEST_F(q299, sample_input01) {
  solution      = new Solution();
  string secret = "1807";
  string guess  = "7810";
  string exp    = "1A3B";
  string act    = solution->getHint(secret, guess);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q299, sample_input02) {
  solution      = new Solution();
  string secret = "1123";
  string guess  = "0111";
  string exp    = "1A1B";
  string act    = solution->getHint(secret, guess);
  EXPECT_EQ(act, exp);
  delete solution;
}