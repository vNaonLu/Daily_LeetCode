#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>
#include <limits>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 671.
 *      Second Minimum Node In a Binary Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a non-empty special binary tree consisting of nodes with the
 *   non-negative value, where each node in this tree has exactly ‘two’ or
 *   ‘zero’ sub-node. If the node has two sub-nodes, then this node's value
 *   is the smaller value among its two sub-nodes. More formally, the
 *   property ‘root.val = min(root.left.val, root.right.val)’ always
 *   Given such a binary tree, you need to output the “second minimum”
 *   value in the set made of all the nodes' value in the whole
 *   If no such second minimum value exists, output -1
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[1, 25]’ .
 *   • ‘1 ≤ Node.val ≤ 2³¹ - 1’
 *   • ‘root.val = min(root.left.val, root.right.val)’ for each internal node of
 * the tree.
 *
 */

struct q671 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    void find(TreeNode *p, long &res, long min) {
      if (nullptr != p) {
        if (min < p->val && p->val < res) {
          res = p->val;
        } else if (min == p->val) {
          find(p->left, res, min);
          find(p->right, res, min);
        }
      }
    }

  public:
    int findSecondMinimumValue(TreeNode *root) {
      auto res = numeric_limits<long>::max();
      find(root, res, nullptr == root ? -1 : root->val);
      return res < numeric_limits<long>::max() ? res : -1;
    }
  };

  class Solution *solution;
};

TEST_F(q671, sample_input01) {
  solution = new Solution();
  TreeNode *root =
      TreeNode::generate({2, 2, 5, NULL_TREENODE, NULL_TREENODE, 5, 7});
  int exp = 5;
  int act = solution->findSecondMinimumValue(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}

TEST_F(q671, sample_input02) {
  solution       = new Solution();
  TreeNode *root = TreeNode::generate({2, 2, 2});
  int       exp  = -1;
  int       act  = solution->findSecondMinimumValue(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}