#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <unordered_map>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 684.
 *      Redundant Connection
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   In this problem, a tree is an “undirected graph” that is connected and
 *   has no
 *   You are given a graph that started as a tree with ‘n’ nodes labeled
 *   from ‘1’ to ‘n’ , with one additional edge added. The added edge has
 *   two “different” vertices chosen from ‘1’ to ‘n’ , and was not an edge
 *   that already existed. The graph is represented as an array ‘edges’ of
 *   length ‘n’ where ‘edges[i] = [aᵢ, bᵢ]’ indicates that there is an edge
 *   between nodes ‘aᵢ’ and ‘bᵢ’ in the
 *   Return “an edge that can be removed so that the resulting graph is a
 *   tree of ” ‘n’ “ nodes” . If there are multiple answers, return the
 *   answer that occurs last in the input.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = edges.length’
 *   • ‘3 ≤ n ≤ 1000’
 *   • ‘edges[i].length = 2’
 *   • ‘1 ≤ aᵢ < bᵢ ≤ edges.length’
 *   • ‘aᵢ ≠ bᵢ’
 *   • There are no repeated edges.
 *   • The given graph is connected.
 *
 */

struct q684 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    unordered_map<int, vector<int>> graph;
    inline bool is_connected(int x, int y) noexcept {
      int n = graph.size();
      vector<bool> visit(n + 1, false);
      queue<int> q;
      q.push(x);
      visit[0] = true;
      visit[x] = true;

      while (q.empty() == false) {
        int curr = q.front(); q.pop();
        for (const auto &to : graph[curr]) {
          if ((curr == x && to == y) || (curr == y && to == x)) continue;
          if (visit[to] == false) {
            visit[to] = true;
            q.push(to);
          }
        }
      }

      for (const auto b : visit) {
        if (b == false) {
          return false;
        }
      }
      return true;
    }

   public:
    vector<int> findRedundantConnection(vector<vector<int>> &edges) {
      int n = 0;
      for (const auto &e : edges) {
        n = max({e[0], e[1], n});
        graph[e[0]].emplace_back(e[1]);
        graph[e[1]].emplace_back(e[0]);
      }
      for (auto it = edges.rbegin(); it != edges.rend(); ++it) {
        if (is_connected((*it)[0], (*it)[1])) {
          return *it;
        }
      }
      return {-1, -1};
    }
  };

  class Solution *solution;
};

TEST_F(q684, sample_input01) {
  solution = new Solution();
  vector<vector<int>> edges = {{1, 2}, {1, 3}, {2, 3}};
  vector<int> exp = {2, 3};
  vector<int> act = solution->findRedundantConnection(edges);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q684, sample_input02) {
  solution = new Solution();
  vector<vector<int>> edges = {{1, 2}, {2, 3}, {3, 4}, {1, 4}, {1, 5}};
  vector<int> exp = {1, 4};
  vector<int> act = solution->findRedundantConnection(edges);
  EXPECT_EQ(act, exp);
  delete solution;
}