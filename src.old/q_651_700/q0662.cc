#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>
#include <queue>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 662.
 *      Maximum Width of Binary Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary tree, return “the “maximum width” of the
 *   given tree”
 *   The “maximum width” of a tree is the maximum “width” among all
 *   The “width” of one level is defined as the length between the
 *   end-nodes (the leftmost and rightmost non-null nodes), where the null
 *   nodes between the end-nodes are also counted into the length
 *   It is “guaranteed” that the answer will in the range of “32-bit”
 *   signed integer.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[1, 3000]’ .
 *   • ‘-100 ≤ Node.val ≤ 100’
 *
 */

struct q662 : public ::testing::Test {
  // Leetcode answer here
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
   private:
    using ull = unsigned long long;

   public:
    int widthOfBinaryTree(TreeNode* root) {
      if (nullptr == root) return 0;
      ull                         res = 1;
      queue<pair<TreeNode*, ull>> q;
      q.emplace(root, 0);
      while (!q.empty()) {
        queue<pair<TreeNode*, ull>> temp = move(q);
        ull                         left = -1;
        while (!temp.empty()) {
          auto [p, index] = temp.front(); temp.pop();
          index <<= 1;
          if (nullptr != p->left) {
            if (left == -1) {
              left = index;
            } else {
              res = max(res, index - left + 1);
            }
            q.emplace(p->left, index);
          }
          if (nullptr != p->right) {
            if (left == -1) {
              left = index + 1;
            } else {
              res = max(res, index - left + 2);
            }
            q.emplace(p->right, index + 1);
          }
        }
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q662, sample_input01) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1, 3, 2, 5, 3, NULL_TREENODE, 9});
  int exp = 4;
  int act = solution->widthOfBinaryTree(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}

TEST_F(q662, sample_input02) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1, 3, NULL_TREENODE, 5, 3});
  int exp = 2;
  int act = solution->widthOfBinaryTree(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}

TEST_F(q662, sample_input03) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1, 3, 2, 5});
  int exp = 2;
  int act = solution->widthOfBinaryTree(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}

TEST_F(q662, input01) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1, 3, 2, 5, NULL_TREENODE, NULL_TREENODE, 9, 6, NULL_TREENODE, NULL_TREENODE, 7});
  int exp = 8;
  int act = solution->widthOfBinaryTree(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}

TEST_F(q662, input02) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({0, 0, 0, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE, NULL_TREENODE, 0, 0, NULL_TREENODE});
  int exp = 2;
  int act = solution->widthOfBinaryTree(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}