#include <gtest/gtest.h>
#include <iostream>
#include <string>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 657.
 *      Robot Return to Origin
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   There is a robot starting at the position ‘(0, 0)’ , the origin, on a
 *   2D plane. Given a sequence of its moves, judge if this robot “ends up
 *   at ” ‘(0, 0)’ after it completes its
 *   You are given a string ‘moves’ that represents the move sequence of
 *   the robot where ‘moves[i]’ represents its ‘iᵗʰ’ move. Valid moves are
 *   ‘'R'’ (right), ‘'L'’ (left), ‘'U'’ (up), and ‘'D'’
 *   Return ‘true’ “ if the robot returns to the origin after it finishes
 *   all of its moves, or ” ‘false’ “ otherwise”
 *    “Note” : The way that the robot is 'facing' is irrelevant. ‘'R'’ will
 *   always make the robot move to the right once, ‘'L'’ will always make
 *   it move left, etc. Also, assume that the magnitude of the robot's
 *   movement is the same for each move.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ moves.length ≤ 2 × 10⁴’
 *   • ‘moves’ only contains the characters ‘'U'’ , ‘'D'’ , ‘'L'’ and ‘'R'’ .
 *
 */

struct q657 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    bool judgeCircle(string moves) {
      auto forward = vector<int>(4, 0);
      for (auto c : moves) {
        switch (c) {
        case 'U':
          ++forward[0];
          break;
        case 'D':
          ++forward[1];
          break;
        case 'L':
          ++forward[2];
          break;
        case 'R':
          ++forward[3];
          break;
        default:
          break;
        }
      }
      return forward[0] == forward[1] && forward[2] == forward[3];
    }
  };

  class Solution *solution;
};

TEST_F(q657, sample_input01) {
  solution     = new Solution();
  string moves = "UD";
  bool   exp   = true;
  bool   act   = solution->judgeCircle(moves);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q657, sample_input02) {
  solution     = new Solution();
  string moves = "LL";
  bool   exp   = false;
  bool   act   = solution->judgeCircle(moves);
  EXPECT_EQ(act, exp);
  delete solution;
}