#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 655.
 *      Print Binary Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary tree, construct a “0-indexed” ‘m x n’
 *   string matrix ‘res’ that represents a “formatted layout” of the tree.
 *   The formatted layout matrix should be constructed using the following
 *       - The “height” of the tree is ‘height’ and the number of rows ‘m’
 *   should be equal to ‘height + 1’
 *       - The number of columns ‘n’ should be equal to ‘2ʰᵉⁱᵍʰᵗ⁺¹ - 1’
 *       - Place the “root node” in the “middle” of the “top row” (more
 *   formally, at location ‘res[0][(n-1)/2]’
 *       - For each node that has been placed in the matrix at position
 *   ‘res[r][c]’ , place its “left child” at ‘res[r+1][c-2ʰᵉⁱᵍʰᵗ⁻ʳ⁻¹]’ and
 *   its “right child” at ‘res[r+1][c+2ʰᵉⁱᵍʰᵗ⁻ʳ⁻¹]’
 *       - Continue this process until all the nodes in the tree have been
 *       - Any empty cells should contain the empty string ‘''’
 *   Return “the constructed matrix ” ‘res’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[1, 2¹⁰]’ .
 *   • ‘-99 ≤ Node.val ≤ 99’
 *   • The depth of the tree will be in the range ‘[1, 10]’ .
 *
 */

struct q655 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    int findDepth(TreeNode *p) {
      if (nullptr == p) {
        return 0;
      }
      return 1 + max(findDepth(p->left), findDepth(p->right));
    }

    void layout(vector<vector<string>> &res, TreeNode *p, int r, int c) {
      if (nullptr != p) {
        auto h    = (int)res.size();
        res[r][c] = to_string(p->val);
        if (r + 1 < h) {
          layout(res, p->left, r + 1, c - (1 << (h - r - 2)));
          layout(res, p->right, r + 1, c + (1 << (h - r - 2)));
        }
      }
    }

  public:
    vector<vector<string>> printTree(TreeNode *root) {
      auto h   = findDepth(root);
      auto w   = (1 << h) - 1;
      auto res = vector<vector<string>>(h, vector<string>(w, ""));
      layout(res, root, 0, (w - 1) / 2);
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q655, sample_input01) {
  solution                    = new Solution();
  TreeNode              *root = TreeNode::generate({1, 2});
  vector<vector<string>> exp  = {
       { "", "1", ""},
       {"2",  "", ""}
  };
  vector<vector<string>> act = solution->printTree(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}

TEST_F(q655, sample_input02) {
  solution                    = new Solution();
  TreeNode              *root = TreeNode::generate({1, 2, 3, NULL_TREENODE, 4});
  vector<vector<string>> exp  = {
       {"",  "",  "", "1", "",  "", ""},
       {"", "2",  "",  "", "", "3", ""},
       {"",  "", "4",  "", "",  "", ""},
  };
  vector<vector<string>> act = solution->printTree(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}