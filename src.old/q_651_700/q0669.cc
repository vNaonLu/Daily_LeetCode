#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 669.
 *      Trim a Binary Search Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary search tree and the lowest and highest
 *   boundaries as ‘low’ and ‘high’ , trim the tree so that all its
 *   elements lies in ‘[low, high]’ . Trimming the tree should “not” change
 *   the relative structure of the elements that will remain in the tree
 *   (i.e., any node's descendant should remain a descendant). It can be
 *   proven that there is a “unique answer”
 *   Return “the root of the trimmed binary search tree” . Note that the
 *   root may change depending on the given bounds.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree in the range ‘[1, 10⁴]’ .
 *   • ‘0 ≤ Node.val ≤ 10⁴’
 *   • The value of each node in the tree is “unique” .
 *   • ‘root’ is guaranteed to be a valid binary search tree.
 *   • ‘0 ≤ low ≤ high ≤ 10⁴’
 *
 */

struct q669 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    TreeNode* trim_low(TreeNode* root, int target) {
      if (nullptr == root) {
        return nullptr;
      } else if (root->val < target) {
        return trim_low(root->right, target);
      } else {
        root->left = trim_low(root->left, target);

        return root;
      }
    }

    TreeNode* trim_high(TreeNode* root, int target) {
      if (nullptr == root) {
        return nullptr;
      } else if (root->val > target) {
        return trim_high(root->left, target);
      } else {
        root->right = trim_high(root->right, target);

        return root;
      }
    }

   public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
      root = trim_low(root, low);
      root = trim_high(root, high);

      return root;
    }
  };

  class Solution *solution;
};

TEST_F(q669, sample_input01) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1, 0, 2});
  int low = 1;
  int high = 2;
  TreeNode* exp = TreeNode::generate({1, NULL_TREENODE, 2});
  TreeNode* act = solution->trimBST(root, low, high);
  EXPECT_TREENODE_EQ(act, exp);
  TreeNode::release(root, exp, act);
  delete solution;
}

TEST_F(q669, sample_input02) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({3, 0, 4, NULL_TREENODE, 2, NULL_TREENODE, NULL_TREENODE, 1});
  int low = 1;
  int high = 3;
  TreeNode* exp = TreeNode::generate({3, 2, NULL_TREENODE, 1});
  TreeNode* act = solution->trimBST(root, low, high);
  EXPECT_TREENODE_EQ(act, exp);
  TreeNode::release(root, exp, act);
  delete solution;
}