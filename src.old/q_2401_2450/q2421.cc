#include <algorithm>
#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 2421.
 *       Number of Good Paths
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   There is a tree (i.e. a connected, undirected graph with no cycles)
 *   consisting of ‘n’ nodes numbered from ‘0’ to ‘n - 1’ and exactly ‘n -
 *   1’
 *   You are given a “0-indexed” integer array ‘vals’ of length ‘n’ where
 *   ‘vals[i]’ denotes the value of the ‘iᵗʰ’ node. You are also given a 2D
 *   integer array ‘edges’ where ‘edges[i] = [aᵢ, bᵢ]’ denotes that there
 *   exists an “undirected” edge connecting nodes ‘aᵢ’ and ‘bᵢ’
 *   A “good path” is a simple path that satisfies the following
 *       1. The starting node and the ending node have the “same”
 *       2. All nodes between the starting node and the ending node have
 *   values “less than or equal to” the starting node (i.e. the starting
 *   node's value should be the maximum value along the
 *   Return “the number of distinct good paths”
 *   Note that a path and its reverse are counted as the “same” path. For
 *   example, ‘0 -> 1’ is considered to be the same as ‘1 -> 0’ . A single
 *   node is also considered as a valid path.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = vals.length’
 *   • ‘1 ≤ n ≤ 3 × 10⁴’
 *   • ‘0 ≤ vals[i] ≤ 10⁵’
 *   • ‘edges.length = n - 1’
 *   • ‘edges[i].length = 2’
 *   • ‘0 ≤ aᵢ, bᵢ < n’
 *   • ‘aᵢ ≠ bᵢ’
 *   • ‘edges’ represents a valid tree.
 *
 */

struct q2421 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    int find(vector<int> &v, int i) {
      if (i == v[i]) {
        return i;
      }
      v[i] = find(v, v[i]);
      return v[i];
    }

  public:
    int numberOfGoodPaths(vector<int> &vals, vector<vector<int>> &edges) {
      int                 n   = vals.size();
      int                 m   = edges.size();
      int                 res = 0;
      vector<vector<int>> x(n);
      vector<int>         v(n);
      for (int i = 0; i < n; ++i) {
        v[i] = i;
        x[i] = {vals[i], 1};
      }
      sort(edges.begin(), edges.end(), [&](auto &a, auto &b) {
        return max(vals[a[0]], vals[a[1]]) < max(vals[b[0]], vals[b[1]]);
      });
      for (int i = 0; i < m; ++i) {
        auto a = find(v, edges[i][0]);
        auto b = find(v, edges[i][1]);
        if (x[a][0] != x[b][0]) {
          if (x[a][0] > x[b][0]) {
            v[b] = a;
          } else {
            v[a] = b;
          }
        } else {
          v[a] = b;
          res += x[a][1] * x[b][1];
          x[b][1] += x[a][1];
        }
      }

      return res + n;
    }
  };

  class Solution *solution;
};

TEST_F(q2421, sample_input01) {
  solution                  = new Solution();
  vector<int>         vals  = {1, 3, 2, 1, 3};
  vector<vector<int>> edges = {
      {0, 1},
      {0, 2},
      {2, 3},
      {2, 4}
  };
  int exp = 6;
  int act = solution->numberOfGoodPaths(vals, edges);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q2421, sample_input02) {
  solution                  = new Solution();
  vector<int>         vals  = {1, 1, 2, 2, 3};
  vector<vector<int>> edges = {
      {0, 1},
      {1, 2},
      {2, 3},
      {2, 4}
  };
  int exp = 7;
  int act = solution->numberOfGoodPaths(vals, edges);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q2421, sample_input03) {
  solution                  = new Solution();
  vector<int>         vals  = {1};
  vector<vector<int>> edges = {};
  int                 exp   = 1;
  int                 act   = solution->numberOfGoodPaths(vals, edges);
  EXPECT_EQ(act, exp);
  delete solution;
}
