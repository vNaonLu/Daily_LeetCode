#include <algorithm>
#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 2279.
 *       Maximum Bags With Full Capacity of Rocks
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You have ‘n’ bags numbered from ‘0’ to ‘n - 1’ . You are given two
 *   “0-indexed” integer arrays ‘capacity’ and ‘rocks’ . The ‘iᵗʰ’ bag can
 *   hold a maximum of ‘capacity[i]’ rocks and currently contains
 *   ‘rocks[i]’ rocks. You are also given an integer ‘additionalRocks’ ,
 *   the number of additional rocks you can place in “any” of the
 *   Return “ the “maximum” number of bags that could have full capacity
 *   after placing the additional rocks in some bags.”
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = capacity.length = rocks.length’
 *   • ‘1 ≤ n ≤ 5 × 10⁴’
 *   • ‘1 ≤ capacity[i] ≤ 10⁹’
 *   • ‘0 ≤ rocks[i] ≤ capacity[i]’
 *   • ‘1 ≤ additionalRocks ≤ 10⁹’
 *
 */

struct q2279 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    int maximumBags(vector<int> &capacity, vector<int> &rocks,
                    int additionalRocks) {
      auto left = priority_queue<int, vector<int>, greater<int>>();
      auto res = (int)0;
      for (int i = 0; i < capacity.size(); ++i) {
        auto cnt = max(0, capacity[i] - rocks[i]);
        if (cnt > 0) {
          left.emplace(cnt);
        } else {
          ++res;
        }
      }
      while (!left.empty() && left.top() <= additionalRocks) {
        ++res;
        additionalRocks -= left.top();
        left.pop();
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q2279, sample_input01) {
  solution                    = new Solution();
  vector<int> capacity        = {2, 3, 4, 5};
  vector<int> rocks           = {1, 2, 4, 4};
  int         additionalRocks = 2;
  int         exp             = 3;
  int         act = solution->maximumBags(capacity, rocks, additionalRocks);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q2279, sample_input02) {
  solution                    = new Solution();
  vector<int> capacity        = {10, 2, 2};
  vector<int> rocks           = {2, 2, 0};
  int         additionalRocks = 100;
  int         exp             = 3;
  int         act = solution->maximumBags(capacity, rocks, additionalRocks);
  EXPECT_EQ(act, exp);
  delete solution;
}
