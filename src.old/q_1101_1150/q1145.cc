#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1145.
 *       Binary Tree Coloring Game
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Two players play a turn based game on a binary tree. We are given the
 *   ‘root’ of this binary tree, and the number of nodes ‘n’ in the tree.
 *   ‘n’ is odd, and each node has a distinct value from ‘1’ to ‘n’
 *   Initially, the first player names a value ‘x’ with ‘1 ≤ x ≤ n’ , and
 *   the second player names a value ‘y’ with ‘1 ≤ y ≤ n’ and ‘y ≠ x’ . The
 *   first player colors the node with value ‘x’ red, and the second player
 *   colors the node with value ‘y’
 *   Then, the players take turns starting with the first player. In each
 *   turn, that player chooses a node of their color (red if player 1, blue
 *   if player 2) and colors an “uncolored” neighbor of the chosen node
 *   (either the left child, right child, or parent of the chosen
 *   If (and only if) a player cannot choose such a node in this way, they
 *   must pass their turn. If both players pass their turn, the game ends,
 *   and the winner is the player that colored more
 *   You are the second player. If it is possible to choose such a ‘y’ to
 *   ensure you win the game, return ‘true’ . If it is not possible, return
 *   ‘false’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is ‘n’ .
 *   • ‘1 ≤ x ≤ n ≤ 100’
 *   • ‘n’ is odd.
 *   • 1 ≤ Node.val ≤ n
 *   • All the values of the tree are “unique” .
 *
 */

struct q1145 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    inline int count(TreeNode* p, int x, int& max_nodes) noexcept {
      if (nullptr == p) return 0;
      int total = count(p->left, x, max_nodes) + count(p->right, x, max_nodes) + 1;
      if (p->val == x) return 0;
      max_nodes = max(max_nodes, total);
      return total;
    }

   public:
    bool btreeGameWinningMove(TreeNode* root, int n, int x) {
      int max_nodes = 0;
      count(root, x, max_nodes);
      return max_nodes > n - max_nodes;
    }
  };

  class Solution *solution;
};

TEST_F(q1145, sample_input01) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11});
  int n = 11;
  int x = 3;
  bool exp = true;
  bool act = solution->btreeGameWinningMove(root, n, x);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}

TEST_F(q1145, sample_input02) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1, 2, 3});
  int n = 3;
  int x = 1;
  bool exp = false;
  bool act = solution->btreeGameWinningMove(root, n, x);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}