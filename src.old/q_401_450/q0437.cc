#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 437.
 *      Path Sum III
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary tree and an integer ‘targetSum’ , return
 *   “the number of paths where the sum of the valuesalong the path equals”
 *    ‘targetSum’
 *   The path does not need to start or end at the root or a leaf, but it
 *   must go downwards (i.e., traveling only from parent nodes to child
 *   nodes).
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[0, 1000]’ .
 *   • ‘-10⁹ ≤ Node.val ≤ 10⁹’
 *   • ‘-1000 ≤ targetSum ≤ 1000’
 *
 */

struct q437 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    int helper(const TreeNode* const p, int target, int sum = 0) {
      if (p == nullptr) return 0;
      sum += p->val;
      return helper(p->left, target, sum) +
             helper(p->right, target, sum) +
             (sum == target ? 1 : 0);
    }
   public:
    int pathSum(TreeNode* root, int targetSum) {
      if (root == nullptr) return 0;
      return helper(root, targetSum) +
             pathSum(root->left, targetSum) +
             pathSum(root->right, targetSum);
    }
  };

  class Solution *solution;
};

TEST_F(q437, sample_input01) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({10, 5, -3, 3, 2, NULL_TREENODE, 11, 3, -2, NULL_TREENODE, 1});
  int targetSum = 8;
  int exp = 3;
  EXPECT_EQ(solution->pathSum(root, targetSum), exp);
  delete solution;
}

TEST_F(q437, sample_input02) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({5, 4, 8, 11, NULL_TREENODE, 13, 4, 7, 2, NULL_TREENODE, NULL_TREENODE, 5, 1});
  int targetSum = 22;
  int exp = 3;
  EXPECT_EQ(solution->pathSum(root, targetSum), exp);
  delete solution;
}