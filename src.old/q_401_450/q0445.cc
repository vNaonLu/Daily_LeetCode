#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/listnode.hpp>
#include <stack>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 445.
 *      Add Two Numbers II
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given two “non-empty” linked lists representing two
 *   non-negative integers. The most significant digit comes first and each
 *   of their nodes contains a single digit. Add the two numbers and return
 *   the sum as a linked
 *   You may assume the two numbers do not contain any leading zero, except
 *   the number 0 itself.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in each linked list is in the range ‘[1, 100]’ .
 *   • ‘0 ≤ Node.val ≤ 9’
 *   • It is guaranteed that the list represents a number that does not have leading zeros.
 *
 */

struct q445 : public ::testing::Test {
  // Leetcode answer here
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode() : val(0), next(nullptr) {}
   *     ListNode(int x) : val(x), next(nullptr) {}
   *     ListNode(int x, ListNode *next) : val(x), next(next) {}
   * };
   */
  class Solution {
   private:
    stack<int> link(stack<int>& x, stack<int>& y) {
      stack<int> res;
      int carry = 0;
      while (!x.empty() && !y.empty()) {
        int sum = x.top() + y.top() + carry;
        x.pop(); y.pop();

        res.emplace(sum % 10);
        carry = sum / 10;
      }

      while (!x.empty()) {
        int sum = x.top() + carry;
        x.pop();

        res.emplace(sum % 10);
        carry = sum / 10;
      }

      while (!y.empty()) {
        int sum = y.top() + carry;
        y.pop();

        res.emplace(sum % 10);
        carry = sum / 10;
      }

      if (carry != 0) {
        res.emplace(carry);
      }

      return res;
    }

   public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
      stack<int> stk1, stk2;
      while (nullptr != l1) {
        stk1.emplace(l1->val);
        l1 = l1->next;
      }
      while (nullptr != l2) {
        stk2.emplace(l2->val);
        l2 = l2->next;
      }

      auto combine = link(stk1, stk2);
      ListNode dummy, *p = &dummy;
      while (!combine.empty()) {
        p->next = new ListNode(combine.top());
        combine.pop();
        p = p->next;
      }

      return dummy.next;
    }
  };

  class Solution *solution;
};

TEST_F(q445, sample_input01) {
  solution = new Solution();
  ListNode* l1 = ListNode::generate({7, 2, 4, 3});
  ListNode* l2 = ListNode::generate({5, 6, 4});
  ListNode* exp = ListNode::generate({7, 8, 0, 7});
  ListNode* act = solution->addTwoNumbers(l1, l2);
  EXPECT_LISTNODE_EQ(act, exp);
  ListNode::release(l1, l2, exp, act);
  delete solution;
}

TEST_F(q445, sample_input02) {
  solution = new Solution();
  ListNode* l1 = ListNode::generate({2, 4, 3});
  ListNode* l2 = ListNode::generate({5, 6, 4});
  ListNode* exp = ListNode::generate({8, 0, 7});
  ListNode* act = solution->addTwoNumbers(l1, l2);
  EXPECT_LISTNODE_EQ(act, exp);
  ListNode::release(l1, l2, exp, act);
  delete solution;
}

TEST_F(q445, sample_input03) {
  solution = new Solution();
  ListNode* l1 = ListNode::generate({0});
  ListNode* l2 = ListNode::generate({0});
  ListNode* exp = ListNode::generate({0});
  ListNode* act = solution->addTwoNumbers(l1, l2);
  EXPECT_LISTNODE_EQ(act, exp);
  ListNode::release(l1, l2, exp, act);
  delete solution;
}