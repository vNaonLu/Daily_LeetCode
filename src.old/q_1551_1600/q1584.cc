#include <gtest/gtest.h>
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1584.
 *       Min Cost to Connect All Points
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given an array ‘points’ representing integer coordinates of
 *   some points on a 2D-plane, where ‘points[i] = [xᵢ, yᵢ]’
 *   The cost of connecting two points ‘[xᵢ, yᵢ]’ and ‘[xⱼ, yⱼ]’ is the
 *   “manhattan distance” between them: ‘|xᵢ - xⱼ| + |yᵢ - yⱼ|’ , where
 *   ‘|val|’ denotes the absolute value of ‘val’
 *   Return “the minimum cost to make all points connected.” All points are
 *   connected if there is “exactly one” simple path between any two points
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ points.length ≤ 1000’
 *   • ‘-10⁶ ≤ xᵢ, yᵢ ≤ 10⁶’
 *   • All pairs ‘(xᵢ, yᵢ)’ are distinct.
 *
 */

struct q1584 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int minCostConnectPoints(vector<vector<int>>& points) {
      priority_queue<pair<int, int>, 
                     vector<pair<int, int>>,
                     greater<pair<int, int>>> pq;
      int                                     n = points.size();
      vector<bool>                            mst(n, false);
      pq.emplace(0, 0);

      int res = 0,
          edges = n;

      while (edges) {
        auto [cost, curr] = pq.top();
        pq.pop();

        if (mst[curr]) continue;

        mst[curr] = true;
        res += cost;
        --edges;

        for (int i = 0; i < n; ++i) {
          if (!mst[i]) {
            pq.emplace(abs(points[curr][0] - points[i][0]) + abs(points[curr][1] - points[i][1]), i);
          }
        }
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1584, sample_input01) {
  solution = new Solution();
  vector<vector<int>> points = {{0, 0}, {2, 2}, {3, 10}, {5, 2}, {7, 0}};
  int exp = 20;
  int act = solution->minCostConnectPoints(points);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1584, sample_input02) {
  solution = new Solution();
  vector<vector<int>> points = {{3, 12}, {-2, 5}, {-4, 1}};
  int exp = 18;
  int act = solution->minCostConnectPoints(points);
  EXPECT_EQ(act, exp);
  delete solution;
}