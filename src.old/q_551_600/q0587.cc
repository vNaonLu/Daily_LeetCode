#include <algorithm>
#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/anyorder.hpp>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 587.
 *      Erect the Fence
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given an array ‘trees’ where ‘trees[i] = [xᵢ, yᵢ]’ represents
 *   the location of a tree in the
 *   You are asked to fence the entire garden using the minimum length of
 *   rope as it is expensive. The garden is well fenced only if “all the
 *   trees are enclosed”
 *   Return “the coordinates of trees that are exactly located on the fence
 *   perimeter” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ points.length ≤ 3000’
 *   • ‘points[i].length = 2’
 *   • ‘0 ≤ xᵢ, yᵢ ≤ 100’
 *   • All the given points are “unique” .
 *
 */

struct q587 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    bool isClockwiseTrun(vector<int> &a, vector<int> &b, vector<int> &c) {
      return (((c[1] - b[1]) * (b[0] - a[0])) -
              ((b[1] - a[1]) * (c[0] - b[0]))) >= 0;
    }

  public:
    vector<vector<int>> outerTrees(vector<vector<int>> &trees) {
      auto res = vector<vector<int>>();
      auto n   = trees.size();
      auto cmp = [&](auto &a, auto &b) {
        return a[0] == b[0] ? a[1] < b[1] : a[0] < b[0];
      };

      sort(trees.begin(), trees.end(), cmp);

      for (int i = 0; i < n; ++i) {
        while (res.size() > 1 && !isClockwiseTrun(*(res.rbegin() + 1),
                                                  *(res.rbegin()), trees[i])) {
          res.pop_back();
        }
        res.emplace_back(trees[i]);
      }

      for (int i = n - 1; i >= 0; --i) {
        while (res.size() > 1 && !isClockwiseTrun(*(res.rbegin() + 1),
                                                  *(res.rbegin()), trees[i])) {
          res.pop_back();
        }
        res.emplace_back(trees[i]);
      }

      res.pop_back();
      sort(res.begin(), res.end(), cmp);
      res.erase(unique(res.begin(), res.end()), res.end());
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q587, sample_input01) {
  solution                  = new Solution();
  vector<vector<int>> trees = {
      {1, 1},
      {2, 2},
      {2, 0},
      {2, 4},
      {3, 3},
      {4, 2}
  };
  vector<vector<int>> exp = {
      {1, 1},
      {2, 0},
      {3, 3},
      {2, 4},
      {4, 2}
  };
  vector<vector<int>> act = solution->outerTrees(trees);
  EXPECT_EQ_ANY_ORDER(act, exp);
  delete solution;
}

TEST_F(q587, sample_input02) {
  solution                  = new Solution();
  vector<vector<int>> trees = {
      {1, 2},
      {2, 2},
      {4, 2}
  };
  vector<vector<int>> exp = {
      {4, 2},
      {2, 2},
      {1, 2}
  };
  vector<vector<int>> act = solution->outerTrees(trees);
  EXPECT_EQ_ANY_ORDER(act, exp);
  delete solution;
}