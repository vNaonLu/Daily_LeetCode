#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <unordered_map>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 567.
 *      Permutation in String
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given two strings ‘s1’ and ‘s2’ , return ‘true’ “ if ” ‘s2’ “ contains
 *   a permutation of ” ‘s1’ “, or ” ‘false’ “ otherwise”
 *   In other words, return ‘true’ if one of ‘s1’ 's permutations is the
 *   substring of ‘s2’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ s1.length, s2.length ≤ 10⁴’
 *   • ‘s1’ and ‘s2’ consist of lowercase English letters.
 *
 */

struct q567 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    bool checkInclusion(string s1, string s2) {
      unordered_map<int, int> key;
      vector<int> count(26, 0);
      int length = 0, left = 0;
      size_t key_size = s1.size();
      for (const auto &c : s1) ++key[c - 'a'];
      for (int i = 0; i < s2.size(); ++i) {
        ++length;
        ++count[s2[i] - 'a'];
        if (length > key_size) {
          --length;
          --count[s2[left++] - 'a'];
        }

        bool match = true;
        for (auto &[c, v] : key) {
          match &= count[c] == v;
        }
        if (match) return true;
      }
      return false;
    }
  };

  class Solution *solution;
};

TEST_F(q567, sample_input01) {
  solution = new Solution();
  string s1 = "ab";
  string s2 = "eidbaooo";
  bool exp = true;
  EXPECT_EQ(solution->checkInclusion(s1, s2), exp);
  delete solution;
}

TEST_F(q567, sample_input02) {
  solution = new Solution();
  string s1 = "ab";
  string s2 = "eidboaoo";
  bool exp = false;
  EXPECT_EQ(solution->checkInclusion(s1, s2), exp);
  delete solution;
}