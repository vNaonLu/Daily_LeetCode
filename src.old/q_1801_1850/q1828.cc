#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1828.
 *       Queries on Number of Points Inside a Circle
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given an array ‘points’ where ‘points[i] = [xᵢ, yᵢ]’ is the
 *   coordinates of the ‘iᵗʰ’ point on a 2D plane. Multiple points can have
 *   the “same”
 *   You are also given an array ‘queries’ where ‘queries[j] = [xⱼ, yⱼ,
 *   rⱼ]’ describes a circle centered at ‘(xⱼ, yⱼ)’ with a radius of ‘rⱼ’
 *   For each query ‘queries[j]’ , compute the number of points “inside”
 *   the ‘jᵗʰ’ circle. Points “on the border” of the circle are considered
 *   “inside”
 *   Return “an array ” ‘answer’ “, where ” ‘answer[j]’ “ is the answer to
 *   the ” ‘jᵗʰ’ “ query” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ points.length ≤ 500’
 *   • ‘points[i].length = 2’
 *   • ‘0 ≤ x⎽(​​​​​​i), y⎽(​​​​​​i) ≤ 500’
 *   • ‘1 ≤ queries.length ≤ 500’
 *   • ‘queries[j].length = 3’
 *   • ‘0 ≤ xⱼ, yⱼ ≤ 500’
 *   • ‘1 ≤ rⱼ ≤ 500’
 *   • All coordinates are integers.
 *
 */

struct q1828 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    vector<int> countPoints(vector<vector<int>> &points, vector<vector<int>> &queries) {
      vector<int> res;
      for (const auto &circle : queries) {
        int pts_cnt = 0, radius_sq = circle[2] * circle[2];
        for (const auto &pt : points) {
          int dx = pt[0] - circle[0],
              dy = pt[1] - circle[1];
          if (dx * dx + dy * dy <= radius_sq) ++pts_cnt;
        }
        res.emplace_back(pts_cnt);
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1828, sample_input01) {
  solution = new Solution();
  vector<vector<int>> points = {{1, 3}, {3, 3}, {5, 3}, {2, 2}};
  vector<vector<int>> queries = {{2, 3, 1}, {4, 3, 1}, {1, 1, 2}};
  vector<int> exp = {3, 2, 2};
  vector<int> act = solution->countPoints(points, queries);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1828, sample_input02) {
  solution = new Solution();
  vector<vector<int>> points = {{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}};
  vector<vector<int>> queries = {{1, 2, 2}, {2, 2, 2}, {4, 3, 2}, {4, 3, 3}};
  vector<int> exp = {2, 3, 2, 4};
  vector<int> act = solution->countPoints(points, queries);
  EXPECT_EQ(act, exp);
  delete solution;
}