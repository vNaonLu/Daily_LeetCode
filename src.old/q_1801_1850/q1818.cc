#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1818.
 *       Minimum Absolute Sum Difference
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given two positive integer arrays ‘nums1’ and ‘nums2’ , both
 *   of length ‘n’
 *   The “absolute sum difference” of arrays ‘nums1’ and ‘nums2’ is defined
 *   as the “sum” of ‘|nums1[i] - nums2[i]|’ for each ‘0 ≤ i < n’ (
 *   “0-indexed”
 *   You can replace “at most one” element of ‘nums1’ with “any” other
 *   element in ‘nums1’ to “minimize” the absolute sum
 *   Return the “minimum absolute sum difference “after” replacing at most
 *   one “ ” element in the array ‘nums1’ .” Since the answer may be large,
 *   return it “modulo” ‘10⁹ + 7’
 *    ‘|x|’ is defined
 *       -  ‘x’ if ‘x ≥ 0’ ,
 *       -  ‘-x’ if ‘x < 0’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = nums1.length’
 *   • ‘n = nums2.length’
 *   • ‘1 ≤ n ≤ 10⁵’
 *   • ‘1 ≤ nums1[i], nums2[i] ≤ 10⁵’
 *
 */

struct q1818 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    inline constexpr static int kMod = 1e9 + 7;
    int helper(vector<int> &nums1, vector<int> &nums2) {
      auto it1 = nums1.begin(),
           it2 = nums2.begin();
      int res = 0;
      while (it1 != nums1.end() && it2 != nums2.end()) {
        res += abs(*it1++ - *it2++);
      }

      return res;
    }

  public:
    int minAbsoluteSumDiff(vector<int> &nums1, vector<int> &nums2) {
      vector<int> memo(nums1.begin(), nums1.end());
      sort(memo.begin(), memo.end());

      auto it1 = nums1.begin(),
           it2 = nums2.begin();
      uint64_t origin = 0;
      while (it1 != nums1.end() && it2 != nums2.end()) {
        origin += abs(*it1++ - *it2++);
      }

      uint64_t res = origin;
      for (int i = 0; i < nums1.size(); ++i) {
        auto revert = origin - abs(nums1[i] - nums2[i]);
        auto ub = upper_bound(memo.begin(), memo.end(), nums2[i]);
        auto lb = lower_bound(memo.begin(), memo.end(), nums2[i]);

        if (lb != memo.end()) {
          res = min(res, revert + abs(*lb - nums2[i]));
        }
        if (ub != memo.begin()) {
          res = min(res, revert + abs(*(ub - 1) - nums2[i]));
        }
      }

      return res % kMod;
    }
  };

  class Solution *solution;
};

TEST_F(q1818, sample_input01) {
  solution = new Solution();
  vector<int> nums1 = {1, 7, 5};
  vector<int> nums2 = {2, 3, 5};
  int exp = 3;
  int act = solution->minAbsoluteSumDiff(nums1, nums2);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1818, sample_input02) {
  solution = new Solution();
  vector<int> nums1 = {2, 4, 6, 8, 10};
  vector<int> nums2 = {2, 4, 6, 8, 10};
  int exp = 0;
  int act = solution->minAbsoluteSumDiff(nums1, nums2);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1818, sample_input03) {
  solution = new Solution();
  vector<int> nums1 = {1, 10, 4, 4, 2, 7};
  vector<int> nums2 = {9, 3, 5, 1, 7, 4};
  int exp = 20;
  int act = solution->minAbsoluteSumDiff(nums1, nums2);
  EXPECT_EQ(act, exp);
  delete solution;
}