#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>
#include <map>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 987.
 *      Vertical Order Traversal of a Binary Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary tree, calculate the “vertical order
 *   traversal” of the binary
 *   For each node at position ‘(row, col)’ , its left and right children
 *   will be at positions ‘(row + 1, col - 1)’ and ‘(row + 1, col + 1)’
 *   respectively. The root of the tree is at ‘(0, 0)’
 *   The “vertical order traversal” of a binary tree is a list of
 *   top-to-bottom orderings for each column index starting from the
 *   leftmost column and ending on the rightmost column. There may be
 *   multiple nodes in the same row and same column. In such a case, sort
 *   these nodes by their
 *   Return “the “vertical order traversal” of the binary tree” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[1, 1000]’ .
 *   • ‘0 ≤ Node.val ≤ 1000’
 *
 */

struct q987 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    void travel(TreeNode *p, int row, int col,
                map<int, vector<pair<int, pair<int, int>>>> &res) {
      if (nullptr == p) {
        return;
      }
      res[col].emplace_back(p->val, make_pair(row, col));
      travel(p->left, row + 1, col - 1, res);
      travel(p->right, row + 1, col + 1, res);
    }

  public:
    vector<vector<int>> verticalTraversal(TreeNode *root) {
      auto mp  = map<int, vector<pair<int, pair<int, int>>>>();
      auto res = vector<vector<int>>();
      travel(root, 0, 0, mp);
      for (auto &[k, v] : mp) {
        sort(v.begin(), v.end(), [](auto &x, auto &y) {
          auto &rc_x = x.second;
          auto &rc_y = y.second;
          return rc_x.first == rc_y.first
                     ? (rc_x.second == rc_y.second ? x.first < y.first
                                                   : rc_x.second < rc_y.second)
                     : rc_x.first < rc_y.first;
        });
        res.emplace_back();
        auto &rv = res.back();
        for (auto x : v) {
          rv.emplace_back(x.first);
        }
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q987, sample_input01) {
  solution = new Solution();
  TreeNode *root =
      TreeNode::generate({3, 9, 20, NULL_TREENODE, NULL_TREENODE, 15, 7});
  vector<vector<int>> exp = {
      { 9},
      { 3,15},
      {20 },
      { 7}
  };
  vector<vector<int>> act = solution->verticalTraversal(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}

TEST_F(q987, sample_input02) {
  solution                 = new Solution();
  TreeNode           *root = TreeNode::generate({1, 2, 3, 4, 5, 6, 7});
  vector<vector<int>> exp  = {
       {4 },
       {2 },
       {1, 5, 6},
       {3},
       {7 }
  };
  vector<vector<int>> act = solution->verticalTraversal(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}

TEST_F(q987, sample_input03) {
  solution                 = new Solution();
  TreeNode           *root = TreeNode::generate({1, 2, 3, 4, 6, 5, 7});
  vector<vector<int>> exp  = {
       {4 },
       {2 },
       {1, 5, 6},
       {3},
       {7 }
  };
  vector<vector<int>> act = solution->verticalTraversal(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}