#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 999.
 *      Available Captures for Rook
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   On an ‘8 x 8’ chessboard, there is “exactly one” white rook ‘'R'’ and
 *   some number of white bishops ‘'B'’ , black pawns ‘'p'’ , and empty
 *   squares ‘'.'’
 *   When the rook moves, it chooses one of four cardinal directions
 *   (north, east, south, or west), then moves in that direction until it
 *   chooses to stop, reaches the edge of the board, captures a black pawn,
 *   or is blocked by a white bishop. A rook is considered “attacking” a
 *   pawn if the rook can capture the pawn on the rook's turn. The “number
 *   of available captures” for the white rook is the number of pawns that
 *   the rook is “attacking”
 *   Return “the “number of available captures” for the white rook” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘board.length = 8’
 *   • ‘board[i].length = 8’
 *   • ‘board[i][j]’ is either ‘'R'’ , ‘'.'’ , ‘'B'’ , or ‘'p'’
 *   • There is exactly one cell with ‘board[i][j] = 'R'’
 *
 */

struct q999 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int numRookCaptures(vector<vector<char>> &board) {
      int res = 0;
      pair<int, int> rock_pos;
      for (int i = 0; i < board.size(); ++i) {
        for (int j = 0; j < board.size(); ++j) {
          if (board[i][j] == 'R') {
            rock_pos = make_pair(i, j);
          }
        }
      }

      auto &[x, y] = rock_pos;
      int i = x + 1;
      while (i < board.size()) {
        if (board[i][y] == '.') {
          ++i;
          continue;
        } else if (board[i][y] == 'p') {
          ++res;
        }
        break;
      }
      i = x - 1;
      while (i >= 0) {
        if (board[i][y] == '.') {
          --i;
          continue;
        } else if (board[i][y] == 'p') {
          ++res;
        }
        break;
      }
      i = y + 1;
      while (i < board.size()) {
        if (board[x][i] == '.') {
          ++i;
          continue;
        } else if (board[x][i] == 'p') {
          ++res;
        }
        break;
      }
      i = y - 1;
      while (i >= 0) {
        if (board[x][i] == '.') {
          --i;
          continue;
        } else if (board[x][i] == 'p') {
          ++res;
        }
        break;
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q999, sample_input01) {
  solution = new Solution();
  vector<vector<char>> board = {{'.', '.', '.', '.', '.', '.', '.', '.'}, {'.', '.', '.', 'p', '.', '.', '.', '.'}, {'.', '.', '.', 'R', '.', '.', '.', 'p'}, {'.', '.', '.', '.', '.', '.', '.', '.'}, {'.', '.', '.', '.', '.', '.', '.', '.'}, {'.', '.', '.', 'p', '.', '.', '.', '.'}, {'.', '.', '.', '.', '.', '.', '.', '.'}, {'.', '.', '.', '.', '.', '.', '.', '.'}};
  int exp = 3;
  int act = solution->numRookCaptures(board);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q999, sample_input02) {
  solution = new Solution();
  vector<vector<char>> board = {{'.', '.', '.', '.', '.', '.', '.', '.'}, {'.', 'p', 'p', 'p', 'p', 'p', '.', '.'}, {'.', 'p', 'p', 'B', 'p', 'p', '.', '.'}, {'.', 'p', 'B', 'R', 'B', 'p', '.', '.'}, {'.', 'p', 'p', 'B', 'p', 'p', '.', '.'}, {'.', 'p', 'p', 'p', 'p', 'p', '.', '.'}, {'.', '.', '.', '.', '.', '.', '.', '.'}, {'.', '.', '.', '.', '.', '.', '.', '.'}};
  int exp = 0;
  int act = solution->numRookCaptures(board);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q999, sample_input03) {
  solution = new Solution();
  vector<vector<char>> board = {{'.', '.', '.', '.', '.', '.', '.', '.'}, {'.', '.', '.', 'p', '.', '.', '.', '.'}, {'.', '.', '.', 'p', '.', '.', '.', '.'}, {'p', 'p', '.', 'R', '.', 'p', 'B', '.'}, {'.', '.', '.', '.', '.', '.', '.', '.'}, {'.', '.', '.', 'B', '.', '.', '.', '.'}, {'.', '.', '.', 'p', '.', '.', '.', '.'}, {'.', '.', '.', '.', '.', '.', '.', '.'}};
  int exp = 3;
  int act = solution->numRookCaptures(board);
  EXPECT_EQ(act, exp);
  delete solution;
}