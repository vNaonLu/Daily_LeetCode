#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 951.
 *      Flip Equivalent Binary Trees
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   For a binary tree “T” , we can define a “flip operation” as follows:
 *   choose any node, and swap the left and right child
 *   A binary tree “X” is “flip equivalent” to a binary tree “Y” if and
 *   only if we can make “X” equal to “Y” after some number of flip
 *   Given the roots of two binary trees ‘root1’ and ‘root2’ , return
 *   ‘true’ if the two trees are flip equivalent or ‘false’ otherwise.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in each tree is in the range ‘[0, 100]’ .
 *   • Each tree will have “unique node values” in the range ‘[0, 99]’ .
 *
 */

struct q951 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    bool flipEquiv(TreeNode* root1, TreeNode* root2) {
      if (root1 == nullptr)
        return root2 == nullptr;
      else if (root2 == nullptr)
        return root1 == nullptr;
      else if (root1->val != root2->val)
        return false;
      return flipEquiv(root1->left, root2->left) && flipEquiv(root1->right, root2->right) ||
             flipEquiv(root1->left, root2->right) && flipEquiv(root1->right, root2->left);
    }
  };

  class Solution *solution;
};

TEST_F(q951, sample_input01) {
  solution = new Solution();
  TreeNode* root1 = TreeNode::generate({1, 2, 3, 4, 5, 6, NULL_TREENODE, NULL_TREENODE, NULL_TREENODE, 7, 8});
  TreeNode* root2 = TreeNode::generate({1, 3, 2, NULL_TREENODE, 6, 4, 5, NULL_TREENODE, NULL_TREENODE, NULL_TREENODE, NULL_TREENODE, 8, 7});
  bool exp = true;
  EXPECT_EQ(solution->flipEquiv(root1, root2), exp);
  delete solution;
}

TEST_F(q951, sample_input02) {
  solution = new Solution();
  TreeNode* root1 = TreeNode::generate({});
  TreeNode* root2 = TreeNode::generate({});
  bool exp = true;
  EXPECT_EQ(solution->flipEquiv(root1, root2), exp);
  delete solution;
}

TEST_F(q951, sample_input03) {
  solution = new Solution();
  TreeNode* root1 = TreeNode::generate({});
  TreeNode* root2 = TreeNode::generate({1});
  bool exp = false;
  EXPECT_EQ(solution->flipEquiv(root1, root2), exp);
  delete solution;
}

TEST_F(q951, sample_input04) {
  solution = new Solution();
  TreeNode* root1 = TreeNode::generate({0, NULL_TREENODE, 1});
  TreeNode* root2 = TreeNode::generate({});
  bool exp = false;
  EXPECT_EQ(solution->flipEquiv(root1, root2), exp);
  delete solution;
}

TEST_F(q951, sample_input05) {
  solution = new Solution();
  TreeNode* root1 = TreeNode::generate({0, NULL_TREENODE, 1});
  TreeNode* root2 = TreeNode::generate({0, 1});
  bool exp = true;
  EXPECT_EQ(solution->flipEquiv(root1, root2), exp);
  delete solution;
}