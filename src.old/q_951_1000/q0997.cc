#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 997.
 *      Find the Town Judge
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   In a town, there are ‘n’ people labeled from ‘1’ to ‘n’ . There is a
 *   rumor that one of these people is secretly the town
 *   If the town judge exists,
 *       1. The town judge trusts
 *       2. Everybody (except for the town judge) trusts the town
 *       3. There is exactly one person that satisfies properties “1” and
 *   “2”
 *   You are given an array ‘trust’ where ‘trust[i] = [aᵢ, bᵢ]’
 *   representing that the person labeled ‘aᵢ’ trusts the person labeled
 *   ‘bᵢ’
 *   Return “the label of the town judge if the town judge exists and can
 *   be identified, or return ” ‘-1’ “ otherwise” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n ≤ 1000’
 *   • ‘0 ≤ trust.length ≤ 10⁴’
 *   • ‘trust[i].length = 2’
 *   • All the pairs of ‘trust’ are “unique” .
 *   • ‘aᵢ ≠ bᵢ’
 *   • ‘1 ≤ aᵢ, bᵢ ≤ n’
 *
 */

struct q997 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int findJudge(int n, vector<vector<int>>& trust) {
      vector<pair<int, int>> trust_map(n, make_pair(0, 0));
      for (const auto& t : trust) {
        ++trust_map[t[0] - 1].first;
        ++trust_map[t[1] - 1].second;
      }
      for (int i = 0; i < trust_map.size(); ++i)
        if (trust_map[i].first == 0 && trust_map[i].second == n - 1)
          return i + 1;
      return -1;
    }
  };

  class Solution *solution;
};

TEST_F(q997, sample_input01) {
  solution = new Solution();
  int n = 2;
  vector<vector<int>> trust = {{1, 2}};
  int exp = 2;
  EXPECT_EQ(solution->findJudge(n, trust), exp);
  delete solution;
}

TEST_F(q997, sample_input02) {
  solution = new Solution();
  int n = 3;
  vector<vector<int>> trust = {{1, 3}, {2, 3}};
  int exp = 3;
  EXPECT_EQ(solution->findJudge(n, trust), exp);
  delete solution;
}

TEST_F(q997, sample_input03) {
  solution = new Solution();
  int n = 3;
  vector<vector<int>> trust = {{1, 3}, {2, 3}, {3, 1}};
  int exp = -1;
  EXPECT_EQ(solution->findJudge(n, trust), exp);
  delete solution;
}

TEST_F(q997, sample_input04) {
  solution = new Solution();
  int n = 3;
  vector<vector<int>> trust = {{1, 2}, {2, 3}};
  int exp = -1;
  EXPECT_EQ(solution->findJudge(n, trust), exp);
  delete solution;
}

TEST_F(q997, sample_input05) {
  solution = new Solution();
  int n = 4;
  vector<vector<int>> trust = {{1, 3}, {1, 4}, {2, 3}, {2, 4}, {4, 3}};
  int exp = 3;
  EXPECT_EQ(solution->findJudge(n, trust), exp);
  delete solution;
}