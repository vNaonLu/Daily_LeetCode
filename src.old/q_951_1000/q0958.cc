#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 958.
 *      Check Completeness of a Binary Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary tree, determine if it is a “complete
 *   binary tree”
 *   In a “<a
 *   href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees"
 *   target="_blank">complete binary tree</a>” , every level, except
 *   possibly the last, is completely filled, and all nodes in the last
 *   level are as far left as possible. It can have between ‘1’ and ‘2ʰ’
 *   nodes inclusive at the last level ‘h’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[1, 100]’ .
 *   • ‘1 ≤ Node.val ≤ 1000’
 *
 */

struct q958 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    int count(TreeNode *p) {
      if (nullptr == p) {
        return 0;
      } else {
        return 1 + count(p->left) + count(p->right);
      }
    }

  public:
    bool isCompleteTree(TreeNode *root) {
      auto total = count(root);
      auto traveled = 0;
      auto q = queue<TreeNode *>();

      q.emplace(root);
      while (!q.empty()) {
        auto curr = q.front();
        q.pop();

        if (curr == nullptr) {
          break;
        }

        ++traveled;
        q.emplace(curr->left);
        q.emplace(curr->right);
      }

      return traveled == total;
    }
  };

  class Solution *solution;
};

TEST_F(q958, sample_input01) {
  solution = new Solution();
  TreeNode *root = TreeNode::generate({1, 2, 3, 4, 5, 6});
  bool exp = true;
  bool act = solution->isCompleteTree(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}

TEST_F(q958, sample_input02) {
  solution = new Solution();
  TreeNode *root = TreeNode::generate({1, 2, 3, 4, 5, NULL_TREENODE, 7});
  bool exp = false;
  bool act = solution->isCompleteTree(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}