#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1379.
 *       Find a Corresponding Node of a Binary Tree in a Clone of That Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given two binary trees ‘original’ and ‘cloned’ and given a reference
 *   to a node ‘target’ in the original
 *   The ‘cloned’ tree is a “copy of” the ‘original’
 *   Return “a reference to the same node” in the ‘cloned’
 *    “Note” that you are “not allowed” to change any of the two trees or
 *   the ‘target’ node and the answer “must be” a reference to a node in
 *   the ‘cloned’ tree.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the ‘tree’ is in the range ‘[1, 10⁴]’ .
 *   • The values of the nodes of the ‘tree’ are unique.
 *   • ‘target’ node is a node from the ‘original’ tree and is not ‘null’ .
 *
 */

struct q1379 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {
      if (original == nullptr) {
        return nullptr;
      }

      if (original == target) {
        return cloned;
      }

      if (auto l = getTargetCopy(original->left, cloned->left, target); nullptr != l) {
        return l;
      } else if (auto r = getTargetCopy(original->right, cloned->right, target); nullptr != r) {
        return r;
      }

      return nullptr;
    }
  };

  class Solution *solution;
};

TEST_F(q1379, sample_input01) {
  solution = new Solution();
  TreeNode* original = TreeNode::generate({7, 4, 3, NULL_TREENODE, NULL_TREENODE, 6, 19});
  TreeNode* cloned = TreeNode::generate({7, 4, 3, NULL_TREENODE, NULL_TREENODE, 6, 19});
  TreeNode* target = original->left;
  TreeNode* exp = cloned->left;
  TreeNode* act = solution->getTargetCopy(original, cloned, target);
  EXPECT_EQ(act, exp);
  TreeNode::release(original, cloned, target, exp, act);
  delete solution;
}

TEST_F(q1379, sample_input02) {
  solution = new Solution();
  TreeNode* original = TreeNode::generate({7});
  TreeNode* cloned = TreeNode::generate({7});
  TreeNode* target = original;
  TreeNode* exp = cloned;
  TreeNode* act = solution->getTargetCopy(original, cloned, target);
  EXPECT_EQ(act, exp);
  TreeNode::release(original, cloned, target, exp, act);
  delete solution;
}

TEST_F(q1379, sample_input03) {
  solution = new Solution();
  TreeNode* original = TreeNode::generate({8, NULL_TREENODE, 6, NULL_TREENODE, 5, NULL_TREENODE, 4, NULL_TREENODE, 3, NULL_TREENODE, 2, NULL_TREENODE, 1});
  TreeNode* cloned = TreeNode::generate({8, NULL_TREENODE, 6, NULL_TREENODE, 5, NULL_TREENODE, 4, NULL_TREENODE, 3, NULL_TREENODE, 2, NULL_TREENODE, 1});
  TreeNode* target = original->right->right->right;
  TreeNode* exp = cloned->right->right->right;
  TreeNode* act = solution->getTargetCopy(original, cloned, target);
  EXPECT_EQ(act, exp);
  TreeNode::release(original, cloned, target, exp, act);
  delete solution;
}