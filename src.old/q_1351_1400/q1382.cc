#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1382.
 *       Balance a Binary Search Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary search tree, return “a “balanced” binary
 *   search tree with the same node values” . If there is more than one
 *   answer, return “any of them”
 *   A binary search tree is “balanced” if the depth of the two subtrees of
 *   every node never differs by more than ‘1’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[1, 10⁴]’ .
 *   • ‘1 ≤ Node.val ≤ 10⁵’
 *
 */

struct q1382 : public ::testing::Test {
  // Leetcode answer here
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
   private:
    void build_inorder(TreeNode* p, vector<TreeNode*>& inorder) {
      if (p == nullptr) {
        return;
      }

      build_inorder(p->left, inorder);
      inorder.emplace_back(p);
      build_inorder(p->right, inorder);
    }

    template <typename iterator>
    TreeNode* build_tree_from_inorder(iterator beg, iterator end) {
      if (beg == end) {
        return nullptr;
      }

      auto mid = beg + (end - beg) / 2;
      (*mid)->left = build_tree_from_inorder(beg, mid);
      (*mid)->right = build_tree_from_inorder(mid + 1, end);

      return *mid;
    }

   public:
    TreeNode* balanceBST(TreeNode* root) {
      vector<TreeNode*> order;
      build_inorder(root, order);

      return build_tree_from_inorder(order.begin(), order.end());
    }
  };

  class Solution *solution;
};

TEST_F(q1382, sample_input01) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1, NULL_TREENODE, 2, NULL_TREENODE, 3, NULL_TREENODE, 4, NULL_TREENODE, NULL_TREENODE});
  TreeNode* exp = TreeNode::generate({3, 2, 4, 1});
  TreeNode* act = solution->balanceBST(root);
  EXPECT_TREENODE_EQ(act, exp);
  TreeNode::release(root, exp, act);
  delete solution;
}

TEST_F(q1382, sample_input02) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({2, 1, 3});
  TreeNode* exp = TreeNode::generate({2, 1, 3});
  TreeNode* act = solution->balanceBST(root);
  EXPECT_TREENODE_EQ(act, exp);
  TreeNode::release(root, exp, act);
  delete solution;
}