#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <unordered_map>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1376.
 *       Time Needed to Inform All Employees
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   A company has ‘n’ employees with a unique ID for each employee from
 *   ‘0’ to ‘n - 1’ . The head of the company is the one with ‘headID’
 *   Each employee has one direct manager given in the ‘manager’ array
 *   where ‘manager[i]’ is the direct manager of the ‘i-th’ employee,
 *   ‘manager[headID] = -1’ . Also, it is guaranteed that the subordination
 *   relationships have a tree
 *   The head of the company wants to inform all the company employees of
 *   an urgent piece of news. He will inform his direct subordinates, and
 *   they will inform their subordinates, and so on until all employees
 *   know about the urgent
 *   The ‘i-th’ employee needs ‘informTime[i]’ minutes to inform all of his
 *   direct subordinates (i.e., After informTime[i] minutes, all his direct
 *   subordinates can start spreading the
 *   Return “the number of minutes” needed to inform all the employees
 *   about the urgent news.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n ≤ 10⁵’
 *   • ‘0 ≤ headID < n’
 *   • ‘manager.length = n’
 *   • ‘0 ≤ manager[i] < n’
 *   • ‘manager[headID] = -1’
 *   • ‘informTime.length = n’
 *   • ‘0 ≤ informTime[i] ≤ 1000’
 *   • ‘informTime[i] = 0’ if employee ‘i’ has no subordinates.
 *   • It is “guaranteed” that all the employees can be informed.
 *
 */

struct q1376 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {
      unordered_map<int, unordered_set<int>> subordination;
      unordered_set<int>                     visited(n);
      for (int i = 0; i < manager.size(); ++i) {
        subordination[manager[i]].insert(i);
      }

      priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
      pq.emplace(informTime[headID], headID);

      while (!pq.empty()) {
        auto [time, who] = pq.top();
        pq.pop();
        if (visited.count(who)) continue;
        visited.insert(who);

        if (visited.size() == n) return time;

        for (const auto& p : subordination[who]) {
          if (!visited.count(p)) {
            pq.emplace(time + informTime[p], p);
          }
        }
      }

      return -1;
    }
  };

  class Solution *solution;
};

TEST_F(q1376, sample_input01) {
  solution = new Solution();
  int n = 1;
  int headID = 0;
  vector<int> manager = {-1};
  vector<int> informTime = {0};
  int exp = 0;
  int act = solution->numOfMinutes(n, headID, manager, informTime);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1376, sample_input02) {
  solution = new Solution();
  int n = 6;
  int headID = 2;
  vector<int> manager = {2, 2, -1, 2, 2, 2};
  vector<int> informTime = {0, 0, 1, 0, 0, 0};
  int exp = 1;
  int act = solution->numOfMinutes(n, headID, manager, informTime);
  EXPECT_EQ(act, exp);
  delete solution;
}