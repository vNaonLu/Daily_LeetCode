#include <gtest/gtest.h>
#include <iostream>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 155.
 *      Min Stack
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Design a stack that supports push, pop, top, and retrieving the
 *   minimum element in constant
 *   Implement the ‘MinStack’
 *       -  ‘MinStack()’ initializes the stack
 *       -  ‘void push(int val)’ pushes the element ‘val’ onto the
 *       -  ‘void pop()’ removes the element on the top of the
 *       -  ‘int top()’ gets the top element of the
 *       -  ‘int getMin()’ retrieves the minimum element in the stack.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘-2³¹ ≤ val ≤ 2³¹ - 1’
 *   • Methods ‘pop’ , ‘top’ and ‘getMin’ operations will always be called on “non-empty” stacks.
 *   • At most ‘3 × 10⁴’ calls will be made to ‘push’ , ‘pop’ , ‘top’ , and ‘getMin’ .
 *
 */

struct q155 : public ::testing::Test {
  // Leetcode answer here
  class MinStack {
   private:
    pair<int, int> data[30001];
    int it;
   public:
    MinStack() {
      it = -1;
    }
    inline void push(int val) {
      int m = numeric_limits<int>::max();
      if (it >= 0) {
        m = min(data[it].first, data[it].second);
      }
      data[++it] = make_pair(val, m);
    }
    inline void pop() {
      --it;
    }
    inline int top() {
      return data[it].first;
    }
    inline int getMin() {
      return min(data[it].first, data[it].second);
    }
  };

  class MinStack *min_stack;
};

TEST_F(q155, sample_input01) {
  min_stack = new MinStack();
  min_stack->push(-2);
  min_stack->push(0);
  min_stack->push(-3);
  EXPECT_EQ(min_stack->getMin(), -3);
  min_stack->pop();
  EXPECT_EQ(min_stack->top(), 0);
  EXPECT_EQ(min_stack->getMin(), -2);
  delete min_stack;
}