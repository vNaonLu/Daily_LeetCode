#include <gtest/gtest.h>
#include <iostream>
#include <string>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 165.
 *      Compare Version Numbers
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given two version numbers, ‘version1’ and ‘version2’ , compare
 *   Version numbers consist of “one or more revisions” joined by a dot
 *   ‘'.'’ . Each revisionconsists of “digits” and may contain leading
 *   “zeros” . Every revision contains “at least one character” . Revisions
 *   are “0-indexed from left to right” , with the leftmost revision being
 *   revision 0, the next revision being revision 1, and so on. For example
 *   ‘2.5.33’ and ‘0.1’ are valid version
 *   To compare version numbers, compare their revisions in “left-to-right
 *   order” . Revisions are compared using their “integer value ignoring
 *   any leading zeros” . This means that revisions ‘1’ and ‘001’ are
 *   considered “equal” . If a version number does not specify a revision
 *   at an index, then “treat the revision as ‘0’ ” . For example, version
 *   ‘1.0’ is less than version ‘1.1’ because their revision 0s are the
 *   same, but their revision 1s are ‘0’ and ‘1’ respectively, and ‘0 < 1’
 *    “Return the following:”
 *       - If ‘version1 < version2’ , return ‘-1’
 *       - If ‘version1 > version2’ , return ‘1’
 *       - Otherwise, return ‘0’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ version1.length, version2.length ≤ 500’
 *   • ‘version1’ and ‘version2’ only contain digits and ‘'.'’ .
 *   • ‘version1’ and ‘version2’  “are valid version numbers” .
 *   • All the given revisions in ‘version1’ and ‘version2’ can be stored ina “32-bit integer” .
 *
 */

struct q165 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int compareVersion(string version1, string version2) {
      int v1 = 0, v2 = 0;
      auto i1 = version1.begin();
      auto i2 = version2.begin();
      while (i1 != version1.end() || i2 != version2.end()) {
        if (i1 != version1.end() && *i1 != '.') {
          v1 = v1 * 10 + (*i1 - '0');
          ++i1;
        }
        if (i2 != version2.end() && *i2 != '.') {
          v2 = v2 * 10 + (*i2 - '0');
          ++i2;
        }

        if ((i1 == version1.end() || *i1 == '.') &&
            (i2 == version2.end() || *i2 == '.')) {
          if (v1 > v2)      return 1;
          else if (v1 < v2) return -1;
          if (i1 != version1.end()) {
            ++i1;
          }
          if (i2 != version2.end()) {
            ++i2;
          }
          v1 = 0;
          v2 = 0;
        }
      }

      return 0;
    }
  };

  class Solution *solution;
};

TEST_F(q165, sample_input01) {
  solution = new Solution();
  string version1 = "1.01";
  string version2 = "1.001";
  int exp = 0;
  int act = solution->compareVersion(version1, version2);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q165, sample_input02) {
  solution = new Solution();
  string version1 = "1.0";
  string version2 = "1.0.0";
  int exp = 0;
  int act = solution->compareVersion(version1, version2);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q165, sample_input03) {
  solution = new Solution();
  string version1 = "0.1";
  string version2 = "1.1";
  int exp = -1;
  int act = solution->compareVersion(version1, version2);
  EXPECT_EQ(act, exp);
  delete solution;
}