#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 318.
 *      Maximum Product of Word Lengths
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a string array ‘words’ , return “the maximum value of”
 *   ‘length(word[i]) × length(word[j])’ “where the two words do not share
 *   common letters” . If no such two words exist, return ‘0’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘2 ≤ words.length ≤ 1000’
 *   • ‘1 ≤ words[i].length ≤ 1000’
 *   • ‘words[i]’ consists only of lowercase English letters.
 *
 */

struct q318 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int maxProduct(vector<string> &words) {
      int res = 0;
      vector<pair<int, unordered_set<int>>> memos;
      for (auto &s : words) {
        pair<int, unordered_set<int>> curr;
        auto &[length, letters] = curr;
        for (auto &c : s) {
          ++length;
          letters.insert(c);
        }

        memos.emplace_back(move(curr));
      }

      for (int i = 0; i < memos.size(); ++i) {
        auto &[lx, lex] = memos[i];
        for (int j = i + 1; j < memos.size(); ++j) {
          auto &[ly, ley] = memos[j];
          bool duplicate = false;
          for (auto &c : lex) {
            if (ley.count(c)) {
              duplicate = true;
              break;
            }
          }

          if (!duplicate) {
            res = max(res, ly * lx);
          }
        }
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q318, sample_input01) {
  solution = new Solution();
  vector<string> words = {"abcw", "baz", "foo", "bar", "xtfn", "abcdef"};
  int exp = 16;
  int act = solution->maxProduct(words);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q318, sample_input02) {
  solution = new Solution();
  vector<string> words = {"a", "ab", "abc", "d", "cd", "bcd", "abcd"};
  int exp = 4;
  int act = solution->maxProduct(words);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q318, sample_input03) {
  solution = new Solution();
  vector<string> words = {"a", "aa", "aaa", "aaaa"};
  int exp = 0;
  int act = solution->maxProduct(words);
  EXPECT_EQ(act, exp);
  delete solution;
}