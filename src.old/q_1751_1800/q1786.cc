#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <unordered_map>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1786.
 *       Number of Restricted Paths From First to Last Node
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   There is an undirected weighted connected graph. You are given a
 *   positive integer ‘n’ which denotes that the graph has ‘n’ nodes
 *   labeled from ‘1’ to ‘n’ , and an array ‘edges’ where each ‘edges[i] =
 *   [uᵢ, vᵢ, weightᵢ]’ denotes that there is an edge between nodes ‘uᵢ’
 *   and ‘vᵢ’ with weight equal to ‘weightᵢ’
 *   A path from node ‘start’ to node ‘end’ is a sequence of nodes ‘[z₀,
 *   z₁,⎽( )z₂, ..., zₖ]’ such that ‘z⎽(0 )= start’ and ‘zₖ = end’ and
 *   there is an edge between ‘zᵢ’ and ‘zᵢ₊₁’ where ‘0 ≤ i ≤ k-1’
 *   The distance of a path is the sum of the weights on the edges of the
 *   path. Let ‘distanceToLastNode(x)’ denote the shortest distance of a
 *   path between node ‘n’ and node ‘x’ . A “restricted path” is a path
 *   that also satisfies that ‘distanceToLastNode(zᵢ) >
 *   distanceToLastNode(zᵢ₊₁)’ where ‘0 ≤ i ≤ k-1’
 *   Return “the number of restricted paths from node” ‘1’ “to node” ‘n’ .
 *   Since that number may be too large, return it “modulo” ‘10⁹ + 7’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n ≤ 2 × 10⁴’
 *   • ‘n - 1 ≤ edges.length ≤ 4 × 10⁴’
 *   • ‘edges[i].length = 3’
 *   • ‘1 ≤ uᵢ, vᵢ ≤ n’
 *   • ‘u⎽(i )≠ vᵢ’
 *   • ‘1 ≤ weightᵢ ≤ 10⁵’
 *   • There is at most one edge between any two nodes.
 *   • There is at least one path between any two nodes.
 *
 */

struct q1786 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    using ull = unsigned long long;
    using pii = pair<int, int>;
    using pui = pair<unsigned long long, int>;
    static constexpr ull kMax = numeric_limits<ull>::max();
    static constexpr int kMod = 1e+9 + 7;
    unordered_map<int, vector<pii>> graph;
    int n;

    int dfs(int from, vector<int> &pathes, const vector<ull> &dist) {
      if (pathes[from] == -1) {
        pathes[from] = 0;
        for (const auto &[u, _] : graph[from]) {
          if (dist[u] < dist[from]) {
            pathes[from] = (pathes[from] + dfs(u, pathes, dist)) % kMod;
          }
        }
      }
      return pathes[from];
    }

    vector<ull> djikstra(int beg) noexcept {
      priority_queue<pui, vector<pui>, greater<pui>> pq;
      vector<ull> res(n + 1, kMax);
      pq.emplace(0, beg);
      res[beg] = 0;
      while (!pq.empty()) {
        auto [du, u] = pq.top(); pq.pop();
        for (auto &[v, dv] : graph[u]) {
          auto dist = dv + res[u];
          if (dist < res[v]) {
            res[v] = dist;
            pq.emplace(dist, v);
          }
        }
      }
      return res;
    }

   public:
    int countRestrictedPaths(int n, vector<vector<int>> &edges) {
      this->n = n;
      for (const auto &vs : edges) {
        graph[vs[0]].emplace_back(vs[1], vs[2]);
        graph[vs[1]].emplace_back(vs[0], vs[2]);
      }
      auto dist = djikstra(n);
      vector<int> pathes(n + 1, -1);
      pathes[n] = 1;
      dfs(1, pathes, dist);
      return pathes[1];
    }
  };

  class Solution *solution;
};

TEST_F(q1786, sample_input01) {
  solution = new Solution();
  int n = 5;
  vector<vector<int>> edges = {{1, 2, 3}, {1, 3, 3}, {2, 3, 1}, {1, 4, 2}, {5, 2, 2}, {3, 5, 1}, {5, 4, 10}};
  int exp = 3;
  int act = solution->countRestrictedPaths(n, edges);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1786, sample_input02) {
  solution = new Solution();
  int n = 7;
  vector<vector<int>> edges = {{1, 3, 1}, {4, 1, 2}, {7, 3, 4}, {2, 5, 3}, {5, 6, 1}, {6, 7, 2}, {7, 5, 3}, {2, 6, 4}};
  int exp = 1;
  int act = solution->countRestrictedPaths(n, edges);
  EXPECT_EQ(act, exp);
  delete solution;
}