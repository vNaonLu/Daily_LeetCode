#include <cmath>
#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/anyorder.hpp>
#include <unordered_set>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 869.
 *      Reordered Power of 2
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given an integer ‘n’ . We reorder the digits in any order
 *   (including the original order) such that the leading digit is not
 *   Return ‘true’ “if and only if we can do this so that the resulting
 *   number is a power of two” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n ≤ 10⁹’
 *
 */

struct q869 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    inline const static unordered_set<int> hashes{
        10,         100,        10000,     100000000,  1000010,    1100,
        1010000,    100000110,  1100100,   100110,     10111,      100010101,
        1001010001, 1100000110, 101011010, 111001100,  2201000,    10001121,
        1020210,    200110200,  111110011, 1010100211, 1000031011, 401001001,
        32000120,   223100,     212010011, 120011220,  102221100,  1111101111};

    int hashNumber(int n) {
      auto res = int(0);
      while (n != 0) {
        res += int(pow(10, n % 10));
        n /= 10;
      }
      return res;
    }

  public:
    bool reorderedPowerOf2(int n) {
      return hashes.find(hashNumber(n)) != hashes.end();
    }
  };

  class Solution *solution;
};

TEST_F(q869, sample_input01) {
  solution = new Solution();
  int  n   = 1;
  bool exp = true;
  bool act = solution->reorderedPowerOf2(n);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q869, sample_input02) {
  solution = new Solution();
  int  n   = 10;
  bool exp = false;
  bool act = solution->reorderedPowerOf2(n);
  EXPECT_EQ(act, exp);
  delete solution;
}