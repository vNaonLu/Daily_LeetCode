#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <unordered_map>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 882.
 *      Reachable Nodes In Subdivided Graph
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given an undirected graph (the “'original graph'” ) with ‘n’
 *   nodes labeled from ‘0’ to ‘n - 1’ . You decide to “subdivide” each
 *   edge in the graph into a chain of nodes, with the number of new nodes
 *   varying between each
 *   The graph is given as a 2D array of ‘edges’ where ‘edges[i] = [uᵢ, vᵢ,
 *   cntᵢ]’ indicates that there is an edge between nodes ‘uᵢ’ and ‘vᵢ’ in
 *   the original graph, and ‘cntᵢ’ is the total number of new nodes that
 *   you will “subdivide” the edge into. Note that ‘cntᵢ = 0’ means you
 *   will not subdivide the
 *   To “subdivide” the edge ‘[uᵢ, vᵢ]’ , replace it with ‘(cntᵢ + 1)’ new
 *   edges and ‘cntᵢ’ new nodes. The new nodes are ‘x₁’ , ‘x₂’ , ...,
 *   ‘x⎽(cnt<sub>i)</sub>’ , and the new edges are ‘[uᵢ, x₁]’ , ‘[x₁, x₂]’
 *   , ‘[x₂, x₃]’ , ..., ‘[x⎽(cnt<sub>i)-1</sub>, x⎽(cnt<sub>i)</sub>]’ ,
 *   ‘[x⎽(cnt<sub>i)</sub>, vᵢ]’
 *   In this “new graph” , you want to know how many nodes are “reachable”
 *   from the node ‘0’ , where a node is “reachable” if the distance is
 *   ‘maxMoves’ or
 *   Given the original graph and ‘maxMoves’ , return “the number of nodes
 *   that are “reachable” from node ” ‘0’ “ in the new graph” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘0 ≤ edges.length ≤ min(n × (n - 1) / 2, 10⁴)’
 *   • ‘edges[i].length = 3’
 *   • ‘0 ≤ uᵢ < vᵢ < n’
 *   • There are “no multiple edges” in the graph.
 *   • ‘0 ≤ cntᵢ ≤ 10⁴’
 *   • ‘0 ≤ maxMoves ≤ 10⁹’
 *   • ‘1 ≤ n ≤ 3000’
 *
 */

struct q882 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {
      vector<int> dist(n, numeric_limits<int>::max());
      unordered_map<int, unordered_map<int, int>> g;
      for (auto& e : edges) g[e[0]][e[1]] = g[e[1]][e[0]] = e[2] + 1;
      auto cmp = [](const pair<int, int>& a, const pair<int, int>& b) { return a.second > b.second; };
      priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);
      pq.push({0, 0});
      dist[0] = 0;
      while (!pq.empty()) {
        auto u = pq.top().first;
        pq.pop();
        if (dist[u] >= maxMoves) break;
        for (auto n_w : g[u]) {
          int v = n_w.first, w = n_w.second;
          if (dist[u] + w < dist[v]) {
            dist[v] = w + dist[u];
            pq.push({v, dist[v]});
          }
        }
      }
      int res = 0;
      for (int i = 0; i < n; i++)
        if (dist[i] <= maxMoves) res++;
      for (auto& e : edges) {
        int a = dist[e[0]] >= maxMoves ? 0 : min(maxMoves - dist[e[0]], e[2]);
        int b = dist[e[1]] >= maxMoves ? 0 : min(maxMoves - dist[e[1]], e[2]);
        res += min(a + b, e[2]);
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q882, sample_input01) {
  solution = new Solution();
  vector<vector<int>> edges = {{0, 1, 10}, {0, 2, 1}, {1, 2, 2}};
  int maxMoves = 6;
  int n = 3;
  int exp = 13;
  EXPECT_EQ(solution->reachableNodes(edges, maxMoves, n), exp);
  delete solution;
}

TEST_F(q882, sample_input02) {
  solution = new Solution();
  vector<vector<int>> edges = {{0, 1, 4}, {1, 2, 6}, {0, 2, 8}, {1, 3, 1}};
  int maxMoves = 10;
  int n = 4;
  int exp = 23;
  EXPECT_EQ(solution->reachableNodes(edges, maxMoves, n), exp);
  delete solution;
}

TEST_F(q882, sample_input03) {
  solution = new Solution();
  vector<vector<int>> edges = {{1, 2, 4}, {1, 4, 5}, {1, 3, 1}, {2, 3, 4}, {3, 4, 5}};
  int maxMoves = 17;
  int n = 5;
  int exp = 1;
  EXPECT_EQ(solution->reachableNodes(edges, maxMoves, n), exp);
  delete solution;
}