#include <gtest/gtest.h>
#include <iostream>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 858.
 *      Mirror Reflection
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   There is a special square room with mirrors on each of the four walls.
 *   Except for the southwest corner, there are receptors on each of the
 *   remaining corners, numbered ‘0’ , ‘1’ , and ‘2’
 *   The square room has walls of length ‘p’ and a laser ray from the
 *   southwest corner first meets the east wall at a distance ‘q’ from the
 *   ‘0ᵗʰ’
 *   Given the two integers ‘p’ and ‘q’ , return “the number of the
 *   receptor that the ray meets first”
 *   The test cases are guaranteed so that the ray will meet a receptor
 *   eventually.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ q ≤ p ≤ 1000’
 *
 */

struct q858 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    template <typename type>
    type gcd(type x, type y) {
      return y == 0 ? x : gcd(y, x % y);
    }
    template <typename type>
    type lcm(type x, type y) {
      return x * y / gcd(x, y);
    }

  public:
    int mirrorReflection(int p, int q) {
      auto lcm_pq = lcm(p, q);
      auto fac_p = lcm_pq / p;
      auto fac_q = lcm_pq / q;

      return fac_p & 1 ? (fac_q & 1 ? 1 : 2) : (fac_q & 1 ? 0 : -1);
    }
  };

  class Solution *solution;
};

TEST_F(q858, sample_input01) {
  solution = new Solution();
  int p = 2;
  int q = 1;
  int exp = 2;
  int act = solution->mirrorReflection(p, q);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q858, sample_input02) {
  solution = new Solution();
  int p = 3;
  int q = 1;
  int exp = 1;
  int act = solution->mirrorReflection(p, q);
  EXPECT_EQ(act, exp);
  delete solution;
}