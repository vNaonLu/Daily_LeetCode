#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>
#include <queue>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 897.
 *      Increasing Order Search Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary search tree, rearrange the tree in
 *   “in-order” so that the leftmost node in the tree is now the root of
 *   the tree, and every node has no left child and only one right
 *   
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the given tree will be in the range ‘[1, 100]’ .
 *   • ‘0 ≤ Node.val ≤ 1000’
 *
 */

struct q897 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    void fill_queue(queue<TreeNode*>& q, TreeNode* p) {
      if (nullptr == p) {
        return;
      }
      fill_queue(q, p->left);
      q.emplace(p);
      fill_queue(q, p->right);
    }

   public:
    TreeNode* increasingBST(TreeNode* root) {
      queue<TreeNode*> q;
      fill_queue(q, root);
      TreeNode* res = q.front(); q.pop();
      TreeNode* p = res;
      while (!q.empty()) {
        p->left = nullptr;
        p->right = q.front(); q.pop();
        p = p->right;
      }
      p->left = nullptr;
      p->right = nullptr;

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q897, sample_input01) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({5, 3, 6, 2, 4, NULL_TREENODE, 8, 1, NULL_TREENODE, NULL_TREENODE, NULL_TREENODE, 7, 9});
  TreeNode* exp = TreeNode::generate({1, NULL_TREENODE, 2, NULL_TREENODE, 3, NULL_TREENODE, 4, NULL_TREENODE, 5, NULL_TREENODE, 6, NULL_TREENODE, 7, NULL_TREENODE, 8, NULL_TREENODE, 9});
  TreeNode* act = solution->increasingBST(root);
  EXPECT_TREENODE_EQ(act, exp);
  TreeNode::release(root, exp, act);
  delete solution;
}

TEST_F(q897, sample_input02) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({5, 1, 7});
  TreeNode* exp = TreeNode::generate({1, NULL_TREENODE, 5, NULL_TREENODE, 7});
  TreeNode* act = solution->increasingBST(root);
  EXPECT_TREENODE_EQ(act, exp);
  TreeNode::release(root, exp, act);
  delete solution;
}