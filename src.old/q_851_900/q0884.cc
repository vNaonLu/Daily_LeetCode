#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/anyorder.hpp>
#include <string>
#include <unordered_map>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 884.
 *      Uncommon Words from Two Sentences
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   A “sentence” is a string of single-space separated words where each
 *   word consists only of lowercase
 *   A word is “uncommon” if it appears exactly once in one of the
 *   sentences, and “does not appear” in the other
 *   Given two “sentences” ‘s1’ and ‘s2’ , return “a list of all the
 *   “uncommon words” ” . You may return the answer in “any order” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ s1.length, s2.length ≤ 200’
 *   • ‘s1’ and ‘s2’ consist of lowercase English letters and spaces.
 *   • ‘s1’ and ‘s2’ do not have leading or trailing spaces.
 *   • All the words in ‘s1’ and ‘s2’ are separated by a single space.
 *
 */

struct q884 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    void get_word(unordered_map<string, int> &cnt, const string &s) {
      string word = "";
      for (int i = 0; i < s.size(); ++i) {
        if (s[i] == ' ') {
          ++cnt[word];
          word = "";
        } else {
          word += s[i];
        }
      }
      ++cnt[word];
    }
   public:
    vector<string> uncommonFromSentences(string s1, string s2) {
      vector<string> res;
      unordered_map<string, int> cnt;
      get_word(cnt, s1);
      get_word(cnt, s2);
      res.reserve(cnt.size());
      for (auto it = cnt.begin(); it != cnt.end(); ++it) {
        if (it->second == 1)
          res.emplace_back(it->first);
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q884, sample_input01) {
  solution = new Solution();
  string s1 = "this apple is sweet";
  string s2 = "this apple is sour";
  vector<string> exp = {"sweet", "sour"};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->uncommonFromSentences(s1, s2), exp);
  delete solution;
}

TEST_F(q884, sample_input02) {
  solution = new Solution();
  string s1 = "apple apple";
  string s2 = "banana";
  vector<string> exp = {"banana"};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->uncommonFromSentences(s1, s2), exp);
  delete solution;
}