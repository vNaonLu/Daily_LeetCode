#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 872.
 *      Leaf-Similar Trees
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Consider all the leaves of a binary tree, fromleft to right order, the
 *   values of thoseleaves form a “leaf value sequence” “.”
 *   For example, in the given tree above, the leaf value sequence is ‘(6,
 *   7, 4, 9, 8)’
 *   Two binary trees are considered “leaf-similar” if their leaf value
 *   sequence is the
 *   Return ‘true’ if and only if the two given trees with head nodes
 *   ‘root1’ and ‘root2’ are leaf-similar.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in each tree will be in the range ‘[1, 200]’ .
 *   • Both of the given trees will have values in the range ‘[0, 200]’ .
 *
 */

struct q872 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    void helper(TreeNode *p, vector<int> &res) {
      if (nullptr != p) {
        if (nullptr == p->left && nullptr == p->right) {
          res.emplace_back(p->val);
        } else {
          helper(p->left, res);
          helper(p->right, res);
        }
      }
    }

    vector<int> extractLeaf(TreeNode *p) {
      auto res = vector<int>();
      helper(p, res);
      return res;
    }

  public:
    bool leafSimilar(TreeNode *root1, TreeNode *root2) {
      auto leaf1 = extractLeaf(root1);
      auto leaf2 = extractLeaf(root2);
      return leaf1 == leaf2;
    }
  };

  class Solution *solution;
};

TEST_F(q872, sample_input01) {
  solution        = new Solution();
  TreeNode *root1 = TreeNode::generate(
      {3, 5, 1, 6, 2, 9, 8, NULL_TREENODE, NULL_TREENODE, 7, 4});
  TreeNode *root2 = TreeNode::generate(
      {3, 5, 1, 6, 7, 4, 2, NULL_TREENODE, NULL_TREENODE, NULL_TREENODE,
       NULL_TREENODE, NULL_TREENODE, NULL_TREENODE, 9, 8});
  bool exp = true;
  bool act = solution->leafSimilar(root1, root2);
  EXPECT_EQ(act, exp);
  TreeNode::release(root1, root2);
  delete solution;
}

TEST_F(q872, sample_input02) {
  solution        = new Solution();
  TreeNode *root1 = TreeNode::generate({1, 2, 3});
  TreeNode *root2 = TreeNode::generate({1, 3, 2});
  bool      exp   = false;
  bool      act   = solution->leafSimilar(root1, root2);
  EXPECT_EQ(act, exp);
  TreeNode::release(root1, root2);
  delete solution;
}