#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 871.
 *      Minimum Number of Refueling Stops
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   A car travels from a starting position to a destination which is
 *   ‘target’ miles east of the starting
 *   There are gas stations along the way. The gas stations are represented
 *   as an array ‘stations’ where ‘stations[i] = [positionᵢ, fuelᵢ]’
 *   indicates that the ‘iᵗʰ’ gas station is ‘positionᵢ’ miles east of the
 *   starting position and has ‘fuelᵢ’ liters of
 *   The car starts with an infinite tank of gas, which initially has
 *   ‘startFuel’ liters of fuel in it. It uses one liter of gas per one
 *   mile that it drives. When the car reaches a gas station, it may stop
 *   and refuel, transferring all the gas from the station into the
 *   Return “the minimum number of refueling stops the car must make in
 *   order to reach its destination” . If it cannot reach the destination,
 *   return ‘-1’
 *   Note that if the car reaches a gas station with ‘0’ fuel left, the car
 *   can still refuel there. If the car reaches the destination with ‘0’
 *   fuel left, it is still considered to have arrived.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ target, startFuel ≤ 10⁹’
 *   • ‘0 ≤ stations.length ≤ 500’
 *   • ‘0 ≤ positionᵢ ≤ positionᵢ₊₁ < target’
 *   • ‘1 ≤ fuelᵢ < 10⁹’
 *
 */

struct q871 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    int minRefuelStops(int target, int startFuel,
                       vector<vector<int>> &stations) {
      auto pq = priority_queue<int>();
      auto res = 0;
      auto prev = 0;
      auto tank = startFuel;

      for (auto &v : stations) {
        auto loc = v[0];
        auto cap = v[1];

        tank -= loc - prev;
        while (!pq.empty() && tank < 0) {
          tank += pq.top();
          pq.pop();
          ++res;
        }

        if (tank < 0) {
          return -1;
        }

        pq.emplace(cap);
        prev = loc;
      }

      tank -= target - prev;
      while (!pq.empty() && tank < 0) {
        tank += pq.top();
        pq.pop();
        ++res;
      }

      if (tank < 0) {
        return -1;
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q871, sample_input01) {
  solution = new Solution();
  int target = 1;
  int startFuel = 1;
  vector<vector<int>> stations = {};
  int exp = 0;
  int act = solution->minRefuelStops(target, startFuel, stations);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q871, sample_input02) {
  solution = new Solution();
  int target = 100;
  int startFuel = 1;
  vector<vector<int>> stations = {{10, 100}};
  int exp = -1;
  int act = solution->minRefuelStops(target, startFuel, stations);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q871, sample_input03) {
  solution = new Solution();
  int target = 100;
  int startFuel = 10;
  vector<vector<int>> stations = {{10, 60}, {20, 30}, {30, 30}, {60, 40}};
  int exp = 2;
  int act = solution->minRefuelStops(target, startFuel, stations);
  EXPECT_EQ(act, exp);
  delete solution;
}