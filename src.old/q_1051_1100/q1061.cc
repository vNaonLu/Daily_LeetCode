#include <gtest/gtest.h>
#include <iostream>
#include <list>
#include <set>
#include <string>
#include <unordered_map>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1061.
 *       Lexicographically Smallest Equivalent String
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given two strings of the same length ‘s1’ and ‘s2’ and a
 *   string ‘baseStr’
 *   We say ‘s1[i]’ and ‘s2[i]’ are equivalent
 *       - For example, if ‘s1 = 'abc'’ and ‘s2 = 'cde'’ , then we have
 *   ‘'a' = 'c'’ , ‘'b' = 'd'’ , and ‘'c' = 'e'’
 *   Equivalent characters follow the usual rules of any equivalence
 *       -  “Reflexivity:” ‘'a' = 'a'’
 *       -  “Symmetry:” ‘'a' = 'b'’ implies ‘'b' = 'a'’
 *       -  “Transitivity:” ‘'a' = 'b'’ and ‘'b' = 'c'’ implies ‘'a' = 'c'’
 *   For example, given the equivalency information from ‘s1 = 'abc'’ and
 *   ‘s2 = 'cde'’ , ‘'acd'’ and ‘'aab'’ are equivalent strings of ‘baseStr
 *   = 'eed'’ , and ‘'aab'’ is the lexicographically smallest equivalent
 *   string of ‘baseStr’
 *   Return “the lexicographically smallest equivalent string of ”
 *   ‘baseStr’ “ by using the equivalency information from ” ‘s1’ “ and ”
 *   ‘s2’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ s1.length, s2.length, baseStr ≤ 1000’
 *   • ‘s1.length = s2.length’
 *   • ‘s1’ , ‘s2’ , and ‘baseStr’ consist of lowercase English letters.
 *
 */

struct q1061 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    string smallestEquivalentString(string s1, string s2, string baseStr) {
      list<set<char>>                                group;
      unordered_map<char, list<set<char>>::iterator> memo;
      for (int i = 0; i < s1.size(); ++i) {
        auto g1 = memo.find(s1[i]);
        auto g2 = memo.find(s2[i]);

        if (g1 == memo.end() && g2 == memo.end()) {
          auto iter   = group.insert(group.end(), set<char>{s1[i], s2[i]});
          memo[s1[i]] = iter;
          memo[s2[i]] = iter;
        } else if (g1 != memo.end() && g2 == memo.end()) {
          (*g1->second).emplace(s2[i]);
          memo[s2[i]] = g1->second;
        } else if (g1 == memo.end() && g2 != memo.end()) {
          (*g2->second).emplace(s1[i]);
          memo[s1[i]] = g2->second;
        } else {
          if (g1->second != g2->second) {
            auto s = std::move(*g2->second);
            group.erase(g2->second);
            (*g1->second).insert(s.begin(), s.end());
            for (auto x : s) {
              memo[x] = g1->second;
            }
          }
        }
      }
      for (auto &c : baseStr) {
        auto gp = memo.find(c);
        if (gp != memo.end()) {
          c = *(*gp->second).begin();
        }
      }
      return baseStr;
    }
  };

  class Solution *solution;
};

TEST_F(q1061, sample_input01) {
  solution       = new Solution();
  string s1      = "parker";
  string s2      = "morris";
  string baseStr = "parser";
  string exp     = "makkek";
  string act     = solution->smallestEquivalentString(s1, s2, baseStr);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1061, sample_input02) {
  solution       = new Solution();
  string s1      = "hello";
  string s2      = "world";
  string baseStr = "hold";
  string exp     = "hdld";
  string act     = solution->smallestEquivalentString(s1, s2, baseStr);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1061, sample_input03) {
  solution       = new Solution();
  string s1      = "leetcode";
  string s2      = "programs";
  string baseStr = "sourcecode";
  string exp     = "aauaaaaada";
  string act     = solution->smallestEquivalentString(s1, s2, baseStr);
  EXPECT_EQ(act, exp);
  delete solution;
}
