#include <gtest/gtest.h>
#include <iostream>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 2154.
 *       Keep Multiplying Found Values by Two
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given an array of integers ‘nums’ . You are also given an
 *   integer ‘original’ which is the first number that needs to be searched
 *   for in ‘nums’
 *   You then do the following
 *       1. If ‘original’ is found in ‘nums’ , “multiply” it by two (i.e.,
 *   set ‘original = 2 × original’
 *       2. Otherwise, “stop” the
 *       3.  “Repeat” this process with the new number as long as you keep
 *   finding the
 *   Return “the “final” value of ” ‘original’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ nums.length ≤ 1000’
 *   • ‘1 ≤ nums[i], original ≤ 1000’
 *
 */

struct q2154 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    int findFinalValue(vector<int> &nums, int original) {
      unordered_set<int> memo(nums.begin(), nums.end());
      while (true) {
        if (!memo.count(original)) {
          break;
        }
        original *= 2;
      }
      return original;
    }
  };

  class Solution *solution;
};

TEST_F(q2154, sample_input01) {
  solution             = new Solution();
  vector<int> nums     = {5, 3, 6, 1, 12};
  int         original = 3;
  int         exp      = 24;
  int         act      = solution->findFinalValue(nums, original);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q2154, sample_input02) {
  solution             = new Solution();
  vector<int> nums     = {2, 7, 9};
  int         original = 4;
  int         exp      = 4;
  int         act      = solution->findFinalValue(nums, original);
  EXPECT_EQ(act, exp);
  delete solution;
}
