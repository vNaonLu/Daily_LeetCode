#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1465.
 *       Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given a rectangular cake of size ‘h x w’ and two arrays of
 *   integers ‘horizontalCuts’ and ‘verticalCuts’
 *       -  ‘horizontalCuts[i]’ is the distance from the top of the
 *   rectangular cake to the ‘iᵗʰ’ horizontal cut and similarly,
 *       -  ‘verticalCuts[j]’ is the distance from the left of the
 *   rectangular cake to the ‘jᵗʰ’ vertical
 *   Return “the maximum area of a piece of cake after you cut at each
 *   horizontal and vertical position provided in the arrays”
 *   ‘horizontalCuts’ “and” ‘verticalCuts’ . Since the answer can be a
 *   large number, return this “modulo” ‘10⁹ + 7’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘2 ≤ h, w ≤ 10⁹’
 *   • ‘1 ≤ horizontalCuts.length ≤ min(h - 1, 10⁵)’
 *   • ‘1 ≤ verticalCuts.length ≤ min(w - 1, 10⁵)’
 *   • ‘1 ≤ horizontalCuts[i] < h’
 *   • ‘1 ≤ verticalCuts[i] < w’
 *   • All the elements in ‘horizontalCuts’ are distinct.
 *   • All the elements in ‘verticalCuts’ are distinct.
 *
 */

struct q1465 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    int maxArea(int h, int w, vector<int> &horizontalCuts, vector<int> &verticalCuts) {
      constexpr static int kMod = 1e9 + 7;
      sort(horizontalCuts.begin(), horizontalCuts.end());
      sort(verticalCuts.begin(), verticalCuts.end());
      int64_t max_hori = horizontalCuts.front(),
              max_vert = verticalCuts.front();
      for (int i = 1; i < horizontalCuts.size(); ++i) {
        max_hori = max<int64_t>(max_hori, horizontalCuts[i] - horizontalCuts[i - 1]);
      }
      for (int i = 1; i < verticalCuts.size(); ++i) {
        max_vert = max<int64_t>(max_vert, verticalCuts[i] - verticalCuts[i - 1]);
      }
      max_hori = max<int64_t>(max_hori, h - horizontalCuts.back());
      max_vert = max<int64_t>(max_vert, w - verticalCuts.back());

      return (max_hori * max_vert) % kMod;
    }
  };

  class Solution *solution;
};

TEST_F(q1465, sample_input01) {
  solution = new Solution();
  int h = 5;
  int w = 4;
  vector<int> horizontalCuts = {1, 2, 4};
  vector<int> verticalCuts = {1, 3};
  int exp = 4;
  int act = solution->maxArea(h, w, horizontalCuts, verticalCuts);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1465, sample_input02) {
  solution = new Solution();
  int h = 5;
  int w = 4;
  vector<int> horizontalCuts = {3, 1};
  vector<int> verticalCuts = {1};
  int exp = 6;
  int act = solution->maxArea(h, w, horizontalCuts, verticalCuts);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1465, sample_input03) {
  solution = new Solution();
  int h = 5;
  int w = 4;
  vector<int> horizontalCuts = {3};
  vector<int> verticalCuts = {3};
  int exp = 9;
  int act = solution->maxArea(h, w, horizontalCuts, verticalCuts);
  EXPECT_EQ(act, exp);
  delete solution;
}