#include <gtest/gtest.h>
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1462.
 *       Course Schedule IV
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   There are a total of ‘numCourses’ courses you have to take, labeled
 *   from ‘0’ to ‘numCourses - 1’ . You are given an array ‘prerequisites’
 *   where ‘prerequisites[i] = [aᵢ, bᵢ]’ indicates that you “must” take
 *   course ‘aᵢ’ first if you want to take course ‘bᵢ’
 *       - For example, the pair ‘[0, 1]’ indicates that you have to take
 *   course ‘0’ before you can take course ‘1’
 *   Prerequisites can also be “indirect” . If course ‘a’ is a prerequisite
 *   of course ‘b’ , and course ‘b’ is a prerequisite of course ‘c’ , then
 *   course ‘a’ is a prerequisite of course ‘c’
 *   You are also given an array ‘queries’ where ‘queries[j] = [uⱼ, vⱼ]’ .
 *   For the ‘jᵗʰ’ query, you should answer whether course ‘uⱼ’ is a
 *   prerequisite of course ‘vⱼ’ or
 *   Return <i>a boolean array </i> ‘answer’ <i>, where </i> ‘answer[j]’
 *   <i> is the answer to the </i> ‘jᵗʰ’ <i> query.</i>
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘2 ≤ numCourses ≤ 100’
 *   • ‘0 ≤ prerequisites.length ≤ (numCourses × (numCourses - 1) / 2)’
 *   • ‘prerequisites[i].length = 2’
 *   • ‘0 ≤ aᵢ, bᵢ ≤ n - 1’
 *   • ‘aᵢ ≠ bᵢ’
 *   • All the pairs ‘[aᵢ, bᵢ]’ are “unique” .
 *   • The prerequisites graph has no cycles.
 *   • ‘1 ≤ queries.length ≤ 10⁴’
 *   • ‘0 ≤ uᵢ, vᵢ ≤ n - 1’
 *   • ‘uᵢ ≠ vᵢ’
 *
 */

struct q1462 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    unordered_map<int, unordered_set<int>> requisites;
    bool dfs(int src, int dst, vector<bool> &visit) {
      if (src == dst) return true;
      visit[src] = true;
      for (const auto &next : requisites[src]) {
        if (!visit[next] && dfs(next, dst, visit)) return true;
      }
      return false;
    }

   public:
    vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>> &prerequisites, vector<vector<int>> &queries) {
      vector<bool> res;
      res.reserve(queries.size());
      for (const auto &v : prerequisites) {
        requisites[v[1]].insert(v[0]);
      }
      for (const auto &v : queries) {
        vector<bool> visited(numCourses, false);
        res.emplace_back(dfs(v[1], v[0], visited));
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1462, sample_input01) {
  solution = new Solution();
  int numCourses = 2;
  vector<vector<int>> prerequisites = {{1, 0}};
  vector<vector<int>> queries = {{0, 1}, {1, 0}};
  vector<bool> exp = {false, true};
  vector<bool> act = solution->checkIfPrerequisite(numCourses, prerequisites, queries);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1462, sample_input02) {
  solution = new Solution();
  int numCourses = 2;
  vector<vector<int>> prerequisites = {};
  vector<vector<int>> queries = {{1, 0}, {0, 1}};
  vector<bool> exp = {false, false};
  vector<bool> act = solution->checkIfPrerequisite(numCourses, prerequisites, queries);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1462, sample_input03) {
  solution = new Solution();
  int numCourses = 3;
  vector<vector<int>> prerequisites = {{1, 2}, {1, 0}, {2, 0}};
  vector<vector<int>> queries = {{1, 0}, {1, 2}};
  vector<bool> exp = {true, true};
  vector<bool> act = solution->checkIfPrerequisite(numCourses, prerequisites, queries);
  EXPECT_EQ(act, exp);
  delete solution;
}