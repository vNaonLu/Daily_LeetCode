#include <gtest/gtest.h>
#include <iostream>
#include <set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1466.
 *       Reorder Routes to Make All Paths Lead to the City Zero
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   There are ‘n’ cities numbered from ‘0’ to ‘n - 1’ and ‘n - 1’ roads
 *   such that there is only one way to travel between two different cities
 *   (this network form a tree). Last year, The ministry of transport
 *   decided to orient the roads in one direction because they are too
 *   Roads are represented by ‘connections’ where ‘connections[i] = [aᵢ,
 *   bᵢ]’ represents a road from city ‘aᵢ’ to city ‘bᵢ’
 *   This year, there will be a big event in the capital (city ‘0’ ), and
 *   many people want to travel to this
 *   Your task consists of reorienting some roads such that each city can
 *   visit the city ‘0’ . Return the “minimum” number of edges
 *   It's “guaranteed” that each city can reach city ‘0’ after reorder.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘2 ≤ n ≤ 5 × 10⁴’
 *   • ‘connections.length = n - 1’
 *   • ‘connections[i].length = 2’
 *   • ‘0 ≤ aᵢ, bᵢ ≤ n - 1’
 *   • ‘aᵢ ≠ bᵢ’
 *
 */

struct q1466 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    set<pair<int, int>> path;
    vector<vector<int>> adj;
    int res;

    inline void dfs(vector<int> &visited, int curr) {
      visited[curr] = 1;

      for (auto &x : adj[curr]) {
        if (!visited[x]) {
          dfs(visited, x);
          if (path.count(make_pair(curr, x))) {
            ++res;
          }
        }
      }
    }

   public:
    int minReorder(int n, vector<vector<int>> &connections) {
      adj.resize(n);
      res = 0;

      for (auto &v : connections) {
        adj[v[0]].emplace_back(v[1]);
        adj[v[1]].emplace_back(v[0]);
        path.emplace(v[0], v[1]);
      }

      vector<int> visited(n, 0);
      dfs(visited, 0);

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1466, sample_input01) {
  solution = new Solution();
  int n = 6;
  vector<vector<int>> connections = {{0, 1}, {1, 3}, {2, 3}, {4, 0}, {4, 5}};
  int exp = 3;
  int act = solution->minReorder(n, connections);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1466, sample_input02) {
  solution = new Solution();
  int n = 5;
  vector<vector<int>> connections = {{1, 0}, {1, 2}, {3, 2}, {3, 4}};
  int exp = 2;
  int act = solution->minReorder(n, connections);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1466, sample_input03) {
  solution = new Solution();
  int n = 3;
  vector<vector<int>> connections = {{1, 0}, {2, 0}};
  int exp = 0;
  int act = solution->minReorder(n, connections);
  EXPECT_EQ(act, exp);
  delete solution;
}