#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1473.
 *       Paint House III
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   There is a row of ‘m’ houses in a small city, each house must be
 *   painted with one of the ‘n’ colors (labeled from ‘1’ to ‘n’ ), some
 *   houses that have been painted last summer should not be painted
 *   A neighborhood is a maximal group of continuous houses that are
 *   painted with the same
 *       - For example: ‘houses = [1,2,2,3,3,2,1,1]’ contains ‘5’
 *   neighborhoods ‘[{1}, {2,2}, {3,3}, {2}, {1,1}]’
 *   Given an array ‘houses’ , an ‘m x n’ matrix ‘cost’ and an integer
 *   ‘target’
 *       -  ‘houses[i]’ : is the color of the house ‘i’ , and ‘0’ if the
 *   house is not painted
 *       -  ‘cost[i][j]’ : is the cost of paint the house ‘i’ with the
 *   color ‘j + 1’
 *   Return “the minimum cost of painting all the remaining houses in such
 *   a way that there are exactly” ‘target’ “neighborhoods” . If it is not
 *   possible, return ‘-1’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘m = houses.length = cost.length’
 *   • ‘n = cost[i].length’
 *   • ‘1 ≤ m ≤ 100’
 *   • ‘1 ≤ n ≤ 20’
 *   • ‘1 ≤ target ≤ m’
 *   • ‘0 ≤ houses[i] ≤ n’
 *   • ‘1 ≤ cost[i][j] ≤ 10⁴’
 *
 */

struct q1473 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    inline static constexpr int kMaxCost = 1e6 + 1;

  public:
    int minCost(vector<int> &houses, vector<vector<int>> &cost, int m, int n, int target) {
      vector<vector<vector<int>>> dp(m, vector<vector<int>>(target + 1, vector<int>(n, kMaxCost)));

      for (int color = 1; color <= n; ++color) {
        if (houses[0] == color) {
          dp[0][1][color - 1] = 0;
        } else if (!houses[0]) {
          dp[0][1][color - 1] = cost[0][color - 1];
        }
      }

      for (int house = 1; house < m; ++house) {
        for (int neigh = 1; neigh <= min(target, house + 1); ++neigh) {
          for (int color = 1; color <= n; ++color) {
            if (houses[house] && color != houses[house]) {
              continue;
            }

            int local = kMaxCost;
            for (int prevColor = 1; prevColor <= n; prevColor++) {
              if (prevColor != color) {
                local = min(local, dp[house - 1][neigh - 1][prevColor - 1]);
              } else {
                local = min(local, dp[house - 1][neigh][color - 1]);
              }
            }
            int curr_cost = houses[house] ? 0 : cost[house][color - 1];
            dp[house][neigh][color - 1] = local + curr_cost;
          }
        }
      }

      int res = kMaxCost;
      for (int color = 1; color <= n; color++) {
        res = min(res, dp[m - 1][target][color - 1]);
      }

      return res == kMaxCost ? -1 : res;
    }
  };

  class Solution *solution;
};

TEST_F(q1473, sample_input01) {
  solution = new Solution();
  vector<int> houses = {0, 0, 0, 0, 0};
  vector<vector<int>> cost = {{1, 10}, {10, 1}, {10, 1}, {1, 10}, {5, 1}};
  int m = 5;
  int n = 2;
  int target = 3;
  int exp = 9;
  int act = solution->minCost(houses, cost, m, n, target);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1473, sample_input02) {
  solution = new Solution();
  vector<int> houses = {0, 2, 1, 2, 0};
  vector<vector<int>> cost = {{1, 10}, {10, 1}, {10, 1}, {1, 10}, {5, 1}};
  int m = 5;
  int n = 2;
  int target = 3;
  int exp = 11;
  int act = solution->minCost(houses, cost, m, n, target);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1473, sample_input03) {
  solution = new Solution();
  vector<int> houses = {3, 1, 2, 3};
  vector<vector<int>> cost = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}};
  int m = 4;
  int n = 3;
  int target = 3;
  int exp = -1;
  int act = solution->minCost(houses, cost, m, n, target);
  EXPECT_EQ(act, exp);
  delete solution;
}