#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 622.
 *      Design Circular Queue
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Design your implementation of the circular queue. The circular queue
 *   is a linear data structure in which the operations are performed based
 *   on FIFO (First In First Out) principle and the last position is
 *   connected back to the first position to make a circle. It is also
 *   called 'Ring
 *   One of the benefits of the circular queue is that we can make use of
 *   the spaces in front of the queue. In a normal queue, once the queue
 *   becomes full, we cannot insert the next element even if there is a
 *   space in front of the queue. But using the circular queue, we can use
 *   the space to store new
 *   Implementation the ‘MyCircularQueue’
 *       -  ‘MyCircularQueue(k)’ Initializes the object with the size of
 *   the queue to be ‘k’
 *       -  ‘int Front()’ Gets the front item from the queue. If the queue
 *   is empty, return ‘-1’
 *       -  ‘int Rear()’ Gets the last item from the queue. If the queue is
 *   empty, return ‘-1’
 *       -  ‘boolean enQueue(int value)’ Inserts an element into the
 *   circular queue. Return ‘true’ if the operation is
 *       -  ‘boolean deQueue()’ Deletes an element from the circular queue.
 *   Return ‘true’ if the operation is
 *       -  ‘boolean isEmpty()’ Checks whether the circular queue is empty
 *   or
 *       -  ‘boolean isFull()’ Checks whether the circular queue is full or
 *   You must solve the problem without using the built-in queue data
 *   structure in your programming language.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ k ≤ 1000’
 *   • ‘0 ≤ value ≤ 1000’
 *   • At most ‘3000’ calls will be made to ‘enQueue’ , ‘deQueue’ , ‘Front’ , ‘Rear’ , ‘isEmpty’ , and ‘isFull’ .
 *
 */

struct q622 : public ::testing::Test {
  // Leetcode answer here
  class MyCircularQueue {
   private:
    vector<int> data;
    int head, tail;

   public:
    MyCircularQueue(int k) : data(k), head{0}, tail{0} {
    }

    bool enQueue(int value) {
      if (isFull()) {
        return false;
      }
      data[head++ % data.size()] = value;

      return true;
    }

    bool deQueue() {
      if (isEmpty()) {
        return false;
      }

      ++tail;
      return true;
    }

    int Front() {
      if (isEmpty()) {
        return -1;
      }

      return data[tail % data.size()];
    }

    int Rear() {
      if (isEmpty()) {
        return -1;
      }

      return data[(head - 1) % data.size()];
    }

    bool isEmpty() {
      return head == tail;
    }

    bool isFull() {
      return head == tail + data.size();
    }
  };

  class MyCircularQueue *my_circular_queue;
};

TEST_F(q622, sample_input01) {
  int k = 3;
  my_circular_queue = new MyCircularQueue(k);
  EXPECT_EQ(my_circular_queue->enQueue(1), true);
  EXPECT_EQ(my_circular_queue->enQueue(2), true);
  EXPECT_EQ(my_circular_queue->enQueue(3), true);
  EXPECT_EQ(my_circular_queue->enQueue(4), false);
  EXPECT_EQ(my_circular_queue->Rear(), 3);
  EXPECT_EQ(my_circular_queue->isFull(), true);
  EXPECT_EQ(my_circular_queue->deQueue(), true);
  EXPECT_EQ(my_circular_queue->enQueue(4), true);
  EXPECT_EQ(my_circular_queue->Rear(), 4);
  delete my_circular_queue;
}