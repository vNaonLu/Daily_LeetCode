#include <gtest/gtest.h>
#include <iostream>
#include <string>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 640.
 *      Solve the Equation
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Solve a given equation and return the value of ‘'x'’ in the form of a
 *   string ‘'x=#value'’ . The equation contains only ‘'+'’ , ‘'-'’
 *   operation, the variable ‘'x'’ and its coefficient. You should return
 *   ‘'No solution'’ if there is no solution for the equation, or
 *   ‘'Infinite solutions'’ if there are infinite solutions for the
 *   If there is exactly one solution for the equation, we ensure that the
 *   value of ‘'x'’ is an integer.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘3 ≤ equation.length ≤ 1000’
 *   • ‘equation’ has exactly one ‘'='’ .
 *   • ‘equation’ consists of integers with an absolute value in the range ‘[0, 100]’ without any leading zeros, and the variable ‘'x'’ .
 *
 */

struct q640 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    struct Coefficient {
      int x, cst;
    };

    template <typename Iterator>
    int toInteger(Iterator beg, Iterator end) {
      if (beg + 1 == end) {
        switch (*beg) {
        case '+':
          return 1;
        case '-':
          return -1;
        default:
          return *beg - '0';
        }
      }

      int scale = 1, num = 0;
      while (beg != end) {
        auto c = *beg++;
        switch (c) {
        case '+':
          scale = 1;
          break;
        case '-':
          scale = -1;
          break;
        default:
          num = num * 10 + (c - '0');
        }
      }

      return scale * num;
    }

    template <typename Iterator>
    Coefficient solveCoefficient(Iterator beg, Iterator end) {
      Coefficient res{0, 0};

      auto prev = beg;
      while (beg != end) {
        auto c = *beg;
        if (c < '0' || c > '9') {
          if (c == 'x') {
            if (prev == beg) {
              ++res.x;
            } else {
              res.x += toInteger(prev, beg);
            }

            prev = ++beg;
          } else {
            res.cst += toInteger(prev, beg);
            prev = beg++;
          }
        } else {
          ++beg;
        }
      }
      res.cst += toInteger(prev, beg);

      return res;
    }

  public:
    string solveEquation(string equation) {
      auto find = equation.begin() + equation.find('=');
      auto left = solveCoefficient(equation.begin(), find),
           right = solveCoefficient(find + 1, equation.end());

      if (left.x == right.x) {

        return left.cst == right.cst ? "Infinite solutions" : "No solution";
      } else {

        return string("x=") + to_string((right.cst - left.cst) / (left.x - right.x));
      }
    }
  };

  class Solution *solution;
};

TEST_F(q640, sample_input01) {
  solution = new Solution();
  string equation = "x+5-3+x=6+x-2";
  string exp = "x=2";
  string act = solution->solveEquation(equation);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q640, sample_input02) {
  solution = new Solution();
  string equation = "x=x";
  string exp = "Infinite solutions";
  string act = solution->solveEquation(equation);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q640, sample_input03) {
  solution = new Solution();
  string equation = "2x=x";
  string exp = "x=0";
  string act = solution->solveEquation(equation);
  EXPECT_EQ(act, exp);
  delete solution;
}