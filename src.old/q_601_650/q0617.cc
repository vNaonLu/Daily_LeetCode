#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 617.
 *      Merge Two Binary Trees
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given two binary trees ‘root1’ and ‘root2’
 *   Imagine that when you put one of them to cover the other, some nodes
 *   of the two trees are overlapped while the others are not. You need to
 *   merge the two trees into a new binary tree. The merge rule is that if
 *   two nodes overlap, then sum node values up as the new value of the
 *   merged node. Otherwise, the NOT null node will be used as the node of
 *   the new
 *   Return “the merged tree”
 *    “Note:” The merging process must start from the root nodes of both
 *   trees.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in both trees is in the range ‘[0, 2000]’ .
 *   • ‘-10⁴ ≤ Node.val ≤ 10⁴’
 *
 */

struct q617 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
      if (root1 != nullptr && root2 != nullptr) {
        root1->val += root2->val;
        root1->left = mergeTrees(root1->left, root2->left);
        root1->right = mergeTrees(root1->right, root2->right);
        return root1;
      } else if (root2 == nullptr) {
        return root1;
      } else {
        return root2;
      }
    }
  };

  class Solution *solution;
};

TEST_F(q617, sample_input01) {
  solution = new Solution();
  TreeNode* root1 = TreeNode::generate({1, 3, 2, 5});
  TreeNode* root2 = TreeNode::generate({2, 1, 3, NULL_TREENODE, 4, NULL_TREENODE, 7});
  TreeNode* exp = TreeNode::generate({3, 4, 5, 5, 4, NULL_TREENODE, 7});
  TreeNode* act = solution->mergeTrees(root1, root2);
  EXPECT_TREENODE_EQ(act, exp);
  TreeNode::release(root1, root2, exp, act);
  delete solution;
}

TEST_F(q617, sample_input02) {
  solution = new Solution();
  TreeNode* root1 = TreeNode::generate({1});
  TreeNode* root2 = TreeNode::generate({1, 2});
  TreeNode* exp = TreeNode::generate({2, 2});
  TreeNode* act = solution->mergeTrees(root1, root2);
  EXPECT_TREENODE_EQ(act, exp);
  TreeNode::release(root1, root2, exp, act);
  delete solution;
}