#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 623.
 *      Add One Row to Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary tree and two integers ‘val’ and ‘depth’ ,
 *   add a row of nodes with value ‘val’ at the given depth ‘depth’
 *   Note that the ‘root’ node is at depth ‘1’
 *   The adding rule
 *       - Given the integer ‘depth’ , for each not null tree node ‘cur’ at
 *   the depth ‘depth - 1’ , create two tree nodes with value ‘val’ as
 *   ‘cur’ 's left subtree root and right subtree
 *       -  ‘cur’ 's original left subtree should be the left subtree of
 *   the new left subtree
 *       -  ‘cur’ 's original right subtree should be the right subtree of
 *   the new right subtree
 *       - If ‘depth = 1’ that means there is no depth ‘depth - 1’ at all,
 *   then create a tree node with value ‘val’ as the new root of the whole
 *   original tree, and the original tree is the new root's left subtree.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[1, 10⁴]’ .
 *   • The depth of the tree is in the range ‘[1, 10⁴]’ .
 *   • ‘-100 ≤ Node.val ≤ 100’
 *   • ‘-10⁵ ≤ val ≤ 10⁵’
 *   • ‘1 ≤ depth ≤ the depth of tree + 1’
 *
 */

struct q623 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    TreeNode* addOneRow(TreeNode* root, int val, int depth) {
      if (depth == 1) {
        return new TreeNode(val, root, nullptr);
      }

      if (root == nullptr) {
        return nullptr;
      } else if (depth == 2) {
        auto p = new TreeNode(val, root->left, nullptr),
             q = new TreeNode(val, nullptr, root->right);
        root->left = p;
        root->right = q;

        return root;
      } else {
        addOneRow(root->left, val, depth - 1);
        addOneRow(root->right, val, depth - 1);

        return root;
      }
    }
  };

  class Solution *solution;
};

TEST_F(q623, sample_input01) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({4, 2, 6, 3, 1, 5});
  int val = 1;
  int depth = 2;
  TreeNode* exp = TreeNode::generate({4, 1, 1, 2, NULL_TREENODE, NULL_TREENODE, 6, 3, 1, 5});
  TreeNode* act = solution->addOneRow(root, val, depth);
  EXPECT_TREENODE_EQ(act, exp);
  TreeNode::release(root, exp, act);
  delete solution;
}

TEST_F(q623, sample_input02) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({4, 2, NULL_TREENODE, 3, 1});
  int val = 1;
  int depth = 3;
  TreeNode* exp = TreeNode::generate({4, 2, NULL_TREENODE, 1, 1, 3, NULL_TREENODE, NULL_TREENODE, 1});
  TreeNode* act = solution->addOneRow(root, val, depth);
  EXPECT_TREENODE_EQ(act, exp);
  TreeNode::release(root, exp, act);
  delete solution;
}