
#ifndef Q141_UNITTEST_H__
#define Q141_UNITTEST_H__
#include <gtest/gtest.h>

#include "../src/q0141.hpp"
using namespace std;

/**
  * this file is generated by gquestion.py
  *
  * 141. Linked List Cycle
  *
  * Given head , the head of a linked list, determine
  * if the linked list has a cycle in it.
  * There is a cycle in a linked list if there is
  * some node in the list that can be reached again by
  * continuously following the next pointer. Internally,
  * pos is used to denote the index of the node
  * thattail';s next pointer is connected to. “Note that
  * pos is not passed as a parameter“ .
  * Return true if there is a cycle in the linked
  * list . Otherwise, return false .
  *
  * Constraints:
  * - The number of the nodes in the list is in the range [0, 10^(4)] .
  * -  -10^(5) <= Node.val <= 10^(5) 
  * -  pos is -1 or a “valid index“ in the linked-list.
  *  “Follow up:“ Can you solve it using O(1) (i.e. constant) memory?
  *
*/

TEST(q141, sample_input01) {
  ListNode *head = ListNode::generate({3, 2, 0, -4}, 0);
  bool exp = true;
  l141::Solution solver;
  EXPECT_EQ(solver.hasCycle(head), exp);
  ListNode::release(head);
}

TEST(q141, sample_input02) {
  ListNode *head = ListNode::generate({1,2}, 0);
  bool exp = true;
  l141::Solution solver;
  EXPECT_EQ(solver.hasCycle(head), exp);
  ListNode::release(head);
}

TEST(q141, sample_input03) {
  ListNode *head = ListNode::generate({1}, -1);
  bool exp = false;
  l141::Solution solver;
  EXPECT_EQ(solver.hasCycle(head), exp);
  ListNode::release(head);
}

#endif