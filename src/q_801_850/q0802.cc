#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <unordered_map>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 802.
 *      Find Eventual Safe States
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   There is a directed graph of ‘n’ nodes with each node labeled from ‘0’
 *   to ‘n - 1’ . The graph is represented by a “0-indexed” 2D integer
 *   array ‘graph’ where ‘graph[i]’ is an integer array of nodes adjacent
 *   to node ‘i’ , meaning there is an edge from node ‘i’ to each node in
 *   ‘graph[i]’
 *   A node is a “terminal node” if there are no outgoing edges. A node is
 *   a “safe node” if every possible path starting from that node leads to
 *   a “terminal node”
 *   Return “an array containing all the “safe nodes” of the graph” . The
 *   answer should be sorted in “ascending” order.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = graph.length’
 *   • ‘1 ≤ n ≤ 10⁴’
 *   • ‘0 ≤ graph[i].length ≤ n’
 *   • ‘0 ≤ graph[i][j] ≤ n - 1’
 *   • ‘graph[i]’ is sorted in a strictly increasing order.
 *   • The graph may contain self-loops.
 *   • The number of edges in the graph will be in the range ‘[1, 4 × 10⁴]’ .
 *
 */

struct q802 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    vector<int> eventualSafeNodes(vector<vector<int>> &graph) {
      vector<int> res, safe(graph.size(), 0);
      vector<unordered_set<int>> g(graph.size()), rg(graph.size());
      queue<int> q;

      for (int i = 0; i < graph.size(); ++i) {
        if (graph[i].empty()) {
          q.emplace(i);
        } else {
          for (auto &x : graph[i]) {
            g[i].insert(x);
            rg[x].insert(i);
          }
        }
      }

      while (!q.empty()) {
        int x = q.front();
        q.pop();
        safe[x] = 1;
        for (auto &y : rg[x]) {
          g[y].erase(x);
          if (g[y].empty()) {
            q.emplace(y);
          }
        }
      }

      for (int i = 0; i < safe.size(); ++i) {
        if (safe[i] != 0) {
          res.emplace_back(i);
        }
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q802, sample_input01) {
  solution = new Solution();
  vector<vector<int>> graph = {{1, 2}, {2, 3}, {5}, {0}, {5}, {}, {}};
  vector<int> exp = {2, 4, 5, 6};
  vector<int> act = solution->eventualSafeNodes(graph);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q802, sample_input02) {
  solution = new Solution();
  vector<vector<int>> graph = {{1, 2, 3, 4}, {1, 2}, {3, 4}, {0, 4}, {}};
  vector<int> exp = {4};
  vector<int> act = solution->eventualSafeNodes(graph);
  EXPECT_EQ(act, exp);
  delete solution;
}