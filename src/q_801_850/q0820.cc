#include <array>
#include <gtest/gtest.h>
#include <iostream>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 820.
 *      Short Encoding of Words
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   A “valid encoding” of an array of ‘words’ is any reference string ‘s’
 *   and array of indices ‘indices’ such
 *       -  ‘words.length = indices.length’
 *       - The reference string ‘s’ ends with the ‘'#'’
 *       - For each index ‘indices[i]’ , the “substring” of ‘s’ starting
 *   from ‘indices[i]’ and up to (but not including) the next ‘'#'’
 *   character is equal to ‘words[i]’
 *   Given an array of ‘words’ , return “the “length of the shortest
 *   reference string” ” ‘s’ “ possible of any “valid encoding” of ”
 *   ‘words’ “.” 
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ words.length ≤ 2000’
 *   • ‘1 ≤ words[i].length ≤ 7’
 *   • ‘words[i]’ consists of only lowercase letters.
 *
 */

struct q820 : public ::testing::Test {
  // Leetcode answer here
class Solution {
private:
    struct Trie {
        array<unique_ptr<Trie>, 26> children;
        int count;
        
        Trie() : count{0} {}
        Trie *next(char c) {
            auto &res = children[c - 'a'];
            if (res == nullptr) {
                res = make_unique<Trie>();
                count++;
            }
            
            return res.get();
        }
    };
public:
    int minimumLengthEncoding(vector<string>& words) {
        auto trie = make_unique<Trie>();
        unordered_map<Trie*, int> nodes;
        for (int i=0; i<words.size(); ++i) {
            auto &s = words[i];
            auto p = trie.get();
            for (int j=s.size()-1; j >=0; --j) {
                p = p->next(s[j]);
            }
            nodes.emplace(p, i);
        }
        
        int res = 0;
        for (auto &[trie, idx] : nodes) {
            if (trie->count == 0) {
                res += words[idx].size() + 1;
            }
        }
        
        return res;
    }
};

  class Solution *solution;
};

TEST_F(q820, sample_input01) {
  solution = new Solution();
  vector<string> words = {"time", "me", "bell"};
  int exp = 10;
  int act = solution->minimumLengthEncoding(words);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q820, sample_input02) {
  solution = new Solution();
  vector<string> words = {"t"};
  int exp = 2;
  int act = solution->minimumLengthEncoding(words);
  EXPECT_EQ(act, exp);
  delete solution;
}