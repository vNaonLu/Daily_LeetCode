
#ifndef LEETCODE_Q27_H__
#define LEETCODE_Q27_H__
#include <algorithm>
#include <iostream>
#include <vector>

namespace l27 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 27.
 *     Remove Element
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an integer array ‘nums’ and an integer ‘val’ , remove all
 *   occurrences of ‘val’ in ‘nums’ <a
 *   href="https://en.wikipedia.org/wiki/In-place_algorithm"
 *   target="_blank"> “in-place” </a>. The relative order of the elements
 *   may be
 *   Since it is impossible to change the length of the array in some
 *   languages, you must instead have the result be placed in the “first
 *   part” of the array ‘nums’ . More formally, if there are ‘k’ elements
 *   after removing the duplicates, then the first ‘k’ elements of ‘nums’
 *   should hold the final result. It does not matter what you leave beyond
 *   the first ‘k’
 *   Return ‘k’ “ after placing the final result in the first ” ‘k’ “ slots
 *   of ” ‘nums’
 *   Do “not” allocate extra space for another array. You must do this by
 *   “modifying the input array <a
 *   href="https://en.wikipedia.org/wiki/In-place_algorithm"
 *   target="_blank">in-place</a>” with O(1) extra
 *    “Custom Judge:”
 *   The judge will test your solution with the following
 *   int[] nums = [...]; // Input
 *   int val = ...; // Value to
 *   int[] expectedNums = [...]; // The expected answer with correct
 *                               // It is sorted with no values equaling
 *   int k = removeElement(nums, val); // Calls your
 *   assert k ==
 *   sort(nums, 0, k); // Sort the first k elements of
 *   for (int i = 0; i < actualLength; i++)
 *       assert nums[i] ==
 *   If all assertions pass, then your solution will be “accepted” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘0 ≤ nums.length ≤ 100’
 *   • ‘0 ≤ nums[i] ≤ 50’
 *   • ‘0 ≤ val ≤ 100’
 *
 */

class Solution {
 public:
  int removeElement(vector<int>& nums, int val) {
    int last = nums.size() - 1;
    for (int i = 0; i <= last; ++i) {
      if (nums[i] == val) {
        while (i <= last && nums[last] == val) --last;
        if (last < i) break;
        swap(nums[i], nums[last]);
      }
    }
    return max(last + 1, 0);
  }
};
}  // namespace l27

#endif