
#ifndef LEETCODE_Q29_H__
#define LEETCODE_Q29_H__
#include <iostream>
#include <limits>

namespace l29 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 29.
 *     Divide Two Integers
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given two integers ‘dividend’ and ‘divisor’ , divide two integers
 *   “without” using multiplication, division, and mod
 *   The integer division should truncate toward zero, which means losing
 *   its fractional part. For example, ‘8.345’ would be truncated to ‘8’ ,
 *   and ‘-2.7335’ would be truncated to ‘-2’
 *   Return “the “quotient” after dividing ” ‘dividend’ “ by ” ‘divisor’
 *    “Note: ” Assume we are dealing with an environment that could only
 *   store integers within the “32-bit” signed integer range: ‘[&minus;2³¹,
 *   2³¹ &minus; 1]’ . For this problem, if the quotient is “strictly
 *   greater than” ‘2³¹ - 1’ , then return ‘2³¹ - 1’ , and if the quotient
 *   is “strictly less than” ‘-2³¹’ , then return ‘-2³¹’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘-2³¹ ≤ dividend, divisor ≤ 2³¹ - 1’
 *   • ‘divisor ≠ 0’
 *
 */
class Solution {
 public:
  int divide(int dividend, int divisor) {
    if (dividend == numeric_limits<int>::min() && divisor == -1)
      return numeric_limits<int>::max();
    long l_divisor, l_dividend, quotient = 0;
    l_divisor = static_cast<long>(divisor);
    l_dividend = static_cast<long>(dividend);
    int sign = (l_dividend < 0 && l_divisor > 0) || (l_divisor < 0 && l_dividend > 0) ? -1 : 1;
    l_dividend = abs(l_dividend);
    l_divisor = abs(l_divisor);
    for (int shift_counter = 31; shift_counter >= 0; shift_counter--) {
      if ((l_divisor << shift_counter) <= l_dividend) {
        l_dividend -= l_divisor << shift_counter;
        quotient = quotient | static_cast<long>(1) << shift_counter;
      }
    }
    return sign * quotient;
  }
};
}  // namespace l29

#endif