
#ifndef Q33_UNITTEST_H__
#define Q33_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0033.hpp"
using namespace std;

/**
  * this file is generated by gquestion.py
  *
  * 33. Search in Rotated Sorted Array
  *
  * There is an integer array nums sorted in
  * ascending order (with “distinct“ values).
  * Prior to being passed to your function, nums is
  * “rotated“ at an unknown pivot index k ( 0 <= k <
  * nums.length ) such that the resulting array is
  * [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1],
  * ..., nums[k-1]] ( “0-indexed“ ). For example,
  * [0,1,2,4,5,6,7] might be rotated at pivot index 3 and
  * become [4,5,6,7,0,1,2] .
  * Given the array nums “after“ the rotation and an
  * integer target , return the index of target if it
  * is in nums , or -1 if it is not in nums .
  * You mustwrite an algorithm with O(log n) runtime
  * complexity.
  *
  * Constraints:
  * -  1 <= nums.length <= 5000 
  * -  -10^(4) <= nums[i] <= 10^(4) 
  * - All values of nums are “unique“ .
  * -  nums is guaranteed to be rotated at some pivot.
  * -  -10^(4) <= target <= 10^(4) 
  *
*/

TEST(q33, sample_input01) {
  vector<int> nums = {4, 5, 6, 7, 0, 1, 2};
  int target = 0;
  int exp = 4;
  l33::Solution solver;
  EXPECT_EQ(solver.search(nums, target), exp);
}

TEST(q33, sample_input02) {
  vector<int> nums = {4, 5, 6, 7, 0, 1, 2};
  int target = 3;
  int exp = -1;
  l33::Solution solver;
  EXPECT_EQ(solver.search(nums, target), exp);
}

TEST(q33, sample_input03) {
  vector<int> nums = {1};
  int target = 0;
  int exp = -1;
  l33::Solution solver;
  EXPECT_EQ(solver.search(nums, target), exp);
}

#endif