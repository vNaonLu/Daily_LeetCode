
#ifndef LEETCODE_Q33_H__
#define LEETCODE_Q33_H__
#include <iostream>
#include <vector>

namespace l33 {
using namespace std;

/**
  * this file is generated by gquestion.py
  *
  * 33. Search in Rotated Sorted Array
  *
  * There is an integer array nums sorted in
  * ascending order (with “distinct“ values).
  * Prior to being passed to your function, nums is
  * “rotated“ at an unknown pivot index k ( 0 <= k <
  * nums.length ) such that the resulting array is
  * [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1],
  * ..., nums[k-1]] ( “0-indexed“ ). For example,
  * [0,1,2,4,5,6,7] might be rotated at pivot index 3 and
  * become [4,5,6,7,0,1,2] .
  * Given the array nums “after“ the rotation and an
  * integer target , return the index of target if it
  * is in nums , or -1 if it is not in nums .
  * You mustwrite an algorithm with O(log n) runtime
  * complexity.
  *
  * Constraints:
  * -  1 <= nums.length <= 5000 
  * -  -10^(4) <= nums[i] <= 10^(4) 
  * - All values of nums are “unique“ .
  * -  nums is guaranteed to be rotated at some pivot.
  * -  -10^(4) <= target <= 10^(4) 
  *
*/
class Solution {
 public:
  int search(vector<int>& nums, int target) {
    int l = 0, r = nums.size() - 1;

    while (l <= r) {
      int mid = l + (r - l) / 2;
      if (nums[mid] == target) return mid;

      if (nums[mid] < nums[r]) {
        if (nums[mid] < target && nums[r] >= target) {
          l = mid + 1;
        } else {
          r = mid - 1;
        }
      } else {
        if (nums[mid] > target && nums[l] <= target) {
          r = mid - 1;
        } else {
          l = mid + 1;
        }
      }
    }
    return -1;
  }
};
}  // namespace l33
#endif