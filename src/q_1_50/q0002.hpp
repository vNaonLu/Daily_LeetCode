
#ifndef LEETCODE_Q2_H__
#define LEETCODE_Q2_H__
#include <iostream>
#include <leetcode/listnode.hpp>

namespace l2 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 2.
  *    Add Two Numbers
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   You are given two “non-empty” linked lists representing two
  *   non-negative integers. The digits are stored in “reverse order” , and
  *   each of their nodes contains a single digit. Add the two numbers and
  *   return the sumas a linked list.
  *   
  *   You may assume the two numbers do not contain any leading zero, except
  *   the number 0 itself.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • The number of nodes in each linked list is in the range ‘[1, 100]’ .
  *   • ‘0 ≤ Node.val ≤ 9’
  *   • It is guaranteed that the list represents a number that does not have leading zeros.
  *
*/

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *   int val;
 *   ListNode *next;
 *   ListNode() : val(0), next(nullptr) {}
 *   ListNode(int x) : val(x), next(nullptr) {}
 *   ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
 public:
  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);
    ListNode* res = &dummy;
    ListNode *p = l1, *q = l2;
    int carry = 0;
    while (p != nullptr || q != nullptr) {
      int x = p == nullptr ? 0 : p->val;
      int y = q == nullptr ? 0 : q->val;
      int sum = x + y + carry;
      carry = sum / 10;
      res->next = new ListNode(sum % 10);
      res = res->next;
      if (p != nullptr) p = p->next;
      if (q != nullptr) q = q->next;
    }
    if (carry != 0) res->next = new ListNode(carry);
    return dummy.next;
  }
};
}  // namespace l2

#endif