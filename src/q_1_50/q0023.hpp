
#ifndef LEETCODE_Q23_H__
#define LEETCODE_Q23_H__
#include <iostream>
#include <leetcode/listnode.hpp>
#include <vector>

namespace l23 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 23.
 *     Merge k Sorted Lists
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given an array of ‘k’ linked-lists ‘lists’ , each linked-list
 *   is sorted in ascending
 *    “Merge all the linked-lists into one sorted linked-list and return
 *   it.” 
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘k = lists.length’
 *   • ‘0 ≤ k ≤ 10^4’
 *   • ‘0 ≤ lists[i].length ≤ 500’
 *   • ‘-10^4 ≤ lists[i][j] ≤ 10^4’
 *   • ‘lists[i]’ is sorted in “ascending order” .
 *   • The sum of ‘lists[i].length’ won't exceed ‘10^4’ .
 *
 */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
 private:
  ListNode *mergeHelper(ListNode *p, ListNode *q) {
    ListNode dummy;
    ListNode *t = &dummy;
    while (p != nullptr && q != nullptr) {
      if (p->val > q->val) {
        t->next = q;
        q = q->next;
      } else {
        t->next = p;
        p = p->next;
      }
      t = t->next;
    }
    if (p != nullptr)
      t->next = p;
    if (q != nullptr)
      t->next = q;
    return dummy.next;
  }

 public:
  ListNode *mergeKLists(vector<ListNode *> &lists) {
    if (lists.empty()) return nullptr;
    for (int i = 1; i < lists.size(); ++i)
      lists[0] = mergeHelper(lists[0], lists[i]);
    return lists.front();
  }
};
}  // namespace l23

#endif