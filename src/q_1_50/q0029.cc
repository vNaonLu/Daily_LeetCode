#include <gtest/gtest.h>
#include <iostream>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 29.
 *     Divide Two Integers
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given two integers ‘dividend’ and ‘divisor’ , divide two integers
 *   “without” using multiplication, division, and mod
 *   The integer division should truncate toward zero, which means losing
 *   its fractional part. For example, ‘8.345’ would be truncated to ‘8’ ,
 *   and ‘-2.7335’ would be truncated to ‘-2’
 *   Return “the “quotient” after dividing ” ‘dividend’ “ by ” ‘divisor’
 *    “Note: ” Assume we are dealing with an environment that could only
 *   store integers within the “32-bit” signed integer range: ‘[&minus;2³¹,
 *   2³¹ &minus; 1]’ . For this problem, if the quotient is “strictly
 *   greater than” ‘2³¹ - 1’ , then return ‘2³¹ - 1’ , and if the quotient
 *   is “strictly less than” ‘-2³¹’ , then return ‘-2³¹’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘-2³¹ ≤ dividend, divisor ≤ 2³¹ - 1’
 *   • ‘divisor ≠ 0’
 *
 */

struct q29 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int divide(int dividend, int divisor) {
      if (dividend == numeric_limits<int>::min() && divisor == -1)
        return numeric_limits<int>::max();
      long l_divisor, l_dividend, quotient = 0;
      l_divisor = static_cast<long>(divisor);
      l_dividend = static_cast<long>(dividend);
      int sign = (l_dividend < 0 && l_divisor > 0) || (l_divisor < 0 && l_dividend > 0) ? -1 : 1;
      l_dividend = abs(l_dividend);
      l_divisor = abs(l_divisor);
      for (int shift_counter = 31; shift_counter >= 0; shift_counter--) {
        if ((l_divisor << shift_counter) <= l_dividend) {
          l_dividend -= l_divisor << shift_counter;
          quotient = quotient | static_cast<long>(1) << shift_counter;
        }
      }
      return sign * quotient;
    }
  };

  class Solution *solution;
};

TEST_F(q29, sample_input01) {
  solution = new Solution();
  int dividend = 10;
  int divisor = 3;
  int exp = 3;
  EXPECT_EQ(solution->divide(dividend, divisor), exp);
  delete solution;
}

TEST_F(q29, sample_input02) {
  solution = new Solution();
  int dividend = 7;
  int divisor = -3;
  int exp = -2;
  EXPECT_EQ(solution->divide(dividend, divisor), exp);
  delete solution;
}

TEST_F(q29, sample_input03) {
  solution = new Solution();
  int dividend = 0;
  int divisor = 1;
  int exp = 0;
  EXPECT_EQ(solution->divide(dividend, divisor), exp);
  delete solution;
}

TEST_F(q29, sample_input04) {
  solution = new Solution();
  int dividend = 1;
  int divisor = 1;
  int exp = 1;
  EXPECT_EQ(solution->divide(dividend, divisor), exp);
  delete solution;
}