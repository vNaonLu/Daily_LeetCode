
#ifndef LEETCODE_Q25_H__
#define LEETCODE_Q25_H__
#include <iostream>
#include <leetcode/listnode.hpp>

namespace l25 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 25.
  *     Reverse Nodes in k-Group
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given a linked list, reverse the nodes of a linked list “k” at a time
  *   and return its modified list.
  *   
  *   “k” is a positive integer and is less than or equal to the length of
  *   the linked list. If the number of nodes is not a multiple of “k” then
  *   left-out nodes, in the end, should remain as it is.
  *   
  *   You maynot alter the values in the list&#39;s nodes, only nodes
  *   themselves may be changed.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • The number of nodes in the listis in the range ‘sz’ .
  *   • ‘1 ≤ sz ≤ 5000’
  *   • ‘0 ≤ Node.val ≤ 1000’
  *   • ‘1 ≤ k ≤ sz’
  *
*/

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
 public:
  ListNode* getNode(ListNode* p, int offset) {
    ListNode* res = p;
    for (int i = 0; i < offset && res != nullptr; i++) {
      res = res->next;
    }
    return res;
  }
  ListNode* reverseNode(ListNode* p, int k) {
    vector<ListNode*> group;
    ListNode* after_group = p;

    for (int i = 0; i < k; i++) {
      if (after_group == nullptr) {
        break;
      } else {
        group.push_back(after_group);
        after_group = after_group->next;
      }
    }

    if (group.size() == k) {
      for (int i = k - 1; i > 0; i--) {
        group[i]->next = group[i - 1];
      }
      group[0]->next = after_group;
      return group[k - 1];
    } else {
      return p;
    }
  }

  ListNode* reverseKGroup(ListNode* head, int k) {
    if (k == 1) return head;
    head = reverseNode(head, k);
    ListNode* p = getNode(head, k - 1);

    while (p != nullptr && p->next != nullptr) {
      p->next = reverseNode(p->next, k);
      p = getNode(p, k);
    }

    return head;
  }
};
}  // namespace l25

#endif