
#ifndef Q29_UNITTEST_H__
#define Q29_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0029.hpp"
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 29.
 *     Divide Two Integers
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given two integers ‘dividend’ and ‘divisor’ , divide two integers
 *   “without” using multiplication, division, and mod
 *   The integer division should truncate toward zero, which means losing
 *   its fractional part. For example, ‘8.345’ would be truncated to ‘8’ ,
 *   and ‘-2.7335’ would be truncated to ‘-2’
 *   Return “the “quotient” after dividing ” ‘dividend’ “ by ” ‘divisor’
 *    “Note: ” Assume we are dealing with an environment that could only
 *   store integers within the “32-bit” signed integer range: ‘[&minus;2³¹,
 *   2³¹ &minus; 1]’ . For this problem, if the quotient is “strictly
 *   greater than” ‘2³¹ - 1’ , then return ‘2³¹ - 1’ , and if the quotient
 *   is “strictly less than” ‘-2³¹’ , then return ‘-2³¹’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘-2³¹ ≤ dividend, divisor ≤ 2³¹ - 1’
 *   • ‘divisor ≠ 0’
 *
 */

TEST(q29, sample_input01) {
  l29::Solution solver;
  int dividend = 10;
  int divisor = 3;
  int exp = 3;
  EXPECT_EQ(solver.divide(dividend, divisor), exp);
}

TEST(q29, sample_input02) {
  l29::Solution solver;
  int dividend = 7;
  int divisor = -3;
  int exp = -2;
  EXPECT_EQ(solver.divide(dividend, divisor), exp);
}

TEST(q29, sample_input03) {
  l29::Solution solver;
  int dividend = 0;
  int divisor = 1;
  int exp = 0;
  EXPECT_EQ(solver.divide(dividend, divisor), exp);
}

TEST(q29, sample_input04) {
  l29::Solution solver;
  int dividend = 1;
  int divisor = 1;
  int exp = 1;
  EXPECT_EQ(solver.divide(dividend, divisor), exp);
}

#endif