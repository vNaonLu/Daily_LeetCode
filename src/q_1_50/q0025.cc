#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/listnode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 25.
 *     Reverse Nodes in k-Group
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a linked list, reverse the nodes of a linked list “k” at a time
 *   and return its modified
 *    “k” is a positive integer and is less than or equal to the length of
 *   the linked list. If the number of nodes is not a multiple of “k” then
 *   left-out nodes, in the end, should remain as it
 *   You maynot alter the values in the list's nodes, only nodes themselves
 *   may be changed.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the listis in the range ‘sz’ .
 *   • ‘1 ≤ sz ≤ 5000’
 *   • ‘0 ≤ Node.val ≤ 1000’
 *   • ‘1 ≤ k ≤ sz’
 *
 */

struct q25 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    ListNode* getNode(ListNode* p, int offset) {
      ListNode* res = p;
      for (int i = 0; i < offset && res != nullptr; i++) {
        res = res->next;
      }
      return res;
    }
    ListNode* reverseNode(ListNode* p, int k) {
      vector<ListNode*> group;
      ListNode* after_group = p;
      for (int i = 0; i < k; i++) {
        if (after_group == nullptr) {
          break;
        } else {
          group.push_back(after_group);
          after_group = after_group->next;
        }
      }
      if (group.size() == k) {
        for (int i = k - 1; i > 0; i--) {
          group[i]->next = group[i - 1];
        }
        group[0]->next = after_group;
        return group[k - 1];
      } else {
        return p;
      }
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
      if (k == 1) return head;
      head = reverseNode(head, k);
      ListNode* p = getNode(head, k - 1);
      while (p != nullptr && p->next != nullptr) {
        p->next = reverseNode(p->next, k);
        p = getNode(p, k);
      }
      return head;
    }
  };

  class Solution *solution;
};

TEST_F(q25, sample_input01) {
  solution = new Solution();
  ListNode* head = ListNode::generate({1, 2, 3, 4, 5});
  int k = 2;
  ListNode* exp = ListNode::generate({2, 1, 4, 3, 5});
  EXPECT_LISTNODE_EQ(solution->reverseKGroup(head, k), exp);
  delete solution;
}

TEST_F(q25, sample_input02) {
  solution = new Solution();
  ListNode* head = ListNode::generate({1, 2, 3, 4, 5});
  int k = 3;
  ListNode* exp = ListNode::generate({3, 2, 1, 4, 5});
  EXPECT_LISTNODE_EQ(solution->reverseKGroup(head, k), exp);
  delete solution;
}

TEST_F(q25, sample_input03) {
  solution = new Solution();
  ListNode* head = ListNode::generate({1, 2, 3, 4, 5});
  int k = 1;
  ListNode* exp = ListNode::generate({1, 2, 3, 4, 5});
  EXPECT_LISTNODE_EQ(solution->reverseKGroup(head, k), exp);
  delete solution;
}

TEST_F(q25, sample_input04) {
  solution = new Solution();
  ListNode* head = ListNode::generate({1});
  int k = 1;
  ListNode* exp = ListNode::generate({1});
  EXPECT_LISTNODE_EQ(solution->reverseKGroup(head, k), exp);
  delete solution;
}