#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/listnode.hpp>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 23.
 *     Merge k Sorted Lists
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given an array of ‘k’ linked-lists ‘lists’ , each linked-list
 *   is sorted in ascending
 *    “Merge all the linked-lists into one sorted linked-list and return
 *   it.” 
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘k = lists.length’
 *   • ‘0 ≤ k ≤ 10^4’
 *   • ‘0 ≤ lists[i].length ≤ 500’
 *   • ‘-10^4 ≤ lists[i][j] ≤ 10^4’
 *   • ‘lists[i]’ is sorted in “ascending order” .
 *   • The sum of ‘lists[i].length’ won't exceed ‘10^4’ .
 *
 */

struct q23 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    ListNode *mergeHelper(ListNode *p, ListNode *q) {
      ListNode dummy;
      ListNode *t = &dummy;
      while (p != nullptr && q != nullptr) {
        if (p->val > q->val) {
          t->next = q;
          q = q->next;
        } else {
          t->next = p;
          p = p->next;
        }
        t = t->next;
      }
      if (p != nullptr)
        t->next = p;
      if (q != nullptr)
        t->next = q;
      return dummy.next;
    }
   public:
    ListNode *mergeKLists(vector<ListNode *> &lists) {
      if (lists.empty()) return nullptr;
      for (int i = 1; i < lists.size(); ++i)
        lists[0] = mergeHelper(lists[0], lists[i]);
      return lists.front();
    }
  };

  class Solution *solution;
};

TEST_F(q23, sample_input01) {
  solution = new Solution();
  vector<ListNode*> lists = {ListNode::generate({1, 4, 5}), ListNode::generate({1, 3, 4}), ListNode::generate({2, 6})};
  ListNode* exp = ListNode::generate({1, 1, 2, 3, 4, 4, 5, 6});
  EXPECT_LISTNODE_EQ(solution->mergeKLists(lists), exp);
  delete solution;
}

TEST_F(q23, sample_input02) {
  solution = new Solution();
  vector<ListNode*> lists = {};
  ListNode* exp = ListNode::generate({});
  EXPECT_LISTNODE_EQ(solution->mergeKLists(lists), exp);
  delete solution;
}

TEST_F(q23, sample_input03) {
  solution = new Solution();
  vector<ListNode*> lists = {ListNode::generate({})};
  ListNode* exp = ListNode::generate({});
  EXPECT_LISTNODE_EQ(solution->mergeKLists(lists), exp);
  delete solution;
}