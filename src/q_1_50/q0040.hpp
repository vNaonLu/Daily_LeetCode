
#ifndef LEETCODE_Q40_H__
#define LEETCODE_Q40_H__
#include <iostream>
#include <vector>

namespace l40 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 40.
  *     Combination Sum II
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given a collection of candidate numbers ( ‘candidates’ ) and a target
  *   number ( ‘target’ ), find all unique combinations in ‘candidates’
  *   where the candidate numbers sum to ‘target’.
  *   
  *   Each number in ‘candidates’ may only be used “once” in the combination.
  *   
  *   “Note:” The solution set must not contain duplicate combinations.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘1 ≤candidates.length ≤ 100’
  *   • ‘1 ≤candidates[i] ≤ 50’
  *   • ‘1 ≤ target ≤ 30’
  *
*/

class Solution {
  void helper(vector<int> &cand, vector<vector<int>> &r, const int &t, vector<int> &c, int &sum, int beg = 0) {
    if (sum == t) {
      r.push_back(c);
    } else if (sum <= t && beg < cand.size()) {
      int i = beg;
      int num = cand[i];
      while (i < cand.size() && num == cand[i]) ++i;
      int same = i - beg;
      helper(cand, r, t, c, sum, i);
      for (int j = 0; j < same; ++j) {
        sum += num;
        c.push_back(num);
        helper(cand, r, t, c, sum, i);
      }

      for (int j = 0; j < same; ++j) {
        sum -= num;
        c.pop_back();
      }
    }
  }

 public:
  vector<vector<int>> combinationSum2(vector<int> &candidates, int target) {
    sort(candidates.begin(), candidates.end());
    vector<vector<int>> res;
    vector<int> tmp;
    int sum = 0;
    helper(candidates, res, target, tmp, sum, 0);
    return res;
  }
};
}  // namespace l40

#endif