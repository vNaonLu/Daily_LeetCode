
#ifndef LEETCODE_Q31_H__
#define LEETCODE_Q31_H__
#include <iostream>
#include <algorithm>
#include <vector>

namespace l31 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 31.
 *     Next Permutation
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Implement “next permutation” , which rearranges numbers into the
 *   lexicographically next greater permutation of
 *   If such an arrangement is not possible, it must rearrange it as the
 *   lowest possible order (i.e., sorted in ascending
 *   The replacement must be “<a
 *   href="http://en.wikipedia.org/wiki/In-place_algorithm"
 *   target="_blank">in place</a>” and use only constantextra memory.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ nums.length ≤ 100’
 *   • ‘0 ≤ nums[i] ≤ 100’
 *
 */

class Solution {
 public:
  void nextPermutation(vector<int>& nums) {
    bool permute = false;
    for (int i = nums.size() - 2; i > -1; i--) {
      if (nums[i] < nums[i + 1]) {
        int j = nums.size() - 1;
        while (j > i && nums[j] <= nums[i]) j--;
        swap(nums[i], nums[j]);
        reverse(nums.begin() + i + 1, nums.end());
        permute = true;
        break;
      }
    }
    if (!permute) reverse(nums.begin(), nums.end());
  }
};
}  // namespace l31

#endif