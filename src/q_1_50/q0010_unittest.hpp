
#ifndef Q10_UNITTEST_H__
#define Q10_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0010.hpp"
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 10.
  *     Regular Expression Matching
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given an input string ‘s’ and a pattern ‘p’ , implement regular
  *   expression matching with support for ‘'.'’ and ‘'×'’.
  *   
  *   - ‘'.'’ Matches any single character.
  *   
  *   - ‘'×'’ Matches zero or more of the preceding element.
  *   
  *   The matching should cover the “entire” input string (not partial).
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘1 ≤ s.length≤ 20’
  *   • ‘1 ≤ p.length≤ 30’
  *   • ‘s’ contains only lowercase English letters.
  *   • ‘p’ contains only lowercase English letters, ‘'.'’ , and ‘'×'’ .
  *   • It is guaranteed for each appearance of the character ‘'×'’ , there will be a previous valid character to match.
  *
*/

TEST(q10, sample_input01) {
  l10::Solution solver;
  string s = "aa";
  string p = "a";
  bool exp = false;
  EXPECT_EQ(solver.isMatch(s, p), exp);
}

TEST(q10, sample_input02) {
  l10::Solution solver;
  string s = "aa";
  string p = "a*";
  bool exp = true;
  EXPECT_EQ(solver.isMatch(s, p), exp);
}

TEST(q10, sample_input03) {
  l10::Solution solver;
  string s = "ab";
  string p = ".*";
  bool exp = true;
  EXPECT_EQ(solver.isMatch(s, p), exp);
}

TEST(q10, sample_input04) {
  l10::Solution solver;
  string s = "aab";
  string p = "c*a*b";
  bool exp = true;
  EXPECT_EQ(solver.isMatch(s, p), exp);
}

TEST(q10, sample_input05) {
  l10::Solution solver;
  string s = "mississippi";
  string p = "mis*is*p*.";
  bool exp = false;
  EXPECT_EQ(solver.isMatch(s, p), exp);
}

TEST(q10, input01) {
  l10::Solution solver;
  string s = "aa";
  string p = "a";
  bool exp = false;
  EXPECT_EQ(solver.isMatch(s, p), exp);
}

#endif