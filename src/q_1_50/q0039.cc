#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/anyorder.hpp>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 39.
 *     Combination Sum
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an array of “distinct” integers ‘candidates’ and a target
 *   integer ‘target’ , return “a list of all “unique combinations” of ”
 *   ‘candidates’ “ where the chosen numbers sum to ” ‘target’ “.” You may
 *   return the combinations in “any order”
 *   The “same” number may be chosen from ‘candidates’ an “unlimited number
 *   of times” . Two combinations are unique if the frequency of at least
 *   one of the chosen numbers is
 *   It is “guaranteed” that the number of unique combinations that sum up
 *   to ‘target’ is less than ‘150’ combinations for the given input.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ candidates.length ≤ 30’
 *   • ‘1 ≤ candidates[i] ≤ 200’
 *   • All elements of ‘candidates’ are “distinct” .
 *   • ‘1 ≤ target ≤ 500’
 *
 */

struct q39 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    void helper(vector<int> &cand, const int &t, vector<vector<int>> &r, vector<int> &c, int sum = 0, int beg = 0) {
      if (beg >= cand.size()) return;
      if (sum == t) {
        r.push_back(c);
      } else {
        for (int i = beg; i < cand.size(); ++i) {
          sum += cand[i];
          if (sum <= t) {
            c.push_back(cand[i]);
            helper(cand, t, r, c, sum, i);
            c.pop_back();
            sum -= cand[i];
          } else {
            sum -= cand[i];
            break;
          }
        }
      }
    }
   public:
    vector<vector<int>> combinationSum(vector<int> &candidates, int target) {
      vector<vector<int>> res;
      vector<int> tmp;
      sort(candidates.begin(), candidates.end());
      helper(candidates, target, res, tmp);
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q39, sample_input01) {
  solution = new Solution();
  vector<int> candidates = {2, 3, 6, 7};
  int target = 7;
  vector<vector<int>> exp = {{2, 2, 3}, {7}};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->combinationSum(candidates, target), exp);
  delete solution;
}

TEST_F(q39, sample_input02) {
  solution = new Solution();
  vector<int> candidates = {2, 3, 5};
  int target = 8;
  vector<vector<int>> exp = {{2, 2, 2, 2}, {2, 3, 3}, {3, 5}};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->combinationSum(candidates, target), exp);
  delete solution;
}

TEST_F(q39, sample_input03) {
  solution = new Solution();
  vector<int> candidates = {2};
  int target = 1;
  vector<vector<int>> exp = {};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->combinationSum(candidates, target), exp);
  delete solution;
}

TEST_F(q39, sample_input04) {
  solution = new Solution();
  vector<int> candidates = {1};
  int target = 1;
  vector<vector<int>> exp = {{1}};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->combinationSum(candidates, target), exp);
  delete solution;
}

TEST_F(q39, sample_input05) {
  solution = new Solution();
  vector<int> candidates = {1};
  int target = 2;
  vector<vector<int>> exp = {{1, 1}};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->combinationSum(candidates, target), exp);
  delete solution;
}