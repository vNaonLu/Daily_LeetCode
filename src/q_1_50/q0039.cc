#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/anyorder.hpp>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 39.
 *     Combination Sum
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an array of “distinct” integers ‘candidates’ and a target
 *   integer ‘target’ , return “a list of all “unique combinations” of ”
 *   ‘candidates’ “ where the chosen numbers sum to ” ‘target’ “.” You may
 *   return the combinations in “any order”
 *   The “same” number may be chosen from ‘candidates’ an “unlimited number
 *   of times” . Two combinations are unique if the frequency of at least
 *   one of the chosen numbers is
 *   It is “guaranteed” that the number of unique combinations that sum up
 *   to ‘target’ is less than ‘150’ combinations for the given input.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ candidates.length ≤ 30’
 *   • ‘1 ≤ candidates[i] ≤ 200’
 *   • All elements of ‘candidates’ are “distinct” .
 *   • ‘1 ≤ target ≤ 500’
 *
 */

struct q39 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    template <typename Iterator>
    void solve(Iterator beg, Iterator end, vector<vector<int>> &res,
               vector<int> &curr, int curr_sum, int target) {
      if (curr_sum > target) {
        return;
      } else if (curr_sum == target) {
        res.emplace_back(curr.begin(), curr.end());
      } else {
        while (beg != end) {
          curr.emplace_back(*beg);
          solve(beg, end, res, curr, curr_sum + *beg, target);
          curr.pop_back();
          ++beg;
        }
      }
    }

  public:
    vector<vector<int>> combinationSum(vector<int> &candidates, int target) {
      auto res = vector<vector<int>>();
      auto tmp = vector<int>();
      solve(candidates.begin(), candidates.end(), res, tmp, 0, target);
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q39, sample_input01) {
  solution                       = new Solution();
  vector<int>         candidates = {2, 3, 6, 7};
  int                 target     = 7;
  vector<vector<int>> exp        = {
             {2, 2, 3},
             {7  }
  };
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->combinationSum(candidates, target), exp);
  delete solution;
}

TEST_F(q39, sample_input02) {
  solution                       = new Solution();
  vector<int>         candidates = {2, 3, 5};
  int                 target     = 8;
  vector<vector<int>> exp        = {
             {2, 2, 2, 2},
             {2, 3, 3},
             {3, 5  }
  };
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->combinationSum(candidates, target), exp);
  delete solution;
}

TEST_F(q39, sample_input03) {
  solution                       = new Solution();
  vector<int>         candidates = {2};
  int                 target     = 1;
  vector<vector<int>> exp        = {};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->combinationSum(candidates, target), exp);
  delete solution;
}

TEST_F(q39, sample_input04) {
  solution                       = new Solution();
  vector<int>         candidates = {1};
  int                 target     = 1;
  vector<vector<int>> exp        = {{1}};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->combinationSum(candidates, target), exp);
  delete solution;
}

TEST_F(q39, sample_input05) {
  solution                       = new Solution();
  vector<int>         candidates = {1};
  int                 target     = 2;
  vector<vector<int>> exp        = {
             {1, 1}
  };
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->combinationSum(candidates, target), exp);
  delete solution;
}