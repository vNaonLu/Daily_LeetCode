
#ifndef Q25_UNITTEST_H__
#define Q25_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0025.hpp"
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 25.
  *     Reverse Nodes in k-Group
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given a linked list, reverse the nodes of a linked list “k” at a time
  *   and return its modified list.
  *   
  *   “k” is a positive integer and is less than or equal to the length of
  *   the linked list. If the number of nodes is not a multiple of “k” then
  *   left-out nodes, in the end, should remain as it is.
  *   
  *   You maynot alter the values in the list&#39;s nodes, only nodes
  *   themselves may be changed.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • The number of nodes in the listis in the range ‘sz’ .
  *   • ‘1 ≤ sz ≤ 5000’
  *   • ‘0 ≤ Node.val ≤ 1000’
  *   • ‘1 ≤ k ≤ sz’
  *
*/

TEST(q25, sample_input01) {
  l25::Solution solver;
  ListNode* head = ListNode::generate({1, 2, 3, 4, 5});
  int k = 2;
  ListNode* exp = ListNode::generate({2, 1, 4, 3, 5});
  EXPECT_LISTNODE_EQ(solver.reverseKGroup(head, k), exp);
}

TEST(q25, sample_input02) {
  l25::Solution solver;
  ListNode* head = ListNode::generate({1, 2, 3, 4, 5});
  int k = 3;
  ListNode* exp = ListNode::generate({3, 2, 1, 4, 5});
  EXPECT_LISTNODE_EQ(solver.reverseKGroup(head, k), exp);
}

TEST(q25, sample_input03) {
  l25::Solution solver;
  ListNode* head = ListNode::generate({1, 2, 3, 4, 5});
  int k = 1;
  ListNode* exp = ListNode::generate({1, 2, 3, 4, 5});
  EXPECT_LISTNODE_EQ(solver.reverseKGroup(head, k), exp);
}

TEST(q25, sample_input04) {
  l25::Solution solver;
  ListNode* head = ListNode::generate({1});
  int k = 1;
  ListNode* exp = ListNode::generate({1});
  EXPECT_LISTNODE_EQ(solver.reverseKGroup(head, k), exp);
}

#endif