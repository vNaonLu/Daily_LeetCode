
#ifndef LEETCODE_Q725_H__
#define LEETCODE_Q725_H__
#include <iostream>
#include <leetcode/listnode.hpp>
#include <vector>

namespace l725 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 725.
  *      Split Linked List in Parts
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given the ‘head’ of a singly linked list and an integer ‘k’ , split
  *   the linked list into ‘k’ consecutive linked list parts.
  *   
  *   The length of each part should be as equal as possible: no two parts
  *   should have a size differing by more than one. This may lead to some
  *   parts being null.
  *   
  *   The parts should be in the order of occurrence in the input list, and
  *   parts occurring earlier should always have a size greater than or
  *   equal to parts occurring later.
  *   
  *   Return “an array of the ” ‘k’ “ parts”.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • The number of nodes in the list is in the range ‘[0, 1000]’ .
  *   • ‘0 ≤ Node.val ≤ 1000’
  *   • ‘1 ≤ k ≤ 50’
  *
*/

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
 public:
  vector<ListNode*> splitListToParts(ListNode* head, int k) {
    int cnt = 0;
    ListNode *p = head, *q = nullptr;
    while (p != nullptr) {
      ++cnt;
      p = p->next;
    }
    vector<ListNode*> res;
    int split = cnt / k, left = cnt % k;
    p = head;
    for (int i = 0; i < k; ++i) {
      q = p;
      int cur = split + (left > 0 ? 1 : 0) - 1;
      --left;
      while (p != nullptr && cur > 0) {
        --cur;
        p = p->next;
      }
      res.push_back(q);
      if (p != nullptr) {
        q = p;
        p = p->next;
        q->next = nullptr;
      }
    }
    return res;
  }
};
}  // namespace l725

#endif