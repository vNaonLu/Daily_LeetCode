#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 743.
 *      Network Delay Time
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given a network of ‘n’ nodes, labeled from ‘1’ to ‘n’ . You
 *   are also given ‘times’ , a list of travel times as directed edges
 *   ‘times[i] = (uᵢ, vᵢ, wᵢ)’ , where ‘uᵢ’ is the source node, ‘vᵢ’ is the
 *   target node, and ‘wᵢ’ is the time it takes for a signal to travel from
 *   source to
 *   We will send a signal from a given node ‘k’ . Return the time it takes
 *   for all the ‘n’ nodes to receive the signal. If it is impossible for
 *   all the ‘n’ nodes to receive the signal, return ‘-1’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ k ≤ n ≤ 100’
 *   • ‘1 ≤ times.length ≤ 6000’
 *   • ‘times[i].length = 3’
 *   • ‘1 ≤ uᵢ, vᵢ ≤ n’
 *   • ‘uᵢ ≠ vᵢ’
 *   • ‘0 ≤ wᵢ ≤ 100’
 *   • All the pairs ‘(uᵢ, vᵢ)’ are “unique” . (i.e., no multiple edges.)
 *
 */

struct q743 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    void dijkstra(vector<vector<pair<int, int>>> &network, int start, vector<int> &receive) {
      vector<int> visited(network.size(), 0);
      receive[start] = 0;

      priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
      pq.emplace(0, start);

      while (!pq.empty()) {
        auto [time, node] = pq.top();
        pq.pop();

        if (time > receive[node]) {
          continue;
        }

        for (auto &n : network[node]) {
          auto &[next, take] = n;

          if (take + time < receive[next]) {
            receive[next] = take + time;
            pq.emplace(take + time, next);
          }
        }
      }
    }

   public:
    inline constexpr static int unreachable = numeric_limits<int>::max();
    int networkDelayTime(vector<vector<int>> &times, int n, int k) {
      vector<vector<pair<int, int>>> network(n + 1);
      vector<int>                    received(n + 1, unreachable);
      for (auto &v : times) {
        network[v[0]].emplace_back(v[1], v[2]);
      }
      dijkstra(network, k, received);

      int res = 0;
      for (int i = 1; i <= n; ++i) {
        res = max(received[i], res);
      }

      return res == unreachable ? -1 : res;
    }
  };

  class Solution *solution;
};

TEST_F(q743, sample_input01) {
  solution = new Solution();
  vector<vector<int>> times = {{2, 1, 1}, {2, 3, 1}, {3, 4, 1}};
  int n = 4;
  int k = 2;
  int exp = 2;
  int act = solution->networkDelayTime(times, n, k);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q743, sample_input02) {
  solution = new Solution();
  vector<vector<int>> times = {{1, 2, 1}};
  int n = 2;
  int k = 1;
  int exp = 1;
  int act = solution->networkDelayTime(times, n, k);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q743, sample_input03) {
  solution = new Solution();
  vector<vector<int>> times = {{1, 2, 1}};
  int n = 2;
  int k = 2;
  int exp = -1;
  int act = solution->networkDelayTime(times, n, k);
  EXPECT_EQ(act, exp);
  delete solution;
}