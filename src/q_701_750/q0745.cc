#include <array>
#include <gtest/gtest.h>
#include <iostream>
#include <memory>
#include <unordered_set>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 745.
 *      Prefix and Suffix Search
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Design a special dictionary with some words that searchs the words in
 *   it by a prefix and a
 *   Implement the ‘WordFilter’
 *       -  ‘WordFilter(string[] words)’ Initializes the object with the
 *   ‘words’ in the
 *       -  ‘f(string prefix, string suffix)’ Returns “the index of the
 *   word in the dictionary,” which has the prefix ‘prefix’ and the suffix
 *   ‘suffix’ . If there is more than one valid index, return “the largest”
 *   of them. If there is no such word in the dictionary, return ‘-1’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ words.length ≤ 15000’
 *   • ‘1 ≤ words[i].length ≤ 10’
 *   • ‘1 ≤ prefix.length, suffix.length ≤ 10’
 *   • ‘words[i]’ , ‘prefix’ and ‘suffix’ consist of lower-case English letters only.
 *   • At most ‘15000’ calls will be made to the function ‘f’ .
 *
 */

struct q745 : public ::testing::Test {
  // Leetcode answer here
class WordFilter {
private:
    struct Trie {
        int index;
        array<unique_ptr<Trie>, 27> next; /// with 'z' + 1
    };
    
    unique_ptr<Trie> memo;
    
    template <typename iterator>
    void build_trie(Trie *target, int index, iterator beg, iterator end) {
        Trie *p = target;
        while (beg != end) {
            auto &next = p->next[*beg++ - 'a'];
            
            if (nullptr == next) {
                next = make_unique<Trie>();
            }
            next->index = index;
            p = next.get();
        }
    }
    
    void build_tries(vector<string> const &words) {
        for (int i=0; i<words.size(); ++i) {
            const auto &s = words[i];
            for (int j=0; j<s.size(); ++j) {
                string tmp = s.substr(j) + "{" + s;
                build_trie(memo.get(), i, tmp.begin(), tmp.end());
            }
        }
    }
    
    template <typename iterator>
    Trie *match(Trie *target, iterator beg, iterator end) {
        Trie *p = target;
        while (beg != end && nullptr != p) {
            p = p->next[*beg++ - 'a'].get();
        }
        return p;
    }
    
public:
    WordFilter(vector<string>& words) 
        : memo{make_unique<Trie>()} {
        build_tries(words);
    }
    
    int f(string pre, string suf) {
        string key = suf + "{" + pre;
        auto res = match(memo.get(), key.begin(), key.end());
        
        return res == nullptr ? -1 : res->index;
    }
};

  class WordFilter *word_filter;
};

TEST_F(q745, sample_input01) {
  vector<string> words = {"apple"};
  word_filter = new WordFilter(words);
  EXPECT_EQ(word_filter->f("a", "e"), 0);
  delete word_filter;
}