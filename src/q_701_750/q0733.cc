#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 733.
 *      Flood Fill
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   An image is represented by an ‘m x n’ integer grid ‘image’ where
 *   ‘image[i][j]’ represents the pixel value of the
 *   You are also given three integers ‘sr’ , ‘sc’ , and ‘newColor’ . You
 *   should perform a “flood fill” on the image starting from the pixel
 *   ‘image[sr][sc]’
 *   To perform a “flood fill” , consider the starting pixel, plus any
 *   pixels connected “4-directionally” to the starting pixel of the same
 *   color as the starting pixel, plus any pixels connected
 *   “4-directionally” to those pixels (also with the same color), and so
 *   on. Replace the color of all of the aforementioned pixels with
 *   ‘newColor’
 *   Return “the modified image after performing the flood fill” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘m = image.length’
 *   • ‘n = image[i].length’
 *   • ‘1 ≤ m, n ≤ 50’
 *   • ‘0 ≤ image[i][j], newColor < 2¹⁶’
 *   • ‘0 ≤ sr <m’
 *   • ‘0 ≤ sc <n’
 *
 */

struct q733 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    vector<pair<int, int>> dir{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
   public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
      vector<vector<bool>> visit(image.size(), vector<bool>(image[0].size(), false));
      queue<pair<int, int>> q;
      int color = image[sr][sc];
      q.push({sr, sc});
      while (!q.empty()) {
        auto point = q.front();
        q.pop();
        image[point.first][point.second] = newColor;
        for (int i = 0; i < 4; ++i) {
          pair<int, int> new_p = {point.first + dir[i].first,
                                  point.second + dir[i].second};
          if (new_p.first >= 0 &&
              new_p.first < image.size() &&
              new_p.second >= 0 &&
              new_p.second < image[0].size() &&
              !visit[new_p.first][new_p.second] &&
              image[new_p.first][new_p.second] == color) {
            visit[new_p.first][new_p.second] = true;
            q.push(new_p);
          }
        }
      }
      return image;
    }
  };

  class Solution *solution;
};

TEST_F(q733, sample_input01) {
  solution = new Solution();
  vector<vector<int>> image = {{1, 1, 1}, {1, 1, 0}, {1, 0, 1}};
  int sr = 1;
  int sc = 1;
  int newColor = 2;
  vector<vector<int>> exp = {{2, 2, 2}, {2, 2, 0}, {2, 0, 1}};
  EXPECT_EQ(solution->floodFill(image, sr, sc, newColor), exp);
  delete solution;
}

TEST_F(q733, sample_input02) {
  solution = new Solution();
  vector<vector<int>> image = {{0, 0, 0}, {0, 0, 0}};
  int sr = 0;
  int sc = 0;
  int newColor = 2;
  vector<vector<int>> exp = {{2, 2, 2}, {2, 2, 2}};
  EXPECT_EQ(solution->floodFill(image, sr, sc, newColor), exp);
  delete solution;
}