
#ifndef LEETCODE_Q721_H__
#define LEETCODE_Q721_H__
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

namespace l721 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 721.
 *      Accounts Merge
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a list of ‘accounts’ where each element ‘accounts[i]’ is a list
 *   of strings, where the first element ‘accounts[i][0]’ is a name, and
 *   the rest of the elements are “emails” representing emails of the
 *   Now, we would like to merge these accounts. Two accounts definitely
 *   belong to the same person if there is some common email to both
 *   accounts. Note that even if two accounts have the same name, they may
 *   belong to different people as people could have the same name. A
 *   person can have any number of accounts initially, but all of their
 *   accounts definitely have the same
 *   After merging the accounts, return the accounts in the following
 *   format: the first element of each account is the name, and the rest of
 *   the elements are emails “in sorted order” . The accounts themselves
 *   can be returned in “any order” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ accounts.length ≤ 1000’
 *   • ‘2 ≤ accounts[i].length ≤ 10’
 *   • ‘1 ≤ accounts[i][j] ≤ 30’
 *   • ‘accounts[i][0]’ consists of English letters.
 *   • ‘accounts[i][j] (for j > 0)’ is a valid email.
 *
 */

class Solution {
 private:
  int find(int x, vector<int>& parent) {
    while (x != parent[x]) {
      parent[x] = parent[parent[x]];
      x = parent[x];
    }
    return x;
  }
  void merge(int x, int y, vector<int>& parent) {
    int parX = find(x, parent);
    int parY = find(y, parent);
    parent[parY] = parX;
  }

 public:
  vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
    int sz = accounts.size();

    unordered_map<string, int> isEmailPresent;
    vector<int> parent(sz, 0);

    for (int i = 0; i < sz; i++) {
      parent[i] = i;
    }

    for (int id = 0; id < sz; id++) {
      int listSize = accounts[id].size();

      for (int j = 1; j < listSize; j++) {
        string email = accounts[id][j];

        if (isEmailPresent.find(email) != isEmailPresent.end()) {
          int accountID = isEmailPresent[email];
          merge(accountID, id, parent);
        } else {
          isEmailPresent[email] = id;
        }
      }
    }

    unordered_map<int, vector<int>> mergedAccounts;
    unordered_map<int, vector<int>>::iterator itr;
    vector<vector<string>> answer;

    for (int i = 0; i < sz; i++) {
      mergedAccounts[find(i, parent)].push_back(i);
    }

    for (itr = mergedAccounts.begin(); itr != mergedAccounts.end(); itr++) {
      vector<int> allAccounts = itr->second;
      set<string> tmpSet;

      for (int j = 0; j < allAccounts.size(); j++) {
        int id = allAccounts[j];
        for (int i = 1; i < accounts[id].size(); i++) {
          tmpSet.insert(accounts[id][i]);
        }
      }

      vector<string> tmpAns;
      string accountName = accounts[allAccounts[0]][0];
      tmpAns.push_back(accountName);

      set<string>::iterator itr = tmpSet.begin();

      while (itr != tmpSet.end()) {
        tmpAns.push_back(*itr);
        itr++;
      }

      sort(tmpAns.begin() + 1, tmpAns.end());
      answer.push_back(tmpAns);
    }

    return answer;
  }
};
}  // namespace l721

#endif