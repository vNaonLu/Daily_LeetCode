#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1829.
 *       Maximum XOR for Each Query
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given a “sorted” array ‘nums’ of ‘n’ non-negative integers and
 *   an integer ‘maximumBit’ . You want to perform the following query ‘n’
 *   “times”
 *       1. Find a non-negative integer ‘k < 2^(maximumBit)’ such that
 *   ‘nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k’ is
 *   “maximized” . ‘k’ is the answer to the ‘iᵗʰ’
 *       2. Remove the “last ” element from the current array ‘nums’
 *   Return “an array” ‘answer’ “, where ” ‘answer[i]’ “ is the answer to
 *   the ” ‘iᵗʰ’ “ query” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘nums.length = n’
 *   • ‘1 ≤ n ≤ 10⁵’
 *   • ‘1 ≤ maximumBit ≤ 20’
 *   • ‘0 ≤ nums[i] < 2^(maximumBit)’
 *   • ‘nums’ ​​​ is sorted in “ascending” order.
 *
 */

struct q1829 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    vector<int> getMaximumXor(vector<int>& nums, int maximumBit) {
      int n = nums.size();
      int mask = (1 << maximumBit) - 1;
      vector<int> res(nums.size(), 0);
      res.back() = nums.front();
      for (int i = 1; i < n; ++i) {
        res[n - i - 1] = res[n - i] ^ nums[i];
      }

      for (auto it = res.begin(); it != res.end(); ++it) {
        *it ^= mask;
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1829, sample_input01) {
  solution = new Solution();
  vector<int> nums = {0, 1, 1, 3};
  int maximumBit = 2;
  vector<int> exp = {0, 3, 2, 3};
  vector<int> act = solution->getMaximumXor(nums, maximumBit);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1829, sample_input02) {
  solution = new Solution();
  vector<int> nums = {2, 3, 4, 7};
  int maximumBit = 3;
  vector<int> exp = {5, 2, 6, 5};
  vector<int> act = solution->getMaximumXor(nums, maximumBit);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1829, sample_input03) {
  solution = new Solution();
  vector<int> nums = {0, 1, 2, 2, 5, 7};
  int maximumBit = 3;
  vector<int> exp = {4, 3, 6, 4, 6, 7};
  vector<int> act = solution->getMaximumXor(nums, maximumBit);
  EXPECT_EQ(act, exp);
  delete solution;
}