#include <algorithm>
#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1834.
 *       Single-Threaded CPU
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given ‘n’ ​​​​​​ tasks labeled from ‘0’ to ‘n
 * - 1’ represented by a 2D integer array ‘tasks’ , where ‘tasks[i] =
 * [enqueueTimeᵢ,
 *   processingTimeᵢ]’ means that the ‘i^(​​​​​​th)’
 * ​​​​ task will be available to process at ‘enqueueTimeᵢ’ and
 * will take ‘processingTimeᵢ’ ⎽( )to finish You have a single-threaded CPU that
 * can process “at most one” task at a time and will act in the following
 *       - If the CPU is idle and there are no available tasks to process,
 *   the CPU remains
 *       - If the CPU is idle and there are available tasks, the CPU will
 *   choose the one with the “shortest processing time” . If multiple tasks
 *   have the same shortest processing time, it will choose the task with
 *   the smallest
 *       - Once a task is started, the CPU will “process the entire task”
 *   without
 *       - The CPU can finish a task then start a new one
 *   Return “the order in which the CPU will process the tasks.”
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘tasks.length = n’
 *   • ‘1 ≤ n ≤ 10⁵’
 *   • ‘1 ≤ enqueueTimeᵢ, processingTimeᵢ ≤ 10⁹’
 *
 */

struct q1834 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    vector<int> getOrder(vector<vector<int>> &tasks) {
      for (int i = 0; i < tasks.size(); ++i) {
        tasks[i].emplace_back(i);
      }
      auto res = vector<int>();
      auto pq  = priority_queue<vector<int>, vector<vector<int>>,
                               greater<vector<int>>>();
      sort(tasks.begin(), tasks.end());

      int cur_time = 0;
      int cur_idx  = 0;
      while (res.size() < tasks.size()) {
        if (pq.empty() && cur_idx < tasks.size()) {
          cur_time = max(cur_time, tasks[cur_idx][0]);
        }

        while (cur_idx < tasks.size() && tasks[cur_idx][0] <= cur_time) {
          pq.emplace(vector<int>{tasks[cur_idx][1], tasks[cur_idx][2]});
          ++cur_idx;
        }

        auto next = pq.top();
        pq.pop();

        cur_time = min<int>(1e9, cur_time + next[0]);
        res.emplace_back(next[1]);
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1834, sample_input01) {
  solution                  = new Solution();
  vector<vector<int>> tasks = {
      {1, 2},
      {2, 4},
      {3, 2},
      {4, 1}
  };
  vector<int> exp = {0, 2, 3, 1};
  vector<int> act = solution->getOrder(tasks);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1834, sample_input02) {
  solution                  = new Solution();
  vector<vector<int>> tasks = {
      {7, 10},
      {7, 12},
      {7,  5},
      {7,  4},
      {7,  2}
  };
  vector<int> exp = {4, 3, 2, 0, 1};
  vector<int> act = solution->getOrder(tasks);
  EXPECT_EQ(act, exp);
  delete solution;
}
