
#ifndef LEETCODE_Q148_H__
#define LEETCODE_Q148_H__
#include <iostream>
#include <leetcode/listnode.hpp>

namespace l148 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 148.
 *      Sort List
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘head’ of a linked list, return “the list after sorting it
 *   in “ascending order” ” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the list is in the range ‘[0, 5 × 10⁴]’ .
 *   • ‘-10⁵ ≤ Node.val ≤ 10⁵’
 *
 */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
 private:
  ListNode* merge(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);
    ListNode* res = &dummy;
    while (l1 != nullptr && l2 != nullptr) {
      if (l1->val < l2->val) {
        res->next = l1;
        l1 = l1->next;
      } else {
        res->next = l2;
        l2 = l2->next;
      }
      res = res->next;
    }
    if (l1 != nullptr) res->next = l1;
    if (l2 != nullptr) res->next = l2;
    return dummy.next;
  }
  ListNode* sort(ListNode* beg, ListNode* end) {
    if (beg == end) return beg;
    ListNode *slow = beg, *fast = beg;
    while (fast != end && fast->next != end) {
      slow = slow->next;
      fast = fast->next->next;
    }
    ListNode* tmp = slow;
    slow = slow->next;
    tmp->next = nullptr;
    return merge(sort(beg, tmp), sort(slow, end));
  }

 public:
  ListNode* sortList(ListNode* head) {
    if (head == nullptr) return nullptr;
    return sort(head, nullptr);
  }
};
}  // namespace l148

#endif