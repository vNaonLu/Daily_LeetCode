#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>
#include <stack>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 114.
 *      Flatten Binary Tree to Linked List
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary tree, flatten the tree into a 'linked
 *       - The 'linked list' should use the same ‘TreeNode’ class where the
 *   ‘right’ child pointer points to the next node in the list and the
 *   ‘left’ child pointer is always ‘null’
 *       - The 'linked list' should be in the same order as a <a
 *   href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR"
 *   target="_blank"> “pre-order”  “ traversal” </a> of the binary tree.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[0, 2000]’ .
 *   • ‘-100 ≤ Node.val ≤ 100’
 *
 */

struct q114 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    void flatten(TreeNode* root) {
      if (root == nullptr) return;
      stack<TreeNode*> s;
      s.push(root);
      while (!s.empty()) {
        auto node = s.top();
        s.pop();
        if (node->right != nullptr)
          s.push(node->right);
        if (node->left != nullptr)
          s.push(node->left);
        node->left = nullptr;
        if (!s.empty())
          node->right = s.top();
      }
    }
  };

  class Solution *solution;
};

TEST_F(q114, sample_input01) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1, 2, 5, 3, 4, NULL_TREENODE, 6});
  TreeNode* exp = TreeNode::generate({1, NULL_TREENODE, 2, NULL_TREENODE, 3, NULL_TREENODE, 4, NULL_TREENODE, 5, NULL_TREENODE, 6});
  solution->flatten(root);
  // Assume the first argument is answer.
  EXPECT_TREENODE_EQ(root, exp);
  delete solution;
}

TEST_F(q114, sample_input02) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({});
  TreeNode* exp = TreeNode::generate({});
  solution->flatten(root);
  // Assume the first argument is answer.
  EXPECT_TREENODE_EQ(root, exp);
  delete solution;
}

TEST_F(q114, sample_input03) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({0});
  TreeNode* exp = TreeNode::generate({0});
  solution->flatten(root);
  // Assume the first argument is answer.
  EXPECT_TREENODE_EQ(root, exp);
  delete solution;
}