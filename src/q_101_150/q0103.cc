#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 103.
 *      Binary Tree Zigzag Level Order Traversal
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary tree, return “the zigzag level order
 *   traversal of its nodes' values” . (i.e., from left to right, then
 *   right to left for the next level and alternate between).
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[0, 2000]’ .
 *   • ‘-100 ≤ Node.val ≤ 100’
 *
 */

struct q103 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
      vector<vector<int>> res;
      if (root == nullptr) return res;
      deque<TreeNode*> dq;
      dq.push_back(root);
      int i = 0;
      TreeNode* temp = nullptr;
      while (!dq.empty()) {
        int s = dq.size();
        vector<int> ll;
        if (i % 2 == 0) {
          while (s--) {
            temp = dq.front();
            dq.pop_front();
            ll.push_back(temp->val);
            if (temp->left != NULL) dq.push_back(temp->left);
            if (temp->right != NULL) dq.push_back(temp->right);
          }
        } else {
          while (s--) {
            temp = dq.back();
            dq.pop_back();
            ll.push_back(temp->val);
            if (temp->right != NULL) dq.push_front(temp->right);
            if (temp->left != NULL) dq.push_front(temp->left);
          }
        }
        res.push_back(ll);
        i++;
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q103, sample_input01) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({3, 9, 20, NULL_TREENODE, NULL_TREENODE, 15, 7});
  vector<vector<int>> exp = {{3}, {20, 9}, {15, 7}};
  EXPECT_EQ(solution->zigzagLevelOrder(root), exp);
  delete solution;
}

TEST_F(q103, sample_input02) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1});
  vector<vector<int>> exp = {{1}};
  EXPECT_EQ(solution->zigzagLevelOrder(root), exp);
  delete solution;
}

TEST_F(q103, sample_input03) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({});
  vector<vector<int>> exp = {};
  EXPECT_EQ(solution->zigzagLevelOrder(root), exp);
  delete solution;
}