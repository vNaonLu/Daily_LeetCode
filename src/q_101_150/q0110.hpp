
#ifndef LEETCODE_Q110_H__
#define LEETCODE_Q110_H__
#include <iostream>
#include <leetcode/treenode.hpp>
#include <unordered_map>

namespace l110 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 110.
  *      Balanced Binary Tree
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given a binary tree, determine if it is height-balanced.
  *   
  *   For this problem, a height-balanced binary tree is defined.
  *   
  *   a binary tree in which the left and right subtrees of “every” node
  *   differ in height by no more than 1.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • The number of nodes in the tree is in the range ‘[0, 5000]’ .
  *   • ‘-10⁴ ≤ Node.val ≤ 10⁴’
  *
*/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
 private:
  unordered_map<unsigned long, int> H;
  int height(TreeNode* root) {
    if (root == nullptr) return 0;
    if (!H.count((unsigned long)root))
      H[(unsigned long)root] = max(height(root->left), height(root->right)) + 1;
    return H[(unsigned long)root];
  }

 public:
  bool isBalanced(TreeNode* root) {
    if (root == nullptr) return true;
    if (root->left == nullptr) {
      return height(root->right) <= 1;
    } else if (root->right == nullptr) {
      return height(root->left) <= 1;
    }

    if (!isBalanced(root->left)) return false;
    if (!isBalanced(root->right)) return false;
    return abs(height(root->left) - height(root->right)) <= 1;
  }
};
}  // namespace l110

#endif