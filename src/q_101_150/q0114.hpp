
#ifndef LEETCODE_Q114_H__
#define LEETCODE_Q114_H__
#include <iostream>
#include <leetcode/treenode.hpp>
#include <stack>

namespace l114 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 114.
  *      Flatten Binary Tree to Linked List
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given the ‘root’ of a binary tree, flatten the tree into a "linked.
  *   
  *   - The "linked list" should use the same ‘TreeNode’ class where the
  *   ‘right’ child pointer points to the next node in the list and the
  *   ‘left’ child pointer is always ‘null’.
  *   
  *   - The "linked list" should be in the same order as a <a
  *   href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR"
  *   target="_blank"> “pre-order”  “ traversal” </a> of the binary tree.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • The number of nodes in the tree is in the range ‘[0, 2000]’ .
  *   • ‘-100 ≤ Node.val ≤ 100’
  *
*/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
 public:
  void flatten(TreeNode* root) {
    if (root == nullptr) return;
    stack<TreeNode*> s;
    s.push(root);
    while (!s.empty()) {
      auto node = s.top();
      s.pop();
      if (node->right != nullptr)
        s.push(node->right);
      if (node->left != nullptr)
        s.push(node->left);
      node->left = nullptr;
      if (!s.empty())
        node->right = s.top();
    }
  }
};
}  // namespace l114

#endif