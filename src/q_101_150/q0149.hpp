
#ifndef LEETCODE_Q149_H__
#define LEETCODE_Q149_H__
#include <iostream>
#include <limits>
#include <unordered_map>
#include <vector>

namespace l149 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 149.
  *      Max Points on a Line
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given an array of ‘points’ where ‘points[i] = [xᵢ, yᵢ]’ represents a
  *   point on the “X-Y” plane, return “the maximum number of points that
  *   lie on the same straight line”.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘1 ≤ points.length ≤ 300’
  *   • ‘points[i].length = 2’
  *   • ‘-10⁴ ≤ xᵢ, yᵢ ≤ 10⁴’
  *   • All the ‘points’ are “unique” .
  *
*/

class Solution {
 public:
  int maxPoints(vector<vector<int>>& points) {
    int res = 0;
    for (auto pt1 = points.begin(); pt1 != points.end(); ++pt1) {
      unordered_map<double, int> slope;
      int same = 1;
      for (auto pt2 = pt1 + 1; pt2 != points.end(); ++pt2) {
        if (*pt1 == *pt2) {
          ++same;
        } else if ((*pt1)[0] == (*pt2)[0]) {
          ++slope[numeric_limits<double>::max()];
        } else {
          double s = (double)((*pt2)[1] - (*pt1)[1]) / (double)((*pt2)[0] - (*pt1)[0]);
          ++slope[s];
        }
      }
      int local_max = 0;
      for (auto it = slope.begin(); it != slope.end(); ++it)
        local_max = max(local_max, it->second);
      res = max(res, local_max + same);
    }
    return res;
  }
};
}  // namespace l149

#endif