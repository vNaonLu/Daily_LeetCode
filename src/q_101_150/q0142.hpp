
#ifndef LEETCODE_Q142_H__
#define LEETCODE_Q142_H__
#include <iostream>

namespace l142 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 142.
  *      Linked List Cycle II
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given the ‘head’ of a linked list, return “the node where the cycle
  *   begins. If there is no cycle, return ” ‘null’.
  *   
  *   There is a cycle in a linked list if there is some node in the list
  *   that can be reached again by continuously following the ‘next’ pointer
  *   Internally, ‘pos’ is used to denote the index of the node that
  *   tail&#39;s ‘next’ pointer is connected to ( “0-indexed” ). It is ‘-1’
  *   if there is no cycle. “Note that” ‘pos’ “is not passed as a parameter”
  *   .
  *   
  *   “Do not modify” the linked list.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • The number of the nodes in the list is in the range ‘[0, 10⁴]’ .
  *   • ‘-10⁵ ≤ Node.val ≤ 10⁵’
  *   • ‘pos’ is ‘-1’ or a “valid index” in the linked-list.
  *
*/

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
 public:
  ListNode *detectCycle(ListNode *head) {
    auto p = head, tmp = head;
    while (p != nullptr) {
      p = p->next;
      tmp = tmp->next;
      if (p) {
        p = p->next;
        if (tmp == p) {
          tmp = head;
          break;
        }
      }
    }

    while (p != nullptr && p != tmp) {
      p = p->next;
      tmp = tmp->next;
    }
    return p;
  }
};
}  // namespace l142

#endif