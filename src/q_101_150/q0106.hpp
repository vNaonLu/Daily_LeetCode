
#ifndef LEETCODE_Q106_H__
#define LEETCODE_Q106_H__
#include <iostream>
#include <leetcode/treenode.hpp>
#include <vector>

namespace l106 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 106.
 *      Construct Binary Tree from Inorder and Postorder Traversal
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given two integer arrays ‘inorder’ and ‘postorder’ where ‘inorder’ is
 *   the inorder traversal of a binary tree and ‘postorder’ is the
 *   postorder traversal of the same tree, construct and return “the binary
 *   tree” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ inorder.length ≤ 3000’
 *   • ‘postorder.length = inorder.length’
 *   • ‘-3000 ≤ inorder[i], postorder[i] ≤ 3000’
 *   • ‘inorder’ and ‘postorder’ consist of “unique” values.
 *   • Each value of ‘postorder’ also appears in ‘inorder’ .
 *   • ‘inorder’ is “guaranteed” to be the inorder traversal of the tree.
 *   • ‘postorder’ is “guaranteed” to be the postorder traversal of the tree.
 *
 */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
 private:
  vector<int> inord, postord;
  TreeNode* helper(int l, int r, int& cur) {
    if (l > r) return nullptr;
    int i = find(inord.begin(), inord.end(), postord[cur--]) - inord.begin();
    auto right = helper(i + 1, r, cur);
    auto left = helper(l, i - 1, cur);
    return new TreeNode(inord[i], left, right);
  }

 public:
  TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
    inord = inorder;
    postord = postorder;
    int cur = postorder.size() - 1;
    return helper(0, postorder.size() - 1, cur);
  }
};
}  // namespace l106

#endif