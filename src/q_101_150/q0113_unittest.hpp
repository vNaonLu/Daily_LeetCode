
#ifndef Q113_UNITTEST_H__
#define Q113_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0113.hpp"
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 113.
  *      Path Sum II
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given the ‘root’ of a binary tree and an integer ‘targetSum’ , return
  *   “all “root-to-leaf” paths where the sum of the node values in the path
  *   equals ” ‘targetSum’ “. Each path should be returned as a list of the
  *   node “values” , not node references”.
  *   
  *   A “root-to-leaf” path is a path starting from the root and ending at
  *   any leaf node. A “leaf” is a node with no children.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • The number of nodes in the tree is in the range ‘[0, 5000]’ .
  *   • ‘-1000 ≤ Node.val ≤ 1000’
  *   • ‘-1000 ≤ targetSum ≤ 1000’
  *
*/

TEST(q113, sample_input01) {
  l113::Solution solver;
  TreeNode* root = TreeNode::generate({5, 4, 8, 11, NULL_TREENODE, 13, 4, 7, 2, NULL_TREENODE, NULL_TREENODE, NULL_TREENODE, NULL_TREENODE, 5, 1});
  int targetSum = 22;
  vector<vector<int>> exp = {{5, 4, 11, 2}, {5, 8, 4, 5}};
  EXPECT_EQ(solver.pathSum(root, targetSum), exp);
}

TEST(q113, sample_input02) {
  l113::Solution solver;
  TreeNode* root = TreeNode::generate({1, 2, 3});
  int targetSum = 5;
  vector<vector<int>> exp = {};
  EXPECT_EQ(solver.pathSum(root, targetSum), exp);
}

TEST(q113, sample_input03) {
  l113::Solution solver;
  TreeNode* root = TreeNode::generate({1, 2});
  int targetSum = 0;
  vector<vector<int>> exp = {};
  EXPECT_EQ(solver.pathSum(root, targetSum), exp);
}

#endif