
#ifndef LEETCODE_Q139_H__
#define LEETCODE_Q139_H__
#include <iostream>
#include <set>
#include <string>
#include <vector>

namespace l139 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 139.
  *      Word Break
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given a string ‘s’ and a dictionary of strings ‘wordDict’ , return
  *   ‘true’ if ‘s’ can be segmented into a space-separated sequence of one
  *   or more dictionary words.
  *   
  *   “Note” that the same word in the dictionary may be reused multiple
  *   times in the segmentation.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘1 ≤ s.length ≤ 300’
  *   • ‘1 ≤ wordDict.length ≤ 1000’
  *   • ‘1 ≤ wordDict[i].length ≤ 20’
  *   • ‘s’ and ‘wordDict[i]’ consist of only lowercase English letters.
  *   • All the strings of ‘wordDict’ are “unique” .
  *
*/

class Solution {
 public:
  bool wordBreak(string s, vector<string>& wordDict) {
    int n = s.size();
    set<string> dict;
    vector<bool> dp(n + 1, false);
    for (auto it = wordDict.begin(); it != wordDict.end(); ++it)
      dict.insert(*it);
    dp[0] = true;
    for (int i = 1; i <= s.size(); ++i) {
      for (int j = 0; j < i; ++j) {
        if (dp[j] && dict.count(s.substr(j, i - j)))
          dp[i] = true;
      }
    }
    return dp.back();
  }
};
}  // namespace l139

#endif