
#ifndef Q114_UNITTEST_H__
#define Q114_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0114.hpp"
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 114.
  *      Flatten Binary Tree to Linked List
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given the ‘root’ of a binary tree, flatten the tree into a "linked.
  *   
  *   - The "linked list" should use the same ‘TreeNode’ class where the
  *   ‘right’ child pointer points to the next node in the list and the
  *   ‘left’ child pointer is always ‘null’.
  *   
  *   - The "linked list" should be in the same order as a <a
  *   href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR"
  *   target="_blank"> “pre-order”  “ traversal” </a> of the binary tree.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • The number of nodes in the tree is in the range ‘[0, 2000]’ .
  *   • ‘-100 ≤ Node.val ≤ 100’
  *
*/

TEST(q114, sample_input01) {
  l114::Solution solver;
  TreeNode* root = TreeNode::generate({1, 2, 5, 3, 4, NULL_TREENODE, 6});
  TreeNode* exp = TreeNode::generate({1, NULL_TREENODE, 2, NULL_TREENODE, 3, NULL_TREENODE, 4, NULL_TREENODE, 5, NULL_TREENODE, 6});
  solver.flatten(root);
  // Assume the first argument is answer.
  EXPECT_TREENODE_EQ(root, exp);
}

TEST(q114, sample_input02) {
  l114::Solution solver;
  TreeNode* root = TreeNode::generate({});
  TreeNode* exp = TreeNode::generate({});
  solver.flatten(root);
  // Assume the first argument is answer.
  EXPECT_TREENODE_EQ(root, exp);
}

TEST(q114, sample_input03) {
  l114::Solution solver;
  TreeNode* root = TreeNode::generate({0});
  TreeNode* exp = TreeNode::generate({0});
  solver.flatten(root);
  // Assume the first argument is answer.
  EXPECT_TREENODE_EQ(root, exp);
}

#endif