#include <gtest/gtest.h>
#include <iostream>
#include <string>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 115.
 *      Distinct Subsequences
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given two strings ‘s’ and ‘t’ , return “the number of distinct
 *   subsequences of ‘s’ which equals ‘t’ ”
 *   A string's “subsequence” is a new string formed from the original
 *   string by deleting some (can be none) of the characters without
 *   disturbing the remaining characters' relative positions. (i.e.,
 *   ‘'ACE'’ is a subsequence of ‘'ABCDE'’ while ‘'AEC'’ is
 *   The test cases are generated so that the answer fits on a 32-bit
 *   signed integer.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ s.length, t.length ≤ 1000’
 *   • ‘s’ and ‘t’ consist of English letters.
 *
 */

struct q115 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int numDistinct(string s, string t) {
      vector<vector<unsigned long long>> dp(t.size() + 1, vector<unsigned long long>(s.size() + 1, 0));
      for (int i = 0; i <= s.size(); ++i)
        dp[0][i] = 1;
      for (int i = 1; i <= t.size(); ++i) {
        for (int j = 1; j <= s.size(); ++j) {
          dp[i][j] = dp[i][j - 1];
          if (t[i - 1] == s[j - 1])
            dp[i][j] += dp[i - 1][j - 1];
        }
      }
      return dp.back().back();
    }
  };

  class Solution *solution;
};

TEST_F(q115, sample_input01) {
  solution = new Solution();
  string s = "rabbbit";
  string t = "rabbit";
  int exp = 3;
  EXPECT_EQ(solution->numDistinct(s, t), exp);
  delete solution;
}

TEST_F(q115, sample_input02) {
  solution = new Solution();
  string s = "babgbag";
  string t = "bag";
  int exp = 5;
  EXPECT_EQ(solution->numDistinct(s, t), exp);
  delete solution;
}