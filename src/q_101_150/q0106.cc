#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 106.
 *      Construct Binary Tree from Inorder and Postorder Traversal
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given two integer arrays ‘inorder’ and ‘postorder’ where ‘inorder’ is
 *   the inorder traversal of a binary tree and ‘postorder’ is the
 *   postorder traversal of the same tree, construct and return “the binary
 *   tree” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ inorder.length ≤ 3000’
 *   • ‘postorder.length = inorder.length’
 *   • ‘-3000 ≤ inorder[i], postorder[i] ≤ 3000’
 *   • ‘inorder’ and ‘postorder’ consist of “unique” values.
 *   • Each value of ‘postorder’ also appears in ‘inorder’ .
 *   • ‘inorder’ is “guaranteed” to be the inorder traversal of the tree.
 *   • ‘postorder’ is “guaranteed” to be the postorder traversal of the tree.
 *
 */

struct q106 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    vector<int> inord, postord;
    TreeNode* helper(int l, int r, int& cur) {
      if (l > r) return nullptr;
      int i = find(inord.begin(), inord.end(), postord[cur--]) - inord.begin();
      auto right = helper(i + 1, r, cur);
      auto left = helper(l, i - 1, cur);
      return new TreeNode(inord[i], left, right);
    }
   public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
      inord = inorder;
      postord = postorder;
      int cur = postorder.size() - 1;
      return helper(0, postorder.size() - 1, cur);
    }
  };

  class Solution *solution;
};

TEST_F(q106, sample_input01) {
  solution = new Solution();
  vector<int> inorder = {9, 3, 15, 20, 7};
  vector<int> postorder = {9, 15, 7, 20, 3};
  TreeNode* exp = TreeNode::generate({3, 9, 20, NULL_TREENODE, NULL_TREENODE, 15, 7});
  EXPECT_TREENODE_EQ(solution->buildTree(inorder, postorder), exp);
  delete solution;
}

TEST_F(q106, sample_input02) {
  solution = new Solution();
  vector<int> inorder = {-1};
  vector<int> postorder = {-1};
  TreeNode* exp = TreeNode::generate({-1});
  EXPECT_TREENODE_EQ(solution->buildTree(inorder, postorder), exp);
  delete solution;
}