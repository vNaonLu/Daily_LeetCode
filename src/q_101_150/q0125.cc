#include <gtest/gtest.h>
#include <cctype>
#include <iostream>
#include <string>

using namespace std;

/**
 * The file is generated by LeetCodeDailyTools
 *
 * 125.
 *      Valid Palindrome
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   A phrase is a “palindrome” if, after converting all uppercase letters
 *   into lowercase letters and removing all non-alphanumeric characters,
 *   it reads the same forward and backward. Alphanumeric characters
 *   include letters and
 *   Given a string ‘s’ , return ‘true’ “ if it is a “palindrome” , or ”
 *   ‘false’ “ otherwise” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ s.length ≤ 2 × 10⁵’
 *   • ‘s’ consists only of printable ASCII characters.
 *
 * see more details: https://leetcode.com/problems/valid-palindrome/
 */

struct q125 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    bool isPalindrome(string s) {
      int lo = 0;
      int hi = s.size() - 1;
      while (lo < hi) {
        while (lo < s.size() && !(isalpha(s[lo]) || isdigit(s[lo]))) {
          ++lo;
        }
        while (hi >= 0 && !(isalpha(s[hi]) || isdigit(s[hi]))) {
          --hi;
        }
        if (lo < s.size() && hi >= 0) {
          if (tolower(s[lo]) != tolower(s[hi])) {
            return false;
          }
        }
        ++lo;
        --hi;
      }
      return true;
    }
  };

  class Solution *solution;
};

TEST_F(q125, sample_input01) {
  solution   = new Solution();
  string s   = "A man, a plan, a canal: Panama";
  bool   exp = true;
  bool   act = solution->isPalindrome(s);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q125, sample_input02) {
  solution   = new Solution();
  string s   = "race a car";
  bool   exp = false;
  bool   act = solution->isPalindrome(s);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q125, sample_input03) {
  solution   = new Solution();
  string s   = " ";
  bool   exp = true;
  bool   act = solution->isPalindrome(s);
  EXPECT_EQ(act, exp);
  delete solution;
}
