#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/listnode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 141.
 *      Linked List Cycle
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given ‘head’ , the head of a linked list, determine if the linked list
 *   has a cycle in
 *   There is a cycle in a linked list if there is some node in the list
 *   that can be reached again by continuously following the ‘next’
 *   pointer. Internally, ‘pos’ is used to denote the index of the node
 *   thattail's ‘next’ pointer is connected to. “Note that ‘pos’ is not
 *   passed as a parameter”
 *   Return ‘true’ “ if there is a cycle in the linked list” . Otherwise,
 *   return ‘false’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of the nodes in the list is in the range ‘[0, 10⁴]’ .
 *   • ‘-10⁵ ≤ Node.val ≤ 10⁵’
 *   • ‘pos’ is ‘-1’ or a “valid index” in the linked-list.
 *
 */

struct q141 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    bool hasCycle(ListNode *head) {
      ListNode *fast = head,
               *slow = head;
      while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
      }
      return false;
    }
  };

  class Solution *solution;
};

TEST_F(q141, sample_input01) {
  solution = new Solution();
  bool exp = true;
  EXPECT_EQ(solution->hasCycle(ListNode::generate({3, 2, 0, -4}, 1)), exp);
  delete solution;
}

TEST_F(q141, sample_input02) {
  solution = new Solution();
  bool exp = true;
  EXPECT_EQ(solution->hasCycle(ListNode::generate({1, 2}, 0)), exp);
  delete solution;
}

TEST_F(q141, sample_input03) {
  solution = new Solution();
  bool exp = false;
  EXPECT_EQ(solution->hasCycle(ListNode::generate({1})), exp);
  delete solution;
}