#include <gtest/gtest.h>
#include <iostream>
#include <stack>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 150.
 *      Evaluate Reverse Polish Notation
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Evaluate the value of an arithmetic expression in <a
 *   href="http://en.wikipedia.org/wiki/Reverse_Polish_notation"
 *   target="_blank">Reverse Polish
 *   Valid operators are ‘+’ , ‘-’ , ‘×’ , and ‘/’ . Each operand may be an
 *   integer or another
 *    “Note” that division between two integers should truncate toward
 *   It is guaranteed that the given RPN expression is always valid. That
 *   means the expression would always evaluate to a result, and there will
 *   not be any division by zero operation.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ tokens.length ≤ 10⁴’
 *   • ‘tokens[i]’ is either an operator: ‘'+'’ , ‘'-'’ , ‘'×'’ , or ‘'/'’ , or an integer in the range ‘[-200, 200]’ .
 *
 */

struct q150 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    pair<int, int> get_twice(stack<int> &s) {
      assert(s.size() >= 2);
      pair<int, int> x;
      x.second = s.top();
      s.pop();
      x.first = s.top();
      s.pop();
      return x;
    }

   public:
    int evalRPN(vector<string> &tokens) {
      stack<int> nums;

      for (auto &x : tokens) {
        if (x.size() == 1) {
          if (x[0] == '+') {
            auto [x, y] = get_twice(nums);
            nums.emplace(x + y);
            continue;
          } else if (x[0] == '-') {
            auto [x, y] = get_twice(nums);
            nums.emplace(x - y);
            continue;
          } else if (x[0] == '*') {
            auto [x, y] = get_twice(nums);
            nums.emplace(x * y);
            continue;
          } else if (x[0] == '/') {
            auto [x, y] = get_twice(nums);
            nums.emplace(x / y);
            continue;
          }
        }

        nums.emplace(stoi(x));
      }

      return nums.top();
    }
  };

  class Solution *solution;
};

TEST_F(q150, sample_input01) {
  solution = new Solution();
  vector<string> tokens = {"2", "1", "+", "3", "*"};
  int exp = 9;
  int act = solution->evalRPN(tokens);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q150, sample_input02) {
  solution = new Solution();
  vector<string> tokens = {"4", "13", "5", "/", "+"};
  int exp = 6;
  int act = solution->evalRPN(tokens);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q150, sample_input03) {
  solution = new Solution();
  vector<string> tokens = {"10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"};
  int exp = 22;
  int act = solution->evalRPN(tokens);
  EXPECT_EQ(act, exp);
  delete solution;
}