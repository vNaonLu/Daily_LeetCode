#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1443.
 *       Minimum Time to Collect All Apples in a Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an undirected tree consisting of ‘n’ vertices numbered from ‘0’
 *   to ‘n-1’ , which has some apples in their vertices. You spend 1 second
 *   to walk over one edge of the tree. “Return the minimum time in seconds
 *   you have to spend to collect all apples in the tree, starting at
 *   “vertex 0” and coming back to this vertex.”
 *   The edges of the undirected tree are given in the array ‘edges’ ,
 *   where ‘edges[i] = [aᵢ, bᵢ]’ means that exists an edge connecting the
 *   vertices ‘aᵢ’ and ‘bᵢ’ . Additionally, there is a boolean array
 *   ‘hasApple’ , where ‘hasApple[i] = true’ means that vertex ‘i’ has an
 *   apple; otherwise, it does not have any apple.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n ≤ 10⁵’
 *   • ‘edges.length = n - 1’
 *   • ‘edges[i].length = 2’
 *   • ‘0 ≤ aᵢ < bᵢ ≤ n - 1’
 *   • ‘fromᵢ < toᵢ’
 *   • ‘hasApple.length = n’
 *
 */

struct q1443 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    int dfs(int node, int parent, vector<vector<int>> &tree,
            vector<bool> &has_apple) {
      int time = 0;
      for (auto x : tree[node]) {
        if (x != parent) {
          time += dfs(x, node, tree, has_apple);
        }
      }
      return (time > 0 || has_apple[node] ? time + 2 : 0);
    }

  public:
    int minTime(int n, vector<vector<int>> &edges, vector<bool> &hasApple) {
      vector<vector<int>> tree(n + 1);
      for (auto &x : edges) {
        tree[x[1]].emplace_back(x[0]);
        tree[x[0]].emplace_back(x[1]);
      }
      return max(0, dfs(0, -1, tree, hasApple) - 2);
    }
  };

  class Solution *solution;
};

TEST_F(q1443, sample_input01) {
  solution                  = new Solution();
  int                 n     = 7;
  vector<vector<int>> edges = {
      {0, 1},
      {0, 2},
      {1, 4},
      {1, 5},
      {2, 3},
      {2, 6}
  };
  vector<bool> hasApple = {false, false, true, false, true, true, false};
  int          exp      = 8;
  int          act      = solution->minTime(n, edges, hasApple);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1443, sample_input02) {
  solution                  = new Solution();
  int                 n     = 7;
  vector<vector<int>> edges = {
      {0, 1},
      {0, 2},
      {1, 4},
      {1, 5},
      {2, 3},
      {2, 6}
  };
  vector<bool> hasApple = {false, false, true, false, true, false};
  int          exp      = 6;
  int          act      = solution->minTime(n, edges, hasApple);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1443, sample_input03) {
  solution                  = new Solution();
  int                 n     = 7;
  vector<vector<int>> edges = {
      {0, 1},
      {0, 2},
      {1, 4},
      {1, 5},
      {2, 3},
      {2, 6}
  };
  vector<bool> hasApple = {false, false, false, false, false, false, false};
  int          exp      = 0;
  int          act      = solution->minTime(n, edges, hasApple);
  EXPECT_EQ(act, exp);
  delete solution;
}
