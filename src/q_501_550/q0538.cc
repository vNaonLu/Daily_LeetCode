#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 538.
 *      Convert BST to Greater Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a Binary Search Tree (BST), convert it to a
 *   Greater Tree such that every key of the original BST is changed to the
 *   original key plus the sum of all keys greater than the original key in
 *   As a reminder, a “binary search tree” is a tree that satisfies these
 *       - The left subtree of a node contains only nodes with keys “less
 *   than” the node's
 *       - The right subtree of a node contains only nodes with keys
 *   “greater than” the node's
 *       - Both the left and right subtrees must also be binary search
 *   trees.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[0, 10⁴]’ .
 *   • ‘-10⁴ ≤ Node.val ≤ 10⁴’
 *   • All the values in the tree are “unique” .
 *   • ‘root’ is guaranteed to be a valid binary search tree.
 *
 */

struct q538 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    int helper(TreeNode* p, int curr) {
      if (nullptr == p) {
        
        return curr;
      } else {
        p->val += helper(p->right, curr);

        return helper(p->left, p->val);
      }
    }

   public:
    TreeNode* convertBST(TreeNode* root) {
      helper(root, 0);

      return root;
    }
  };
  class Solution *solution;
};

TEST_F(q538, sample_input01) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({4, 1, 6, 0, 2, 5, 7, NULL_TREENODE, NULL_TREENODE, NULL_TREENODE, 3, NULL_TREENODE, NULL_TREENODE, NULL_TREENODE, 8});
  TreeNode* exp = TreeNode::generate({30, 36, 21, 36, 35, 26, 15, NULL_TREENODE, NULL_TREENODE, NULL_TREENODE, 33, NULL_TREENODE, NULL_TREENODE, NULL_TREENODE, 8});
  TreeNode* act = solution->convertBST(root);
  EXPECT_TREENODE_EQ(act, exp);
  TreeNode::release(root, exp, act);
  delete solution;
}

TEST_F(q538, sample_input02) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({0, NULL_TREENODE, 1});
  TreeNode* exp = TreeNode::generate({1, NULL_TREENODE, 1});
  TreeNode* act = solution->convertBST(root);
  EXPECT_TREENODE_EQ(act, exp);
  TreeNode::release(root, exp, act);
  delete solution;
}