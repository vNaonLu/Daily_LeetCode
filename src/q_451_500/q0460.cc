#include <gtest/gtest.h>
#include <iostream>
#include <list>
#include <unordered_map>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 460.
 *      LFU Cache
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Design and implement a data structure for a <a
 *   href="https://en.wikipedia.org/wiki/Least_frequently_used"
 *   target="_blank">Least Frequently Used (LFU)</a>
 *   Implement the ‘LFUCache’
 *       -  ‘LFUCache(int capacity)’ Initializes the object with the
 *   ‘capacity’ of the data
 *       -  ‘int get(int key)’ Gets the value of the ‘key’ if the ‘key’
 *   exists in the cache. Otherwise, returns ‘-1’
 *       -  ‘void put(int key, int value)’ Update the value of the ‘key’ if
 *   present, or inserts the ‘key’ if not already present. When the cache
 *   reaches its ‘capacity’ , it should invalidate and remove the “least
 *   frequently used” key before inserting a new item. For this problem,
 *   when there is a “tie” (i.e., two or more keys with the same
 *   frequency), the “least recently used” ‘key’ would be
 *   To determine the least frequently used key, a “use counter” is
 *   maintained for each key in the cache. The key with the smallest “use
 *   counter” is the least frequently used
 *   When a key is first inserted into the cache, its “use counter” is set
 *   to ‘1’ (due to the ‘put’ operation). The “use counter” for a key in
 *   the cache is incremented either a ‘get’ or ‘put’ operation is called
 *   on
 *   The functions<code data-stringify-type="code">get</code>and<code
 *   data-stringify-type="code">put</code>must each run in ‘O(1)’ average
 *   time complexity.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘0 ≤ capacity≤ 10⁴’
 *   • ‘0 ≤ key ≤ 10⁵’
 *   • ‘0 ≤ value ≤ 10⁹’
 *   • At most ‘2 × 10⁵’ calls will be made to ‘get’ and ‘put’ .
 *
 */

struct q460 : public ::testing::Test {
  // Leetcode answer here
  class LFUCache {
  private:
    int                                     cap;
    int                                     min_freq;
    unordered_map<int, pair<int, int>>      key_val;
    unordered_map<int, list<int>>           freq_list;
    unordered_map<int, list<int>::iterator> pos;

    unordered_map<int, pair<int, int>>::iterator access(int key) {
      auto iter = key_val.find(key);
      if (iter == key_val.end()) {
        return iter;
      }
      freq_list[iter->second.second].erase(pos[key]);
      ++iter->second.second;
      freq_list[iter->second.second].emplace_back(key);
      pos[key] = --freq_list[iter->second.second].end();
      if (freq_list[min_freq].empty()) {
        ++min_freq;
      }
      return iter;
    }

  public:
    LFUCache(int capacity) : cap{capacity}, min_freq{0} {}

    int get(int key) {
      auto iter = access(key);
      return iter == key_val.end() ? -1 : iter->second.first;
    }

    void put(int key, int value) {
      if (!cap) {
        return;
      }
      auto iter = access(key);
      if (iter != key_val.end()) {
        iter->second.first = value;
      } else {
        if (key_val.size() == cap) {
          int del = freq_list[min_freq].front();
          key_val.erase(del);
          pos.erase(del);
          freq_list[min_freq].pop_front();
        }
        key_val[key] = {value, 1};
        freq_list[1].emplace_back(key);
        pos[key] = --freq_list[1].end();
        min_freq = 1;
      }
    }
  };

  class LFUCache *lfu_cache;
};

TEST_F(q460, sample_input01) {
  int capacity = 2;
  lfu_cache    = new LFUCache(capacity);
  lfu_cache->put(1, 1);
  lfu_cache->put(2, 2);
  EXPECT_EQ(lfu_cache->get(1), 1);
  lfu_cache->put(3, 3);
  EXPECT_EQ(lfu_cache->get(2), -1);
  EXPECT_EQ(lfu_cache->get(3), 3);
  lfu_cache->put(4, 4);
  EXPECT_EQ(lfu_cache->get(1), -1);
  EXPECT_EQ(lfu_cache->get(3), 3);
  EXPECT_EQ(lfu_cache->get(4), 4);
  delete lfu_cache;
}
