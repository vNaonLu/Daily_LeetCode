#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 474.
 *      Ones and Zeroes
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given an array of binary strings ‘strs’ and two integers ‘m’
 *   and ‘n’
 *   Return “the size of the largest subset of ‘strs’ such that there are
 *   “at most” ” ‘m’ “ ” ‘0’ “'s and ” ‘n’ “ ” ‘1’ “'s in the subset”
 *   A set ‘x’ is a “subset” of a set ‘y’ if all elements of ‘x’ are also
 *   elements of ‘y’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ strs.length ≤ 600’
 *   • ‘1 ≤ strs[i].length ≤ 100’
 *   • ‘strs[i]’ consists only of digits ‘'0'’ and ‘'1'’ .
 *   • ‘1 ≤ m, n ≤ 100’
 *
 */

struct q474 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int findMaxForm(vector<string> &strs, int m, int n) {
      vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

      for (auto &s : strs) {
        int zero = count(s.begin(), s.end(), '0'),
            one = s.size();

        for (int i = m; i >= zero; --i) {
          for (int j = n; j >= (one - zero); --j) {
            dp[i][j] = max(dp[i][j], 1 + dp[i - zero][j - (one - zero)]);
          }
        }
      }

      return dp.back().back();
    }
  };

  class Solution *solution;
};

TEST_F(q474, sample_input01) {
  solution = new Solution();
  vector<string> strs = {"10", "0001", "111001", "1", "0"};
  int m = 5;
  int n = 3;
  int exp = 4;
  int act = solution->findMaxForm(strs, m, n);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q474, sample_input02) {
  solution = new Solution();
  vector<string> strs = {"10", "0", "1"};
  int m = 1;
  int n = 1;
  int exp = 2;
  int act = solution->findMaxForm(strs, m, n);
  EXPECT_EQ(act, exp);
  delete solution;
}