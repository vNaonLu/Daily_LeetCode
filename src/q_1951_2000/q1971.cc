#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1971.
 *       Find if Path Exists in Graph
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   There is a “bi-directional” graph with ‘n’ vertices, where each vertex
 *   is labeled from ‘0’ to ‘n - 1’ ( “inclusive” ). The edges in the graph
 *   are represented as a 2D integer array ‘edges’ , where each ‘edges[i] =
 *   [uᵢ, vᵢ]’ denotes a bi-directional edge between vertex ‘uᵢ’ and vertex
 *   ‘vᵢ’ . Every vertex pair is connected by “at most one” edge, and no
 *   vertex has an edge to
 *   You want to determine if there is a “valid path” that exists from
 *   vertex ‘source’ to vertex ‘destination’
 *   Given ‘edges’ and the integers ‘n’ , ‘source’ , and ‘destination’ ,
 *   return ‘true’ “ if there is a “valid path” from ” ‘source’ “ to ”
 *   ‘destination’ “, or ” ‘false’ “ otherwise”  “.”
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n ≤ 2 × 10⁵’
 *   • ‘0 ≤ edges.length ≤ 2 × 10⁵’
 *   • ‘edges[i].length = 2’
 *   • ‘0 ≤ uᵢ, vᵢ ≤ n - 1’
 *   • ‘uᵢ ≠ vᵢ’
 *   • ‘0 ≤ source, destination ≤ n - 1’
 *   • There are no duplicate edges.
 *   • There are no self edges.
 *
 */

struct q1971 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    bool validPath(int n, vector<vector<int>> &edges, int source,
                   int destination) {
      auto graph   = vector<unordered_set<int>>(n);
      auto path    = queue<int>();
      auto visited = unordered_set<int>();
      for (auto &e : edges) {
        graph[e[0]].emplace(e[1]);
        graph[e[1]].emplace(e[0]);
      }
      path.emplace(source);
      visited.emplace(source);
      while (!path.empty()) {
        auto x = path.front();
        path.pop();

        if (x == destination) {
          return true;
        }

        for (auto next : graph[x]) {
          if (visited.emplace(next).second) {
            path.emplace(next);
          }
        }
      }
      return false;
    }
  };

  class Solution *solution;
};

TEST_F(q1971, sample_input01) {
  solution                  = new Solution();
  int                 n     = 3;
  vector<vector<int>> edges = {
      {0, 1},
      {1, 2},
      {2, 0}
  };
  int  source      = 0;
  int  destination = 2;
  bool exp         = true;
  bool act         = solution->validPath(n, edges, source, destination);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1971, sample_input02) {
  solution                  = new Solution();
  int                 n     = 6;
  vector<vector<int>> edges = {
      {0, 1},
      {0, 2},
      {3, 5},
      {5, 4},
      {4, 3}
  };
  int  source      = 0;
  int  destination = 5;
  bool exp         = false;
  bool act         = solution->validPath(n, edges, source, destination);
  EXPECT_EQ(act, exp);
  delete solution;
}
