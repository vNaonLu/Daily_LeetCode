
#ifndef Q1361_UNITTEST_H__
#define Q1361_UNITTEST_H__
#include <gtest/gtest.h>

#include "q1361.hpp"
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1361.
 *       Validate Binary Tree Nodes
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You have ‘n’ binary tree nodes numbered from ‘0’ to ‘n - 1’ where node
 *   ‘i’ has two children ‘leftChild[i]’ and ‘rightChild[i]’ , return
 *   ‘true’ if and only if “all” the given nodes form “exactly one” valid
 *   binary
 *   If node ‘i’ has no left child then ‘leftChild[i]’ will equal ‘-1’ ,
 *   similarly for the right
 *   Note that the nodes have no values and that we only use the node
 *   numbers in this problem.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n ≤ 10⁴’
 *   • ‘leftChild.length = rightChild.length = n’
 *   • ‘-1 ≤ leftChild[i], rightChild[i] ≤ n - 1’
 *
 */

TEST(q1361, sample_input01) {
  l1361::Solution solver;
  int n = 4;
  vector<int> leftChild = {1, -1, 3, -1};
  vector<int> rightChild = {2, -1, -1, -1};
  bool exp = true;
  EXPECT_EQ(solver.validateBinaryTreeNodes(n, leftChild, rightChild), exp);
}

TEST(q1361, sample_input02) {
  l1361::Solution solver;
  int n = 4;
  vector<int> leftChild = {1, -1, 3, -1};
  vector<int> rightChild = {2, 3, -1, -1};
  bool exp = false;
  EXPECT_EQ(solver.validateBinaryTreeNodes(n, leftChild, rightChild), exp);
}

TEST(q1361, sample_input03) {
  l1361::Solution solver;
  int n = 2;
  vector<int> leftChild = {1, 0};
  vector<int> rightChild = {-1, -1};
  bool exp = false;
  EXPECT_EQ(solver.validateBinaryTreeNodes(n, leftChild, rightChild), exp);
}

TEST(q1361, sample_input04) {
  l1361::Solution solver;
  int n = 6;
  vector<int> leftChild = {1, -1, -1, 4, -1, -1};
  vector<int> rightChild = {2, -1, -1, 5, -1, -1};
  bool exp = false;
  EXPECT_EQ(solver.validateBinaryTreeNodes(n, leftChild, rightChild), exp);
}

#endif