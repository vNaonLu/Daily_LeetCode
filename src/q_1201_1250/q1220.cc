#include <gtest/gtest.h>
#include <iostream>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1220.
 *       Count Vowels Permutation
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an integer ‘n’ , your task is to count how many strings of
 *   length ‘n’ can be formed under the following
 *       - Each character is a lower case vowel( ‘'a'’ , ‘'e'’ , ‘'i'’ ,
 *   ‘'o'’ , ‘'u'’
 *       - Each vowel ‘'a'’ may only be followed by an ‘'e'’
 *       - Each vowel ‘'e'’ may only be followed by an ‘'a'’ or an ‘'i'’
 *       - Each vowel ‘'i'’ “may not” be followed by another ‘'i'’
 *       - Each vowel ‘'o'’ may only be followed by an ‘'i'’ or a ‘'u'’
 *       - Each vowel ‘'u'’ may only be followed by an ‘'a'.’
 *   Since the answermay be too large,return it modulo ‘10^9 + 7.’
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n ≤ 2 × 10^4’
 *
 */

struct q1220 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    inline constexpr static int kMod = 1e9 + 7;
    int solve(int prev, int count, int n, vector<vector<int>> &dp) {
      if (count == n) {
        return 1;
      }

      if (dp[count][prev] == -1) {
        int res = 0;
        for (int i = 1; i <= 5; ++i) {
          if (prev == 1 && i == 2) {
            res = (res + solve(i, count + 1, n, dp)) % kMod;
          } else if (prev == 2 && (i == 1 || i == 3)) {
            res = (res + solve(i, count + 1, n, dp)) % kMod;
          } else if (prev == 3 && i != 3) {
            res = (res + solve(i, count + 1, n, dp)) % kMod;
          } else if (prev == 4 && (i == 3 || i == 5)) {
            res = (res + solve(i, count + 1, n, dp)) % kMod;
          } else if (prev == 5 && (i == 1)) {
            res = (res + solve(i, count + 1, n, dp)) % kMod;
          }
        }
        dp[count][prev] = res;
      }

      return dp[count][prev] %= kMod;
    }

  public:
    int countVowelPermutation(int n) {
      auto res = 0;
      auto dp = vector<vector<int>>(n + 1, vector<int>(6, -1));
      for (int i = 1; i <= 5; ++i) {
        res += solve(i, 1, n, dp);
        res %= kMod;
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1220, sample_input01) {
  solution = new Solution();
  int n = 1;
  int exp = 5;
  int act = solution->countVowelPermutation(n);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1220, sample_input02) {
  solution = new Solution();
  int n = 2;
  int exp = 10;
  int act = solution->countVowelPermutation(n);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1220, sample_input03) {
  solution = new Solution();
  int n = 5;
  int exp = 68;
  int act = solution->countVowelPermutation(n);
  EXPECT_EQ(act, exp);
  delete solution;
}