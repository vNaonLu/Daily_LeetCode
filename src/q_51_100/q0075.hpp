
#ifndef LEETCODE_Q75_H__
#define LEETCODE_Q75_H__
#include <iostream>
#include <limits>
#include <vector>

namespace l75 {
using namespace std;

/**
  * this file is generated by gquestion.py
  *
  * 75. Sort Colors
  *
  * Given an array nums with n objects colored red,
  * white, or blue, sort them “<a
  * href="https://en.wikipedia.org/wiki/In-place_algorithm"
  * target="_blank">in-place</a>“ so that objects of the same color
  * are adjacent, with the colors in the order red,
  * white, and blue.
  * We will use the integers 0 , 1 , and 2 to
  * represent the color red, white, and blue, respectively.
  * You must solve this problem without using the
  * library';s sort function.
  *
  * Constraints:
  * -  n == nums.length 
  * -  1 <= n <= 300 
  * -  nums[i] is 0 , 1 , or 2 .
  *  “Follow up:“ Could you come up with a one-pass algorithm using onlyconstant extra space?
  *
*/
class Solution {
 private:
  void mergeSort(vector<int> &nums, int beg, int end) {
    if (end > beg) {
      int mid = beg + (end - beg) / 2;
      mergeSort(nums, beg, mid);
      mergeSort(nums, mid + 1, end);
      merge(nums, beg, mid, end);
    }
  }
  void merge(vector<int> &nums, int beg, int mid, int end) {
    vector<int> lhs(nums.begin() + beg, nums.begin() + mid + 1),
        rhs(nums.begin() + mid + 1, nums.begin() + end + 1);

    lhs.push_back(numeric_limits<int>::max());
    rhs.push_back(numeric_limits<int>::max());

    int li = 0, ri = 0;

    for (auto it = nums.begin() + beg; it != nums.begin() + end + 1; ++it) {
      if (lhs[li] > rhs[ri]) {
        *it = rhs[ri++];
      } else {
        *it = lhs[li++];
      }
    }
  }

 public:
  void sortColors(vector<int> &nums) {
    mergeSort(nums, 0, nums.size() - 1);
  }
};
}  // namespace l75
#endif