
#ifndef LEETCODE_Q63_H__
#define LEETCODE_Q63_H__
#include <iostream>
#include <vector>

namespace l63 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 63.
 *     Unique Paths II
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   A robot is located at the top-left corner of a ‘m x n’ grid (marked
 *   'Start' in the diagram
 *   The robot can only move either down or right at any point in time. The
 *   robot is trying to reach the bottom-right corner of the grid (marked
 *   'Finish' in the diagram
 *   Now consider if some obstacles are added to the grids. How many unique
 *   paths would there
 *   An obstacle and space is marked as ‘1’ and ‘0’ respectively in the
 *   grid.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘m =obstacleGrid.length’
 *   • ‘n =obstacleGrid[i].length’
 *   • ‘1 ≤ m, n ≤ 100’
 *   • ‘obstacleGrid[i][j]’ is ‘0’ or ‘1’ .
 *
 */

class Solution {
 public:
  int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
    int m = obstacleGrid.size(),
        n = obstacleGrid[0].size();
    vector<vector<int>> dp(m, vector<int>(n, 0));
    dp[0][0] = obstacleGrid[0][0] == 1 ? 0 : 1;
    for (int i = 1; i < m; ++i) dp[i][0] = obstacleGrid[i][0] == 1 ? 0 : dp[i - 1][0];
    for (int j = 1; j < n; ++j) dp[0][j] = obstacleGrid[0][j] == 1 ? 0 : dp[0][j - 1];

    for (int i = 1; i < m; ++i) {
      for (int j = 1; j < n; ++j) {
        if (obstacleGrid[i][j] == 1) {
          dp[i][j] = 0;
        } else {
          dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
      }
    }

    return dp.back().back();
  }
};
}  // namespace l63

#endif