
#ifndef LEETCODE_Q91_H__
#define LEETCODE_Q91_H__
#include <iostream>
#include <string>
#include <vector>

namespace l91 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 91.
  *     Decode Ways
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   A message containing letters from ‘A-Z’ can be “encoded” into numbers
  *   using the following.
  *   
  *   'A' ->.
  *   
  *   'B' ->.
  *   
  *   ...
  *   
  *   'Z' ->.
  *   
  *   To “decode” an encoded message, all the digits must be grouped then
  *   mapped back into letters using the reverse of the mapping above (there
  *   may be multiple ways). For example, ‘"11106"’ can be mapped.
  *   
  *   - ‘"AAJF"’ with the grouping ‘(1 1 10 6)’.
  *   
  *   - ‘"KJF"’ with the grouping ‘(11 10 6)’.
  *   
  *   Note that the grouping ‘(1 11 06)’ is invalid because ‘"06"’ cannot be
  *   mapped into ‘'F'’ since ‘"6"’ is different from ‘"06"’.
  *   
  *   Given a string ‘s’ containing only digits, return “the “number” of
  *   ways to “decode” it”.
  *   
  *   The answer is guaranteed to fit in a “32-bit” integer.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘1 ≤ s.length ≤ 100’
  *   • ‘s’ contains only digits and may contain leading zero(s).
  *
*/

class Solution {
 public:
  int numDecodings(string s) {
    vector<int> dp(s.size() + 1, 0);
    dp[0] = 1;
    dp[1] = s[0] == '0' ? 0 : 1;
    for (int i = 2; i <= s.size(); ++i){
      dp[i] = s[i - 1] == '0' ? 0 : dp[i - 1];
      if(s[i-2] == '1' || (s[i-2] == '2' && s[i-1] <= '6'))
        dp[i] += dp[i - 2];
    }
    return dp.back();
  }
};
}  // namespace l91

#endif