
#ifndef Q93_UNITTEST_H__
#define Q93_UNITTEST_H__
#include <gtest/gtest.h>

#include <leetcode/anyorder.hpp>

#include "q0093.hpp"
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 93.
  *     Restore IP Addresses
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given a string ‘s’ containing only digits, return all possible valid
  *   IP addresses that can be obtained from ‘s’ . You can return them in
  *   “any” order.
  *   
  *   A “valid IP address” consists of exactly four integers, each integer
  *   is between ‘0’ and ‘255’ , separated by single dots and cannot have
  *   leading zeros. For example, "0.1.2.201" and "192.168.1.1" are “valid”
  *   IP addresses and "0.011.255.245", "192.168.1.312" and "192.168@1.1"
  *   are “invalid” IP addresses.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘0 ≤ s.length ≤ 3000’
  *   • ‘s’ consists of digits only.
  *
*/

TEST(q93, sample_input01) {
  l93::Solution solver;
  string s = "25525511135";
  vector<string> exp = {"255.255.11.135", "255.255.111.35"};
  EXPECT_EQ_ANY_ORDER(solver.restoreIpAddresses(s), exp);
}

TEST(q93, sample_input02) {
  l93::Solution solver;
  string s = "0000";
  vector<string> exp = {"0.0.0.0"};
  EXPECT_EQ_ANY_ORDER(solver.restoreIpAddresses(s), exp);
}

TEST(q93, sample_input03) {
  l93::Solution solver;
  string s = "1111";
  vector<string> exp = {"1.1.1.1"};
  EXPECT_EQ_ANY_ORDER(solver.restoreIpAddresses(s), exp);
}

TEST(q93, sample_input04) {
  l93::Solution solver;
  string s = "010010";
  vector<string> exp = {"0.10.0.10", "0.100.1.0"};
  EXPECT_EQ_ANY_ORDER(solver.restoreIpAddresses(s), exp);
}

TEST(q93, sample_input05) {
  l93::Solution solver;
  string s = "101023";
  vector<string> exp = {"1.0.10.23", "1.0.102.3", "10.1.0.23", "10.10.2.3", "101.0.2.3"};
  EXPECT_EQ_ANY_ORDER(solver.restoreIpAddresses(s), exp);
}

#endif