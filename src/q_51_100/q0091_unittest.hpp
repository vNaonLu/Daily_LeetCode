
#ifndef Q91_UNITTEST_H__
#define Q91_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0091.hpp"
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 91.
  *     Decode Ways
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   A message containing letters from ‘A-Z’ can be “encoded” into numbers
  *   using the following.
  *   
  *   'A' ->.
  *   
  *   'B' ->.
  *   
  *   ...
  *   
  *   'Z' ->.
  *   
  *   To “decode” an encoded message, all the digits must be grouped then
  *   mapped back into letters using the reverse of the mapping above (there
  *   may be multiple ways). For example, ‘"11106"’ can be mapped.
  *   
  *   - ‘"AAJF"’ with the grouping ‘(1 1 10 6)’.
  *   
  *   - ‘"KJF"’ with the grouping ‘(11 10 6)’.
  *   
  *   Note that the grouping ‘(1 11 06)’ is invalid because ‘"06"’ cannot be
  *   mapped into ‘'F'’ since ‘"6"’ is different from ‘"06"’.
  *   
  *   Given a string ‘s’ containing only digits, return “the “number” of
  *   ways to “decode” it”.
  *   
  *   The answer is guaranteed to fit in a “32-bit” integer.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘1 ≤ s.length ≤ 100’
  *   • ‘s’ contains only digits and may contain leading zero(s).
  *
*/

TEST(q91, sample_input01) {
  l91::Solution solver;
  string s = "12";
  int exp = 2;
  EXPECT_EQ(solver.numDecodings(s), exp);
}

TEST(q91, sample_input02) {
  l91::Solution solver;
  string s = "226";
  int exp = 3;
  EXPECT_EQ(solver.numDecodings(s), exp);
}

TEST(q91, sample_input03) {
  l91::Solution solver;
  string s = "0";
  int exp = 0;
  EXPECT_EQ(solver.numDecodings(s), exp);
}

TEST(q91, sample_input04) {
  l91::Solution solver;
  string s = "06";
  int exp = 0;
  EXPECT_EQ(solver.numDecodings(s), exp);
}

#endif