#include <array>
#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <string_view>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 76.
 *     Minimum Window Substring
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given two strings ‘s’ and ‘t’ of lengths ‘m’ and ‘n’ respectively,
 *   return “the “minimum window substring” of ” ‘s’ “ such that every
 *   character in ” ‘t’ “ ( “including duplicates” ) is included in the
 *   window. If there is no such substring”  “, return the empty string ”
 *   ‘''’ “.”
 *   The testcases will be generated such that the answer is “unique”
 *   A “substring” is a contiguous sequence of characters within the string
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘m = s.length’
 *   • ‘n = t.length’
 *   • ‘1 ≤ m, n≤ 10⁵’
 *   • ‘s’ and ‘t’ consist of uppercase and lowercase English letters.
 *
 */

struct q76 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    template <typename Iterator>
    array<int, 128> count(Iterator beg, Iterator end) {
      auto res = array<int, 128>();
      while (beg != end) {
        ++res[*beg++];
      }
      return res;
    }

  public:
    string minWindow(string s, string t) {
      auto sv     = string_view(s);
      auto target = count(t.begin(), t.end());
      auto left   = s.begin();
      auto beg    = s.begin();
      auto res    = string_view(""); /// be aware of the unmatched condition
      auto curr   = (int)0;
      while (beg != s.end()) {
        if (--target[*beg] >= 0) {
          ++curr;
        }

        while (curr == t.size()) {
          if (res.size() > distance(left, beg) + 1 || res.empty()) {
            res = string_view(&(*left), distance(left, beg) + 1);
          }
          if (++target[*left++] > 0) {
            --curr;
          }
        }
        ++beg;
      }
      return string(res.begin(), res.end());
    }
  };

  class Solution *solution;
};

TEST_F(q76, sample_input01) {
  solution   = new Solution();
  string s   = "ADOBECODEBANC";
  string t   = "ABC";
  string exp = "BANC";
  string act = solution->minWindow(s, t);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q76, sample_input02) {
  solution   = new Solution();
  string s   = "a";
  string t   = "a";
  string exp = "a";
  string act = solution->minWindow(s, t);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q76, sample_input03) {
  solution   = new Solution();
  string s   = "a";
  string t   = "aa";
  string exp = "";
  string act = solution->minWindow(s, t);
  EXPECT_EQ(act, exp);
  delete solution;
}