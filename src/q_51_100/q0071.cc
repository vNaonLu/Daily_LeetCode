#include <gtest/gtest.h>
#include <iostream>
#include <stack>
#include <string>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 71.
 *     Simplify Path
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a string ‘path’ , which is an “absolute path” (starting with a
 *   slash ‘'/'’ ) to a file or directory in a Unix-style file system,
 *   convert it to the simplified “canonical path”
 *   In a Unix-style file system, a period ‘'.'’ refers to the current
 *   directory, a double period ‘'..'’ refers to the directory up a level,
 *   and any multiple consecutive slashes (i.e. ‘'//'’ ) are treated as a
 *   single slash ‘'/'’ . For this problem, any other format of periods
 *   such as ‘'...'’ are treated as file/directory
 *   The “canonical path” should have the following
 *       - The path starts with a single slash ‘'/'’
 *       - Any two directories are separated by a single slash ‘'/'’
 *       - The path does not end with a trailing ‘'/'’
 *       - The path only contains the directories on the path from the root
 *   directory to the target file or directory (i.e., no period ‘'.'’ or
 *   double period ‘'..'’
 *   Return “the simplified “canonical path” ” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ path.length ≤ 3000’
 *   • ‘path’ consists of English letters, digits, period ‘'.'’ , slash ‘'/'’ or ‘'_'’ .
 *   • ‘path’ is a valid absolute Unix path.
 *
 */

struct q71 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    string join(stack<string> &stk) {
      stack<string> p;
      while (!stk.empty()) {
        p.emplace(move(stk.top()));
        stk.pop();
      }

      string res;
      while (!p.empty()) {
        res += "/";
        res += p.top();
        p.pop();
      }

      return res.empty() ? "/" : res;
    }

    void push(stack<string> &s, string &curr) {
      if (curr == "..") {
        if (!s.empty()) {
          s.pop();
        }
      } else if (curr != "." && !curr.empty()) {
        s.emplace(move(curr));
      }
      curr.clear();
    }

   public:
    string simplifyPath(string path) {
      stack<string> pathes;
      string        curr;

      for (auto it = path.begin(); it != path.end(); ++it) {
        if (*it == '/') {
          push(pathes, curr);
        } else {
          curr.push_back(*it);
        }
      }
      push(pathes, curr);

      return join(pathes);
    }
  };

  class Solution *solution;
};

TEST_F(q71, sample_input01) {
  solution = new Solution();
  string path = "/home/";
  string exp = "/home";
  string act = solution->simplifyPath(path);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q71, sample_input02) {
  solution = new Solution();
  string path = "/../";
  string exp = "/";
  string act = solution->simplifyPath(path);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q71, sample_input03) {
  solution = new Solution();
  string path = "/home//foo/";
  string exp = "/home/foo";
  string act = solution->simplifyPath(path);
  EXPECT_EQ(act, exp);
  delete solution;
}