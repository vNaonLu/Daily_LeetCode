
#ifndef LEETCODE_Q72_H__
#define LEETCODE_Q72_H__
#include <iostream>
#include <string>
#include <vector>

namespace l72 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 72.
  *     Edit Distance
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given two strings ‘word1’ and ‘word2’ , return “the minimum number of
  *   operations required to convert ‘word1’ to ‘word2’ ”.
  *   
  *   You have the following three operations permitted on a.
  *   
  *   - Insert a.
  *   
  *   - Delete a.
  *   
  *   - Replace a.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘0 ≤ word1.length, word2.length ≤ 500’
  *   • ‘word1’ and ‘word2’ consist of lowercase English letters.
  *
*/

class Solution {
 public:
  int minDistance(string word1, string word2) {
    int m = word1.size() + 1, n = word2.size() + 1;
    vector<vector<int>> dp(m, vector<int>(n, m + n));
    for (int i = 0; i < m; ++i) dp[i][0] = i;
    for (int j = 1; j < n; ++j) dp[0][j] = j;

    for (int i = 1; i < m; ++i) {
      for (int j = 1; j < n; ++j) {
        if(word1[i-1] == word2[j-1]){
          dp[i][j] = dp[i - 1][j - 1];
        }else{
          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]);
          dp[i][j] = min(dp[i][j], dp[i][j-1]);
          ++dp[i][j];
        }
      }
    }

    return dp.back().back();
  }
};
}  // namespace l72

#endif