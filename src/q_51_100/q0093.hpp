
#ifndef LEETCODE_Q93_H__
#define LEETCODE_Q93_H__
#include <iostream>
#include <string>
#include <vector>

namespace l93 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 93.
  *     Restore IP Addresses
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given a string ‘s’ containing only digits, return all possible valid
  *   IP addresses that can be obtained from ‘s’ . You can return them in
  *   “any” order.
  *   
  *   A “valid IP address” consists of exactly four integers, each integer
  *   is between ‘0’ and ‘255’ , separated by single dots and cannot have
  *   leading zeros. For example, "0.1.2.201" and "192.168.1.1" are “valid”
  *   IP addresses and "0.011.255.245", "192.168.1.312" and "192.168@1.1"
  *   are “invalid” IP addresses.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘0 ≤ s.length ≤ 3000’
  *   • ‘s’ consists of digits only.
  *
*/

class Solution {
 private:
  bool valid_ip(const string &s) {
    int num = 0;
    for (const auto &c : s) num = num * 10 + (c - '0');
    if (num != 0 && s[0] == '0') return false;
    if (num == 0 && s.size() > 1) return false;
    return num >= 0 && num <= 255;
  }
  void helper(const string &s, string ip, vector<string> &r, int ip_cnt = 0, int beg = 0) {
    if (ip_cnt == 4 && beg == s.size()) {
      r.push_back(ip);
    } else if (ip_cnt < 4) {
      for (int i = 1; i < 4 && beg + i <= s.size(); ++i) {
        string current = s.substr(beg, i);
        if (valid_ip(current)) {
          if (ip_cnt == 0) {
            helper(s, current, r, ip_cnt + 1, beg + i);
          } else {
            helper(s, ip + "." + current, r, ip_cnt + 1, beg + i);
          }
        }
      }
    }
  }

 public:
  vector<string> restoreIpAddresses(string s) {
    vector<string> res;
    if (s.size() > 12) return res;
    helper(s, "", res);
    return res;
  }
};
}  // namespace l93

#endif