#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 88.
 *     Merge Sorted Array
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given two integer arrays ‘nums1’ and ‘nums2’ , sorted in
 *   “non-decreasing order” , and two integers ‘m’ and ‘n’ , representing
 *   the number of elements in ‘nums1’ and ‘nums2’
 *    “Merge” ‘nums1’ and ‘nums2’ into a single array sorted in
 *   “non-decreasing order”
 *   The final sorted array should not be returned by the function, but
 *   instead be “stored inside the array ” ‘nums1’ . To accommodate this,
 *   ‘nums1’ has a length of ‘m + n’ , where the first ‘m’ elements denote
 *   the elements that should be merged, and the last ‘n’ elements are set
 *   to ‘0’ and should be ignored. ‘nums2’ has a length of ‘n’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘nums1.length = m + n’
 *   • ‘nums2.length = n’
 *   • ‘0 ≤ m, n ≤ 200’
 *   • ‘1 ≤ m + n ≤ 200’
 *   • ‘-10⁹ ≤ nums1[i], nums2[j] ≤ 10⁹’
 *
 */

struct q88 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
      int i = -1;
      int i1 = 0, i2 = 0;
      vector<int> n1(nums1.begin(), nums1.begin() + m);
      while (i1 < m && i2 < n) {
        if (n1[i1] <= nums2[i2]) {
          nums1[++i] = n1[i1++];
        } else {
          nums1[++i] = nums2[i2++];
        }
      }
      while (i1 < m) {
        nums1[++i] = n1[i1++];
      }
      while (i2 < n) {
        nums1[++i] = nums2[i2++];
      }
    }
  };

  class Solution *solution;
};

TEST_F(q88, sample_input01) {
  solution = new Solution();
  vector<int> nums1 = {1, 2, 3, 0, 0, 0};
  int m = 3;
  vector<int> nums2 = {2, 5, 6};
  int n = 3;
  vector<int> exp = {1, 2, 2, 3, 5, 6};
  solution->merge(nums1, m, nums2, n);
  // Assume the first argument is answer.
  EXPECT_EQ(nums1, exp);
  delete solution;
}

TEST_F(q88, sample_input02) {
  solution = new Solution();
  vector<int> nums1 = {1};
  int m = 1;
  vector<int> nums2 = {};
  int n = 0;
  vector<int> exp = {1};
  solution->merge(nums1, m, nums2, n);
  // Assume the first argument is answer.
  EXPECT_EQ(nums1, exp);
  delete solution;
}

TEST_F(q88, sample_input03) {
  solution = new Solution();
  vector<int> nums1 = {0};
  int m = 0;
  vector<int> nums2 = {1};
  int n = 1;
  vector<int> exp = {1};
  solution->merge(nums1, m, nums2, n);
  // Assume the first argument is answer.
  EXPECT_EQ(nums1, exp);
  delete solution;
}