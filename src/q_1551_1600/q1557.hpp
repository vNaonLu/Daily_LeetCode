
#ifndef LEETCODE_Q1557_H__
#define LEETCODE_Q1557_H__
#include <iostream>
#include <unordered_set>
#include <vector>

namespace l1557 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 1557.
  *       Minimum Number of Vertices to Reach All Nodes
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given a “directed acyclic graph” ,with ‘n’ vertices numbered from ‘0’
  *   to ‘n-1’ ,and an array ‘edges’ where ‘edges[i] = [fromᵢ, toᵢ]’
  *   represents a directed edge from node ‘fromᵢ’ to node ‘toᵢ’.
  *   
  *   Find “the smallest set of vertices from which all nodes in the graph
  *   are reachable” . It's guaranteed that a unique solution exists.
  *   
  *   Notice that you can return the vertices in any order.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘2 ≤ n ≤ 10^5’
  *   • ‘1 ≤ edges.length ≤ min(10^5, n × (n - 1) / 2)’
  *   • ‘edges[i].length = 2’
  *   • ‘0 ≤ from⎽(i,)toᵢ < n’
  *   • All pairs ‘(fromᵢ, toᵢ)’ are distinct.
  *
*/

class Solution {
 public:
  vector<int> findSmallestSetOfVertices(int n, vector<vector<int>>& edges) {
    unordered_set<int> reachable;
    for (const auto& e : edges)
      reachable.insert(e[1]);
    vector<int> res;
    for (int i = 0; i < n; ++i)
      if (!reachable.count(i))
        res.push_back(i);
    return res;
  }
};
}  // namespace l1557

#endif