#include <gtest/gtest.h>
#include <iostream>
#include <stack>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 430.
 *      Flatten a Multilevel Doubly Linked List
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given a doubly linked list, which contains nodes that have a
 *   next pointer, a previous pointer, and an additional “child pointer” .
 *   This child pointer may or may not point to a separate doubly linked
 *   list, also containing these special nodes. These child lists may have
 *   one or more children of their own, and so on, to produce a “multilevel
 *   data structure” as shown in the example
 *   Given the ‘head’ of the first level of the list, “flatten” the list so
 *   that all the nodes appear in a single-level, doubly linked list. Let
 *   ‘curr’ be a node with a child list. The nodes in the child list should
 *   appear “after” ‘curr’ and “before” ‘curr.next’ in the flattened
 *   Return “the ” ‘head’ “ of the flattened list. The nodes in the list
 *   must have “all” of their child pointers set to ” ‘null’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of Nodes will not exceed ‘1000’ .
 *   • ‘1 ≤ Node.val ≤ 10⁵’
 *
 */

struct q430 : public ::testing::Test {
  // Leetcode answer here
  class Node {
   public:
    int val;
    Node* prev;
    Node* next;
    Node* child;
  };
  class Solution {
   public:
    Node* flatten(Node* head) {
      if (head == nullptr) return nullptr;
      Node dummy{0, nullptr, nullptr, nullptr};
      Node* p = &dummy;
      stack<Node*> path;
      path.push(head);
      while (!path.empty()) {
        auto node = path.top();
        path.pop();
        if (node->next != nullptr)
          path.push(node->next);
        if (node->child != nullptr)
          path.push(node->child);
        p->next = node;
        if (p != &dummy) {
          node->prev = p;
        } else {
          node->prev = nullptr;
        }
        node->child = nullptr;
        p = p->next;
      }
      return dummy.next;
    }
  };

  class Solution *solution;
};

TEST_F(q430, NOT_IMPLEMENT) {
   EXPECT_TRUE("NOT IMPLEMENT");
}