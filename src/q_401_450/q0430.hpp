
#ifndef LEETCODE_Q430_H__
#define LEETCODE_Q430_H__
#include <iostream>
#include <stack>

namespace l430 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 430.
 *      Flatten a Multilevel Doubly Linked List
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given a doubly linked list which in addition to the next and
 *   previous pointers, it could have a child pointer, which may or may not
 *   point to a separate doubly linked list. These child lists may have one
 *   or more children of their own, and so on, to produce a multilevel data
 *   structure, as shown in the example
 *   Flatten the list so that all the nodes appear in a single-level,
 *   doubly linked list. You are given the head of the first level of the
 *   list.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of Nodes will not exceed ‘1000’ .
 *   • ‘1 ≤ Node.val ≤ 10⁵’
 *
 */

// Definition for a Node.
class Node {
 public:
  int val;
  Node* prev;
  Node* next;
  Node* child;
};

class Solution {
 public:
  Node* flatten(Node* head) {
    if (head == nullptr) return nullptr;
    Node dummy{0, nullptr, nullptr, nullptr};
    Node* p = &dummy;
    stack<Node*> path;
    path.push(head);
    while (!path.empty()) {
      auto node = path.top();
      path.pop();
      if (node->next != nullptr)
        path.push(node->next);
      if (node->child != nullptr)
        path.push(node->child);

      p->next = node;
      if (p != &dummy) {
        node->prev = p;
      } else {
        node->prev = nullptr;
      }
      node->child = nullptr;
      p = p->next;
    }
    return dummy.next;
  }
};
}  // namespace l430

#endif