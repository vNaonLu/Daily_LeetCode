#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/anyorder.hpp>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 417.
 *      Pacific Atlantic Water Flow
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   There is an ‘m x n’ rectangular island that borders both the “Pacific
 *   Ocean” and “Atlantic Ocean” . The “Pacific Ocean” touches the island's
 *   left and top edges, and the “Atlantic Ocean” touches the island's
 *   right and bottom
 *   The island is partitioned into a grid of square cells. You are given
 *   an ‘m x n’ integer matrix ‘heights’ where ‘heights[r][c]’ represents
 *   the “height above sea level” of the cell at coordinate ‘(r, c)’
 *   The island receives a lot of rain, and the rain water can flow to
 *   neighboring cells directly north, south, east, and west if the
 *   neighboring cell's height is “less than or equal to” the current
 *   cell's height. Water can flow from any cell adjacent to an ocean into
 *   the
 *   Return “a “2D list” of grid coordinates ” ‘result’ “ where ”
 *   ‘result[i] = [rᵢ, cᵢ]’ “ denotes that rain water can flow from cell ”
 *   ‘(rᵢ, cᵢ)’ “ to “both” the Pacific and Atlantic oceans” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘m = heights.length’
 *   • ‘n = heights[r].length’
 *   • ‘1 ≤ m, n ≤ 200’
 *   • ‘0 ≤ heights[r][c] ≤ 10⁵’
 *
 */

struct q417 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    int                 m, n;
    vector<vector<int>> terrain;

    inline void helper(int i, int j, unordered_set<int> &ocean,
                       int prev_alt = numeric_limits<int>::min()) {
      int  pos = i * n + j;
      auto it  = ocean.find(pos);
      if (i < 0 || i >= m || j < 0 || j >= n)
        return;

      int curr = terrain[i][j];
      if (curr < prev_alt || it != ocean.end())
        return;

      ocean.insert(pos);
      helper(i + 1, j, ocean, curr);
      helper(i - 1, j, ocean, curr);
      helper(i, j + 1, ocean, curr);
      helper(i, j - 1, ocean, curr);
    }

  public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>> &heights) {
      m       = heights.size();
      n       = heights[0].size();
      terrain = move(heights);
      unordered_set<int> pacific, atlantic;
      for (int i = 0; i < max(m, n); ++i) {
        helper(i, 0, pacific);
        helper(0, i, pacific);
      }
      for (int i = 0; i < max(m, n); ++i) {
        helper(i, n - 1, atlantic);
        helper(m - 1, i, atlantic);
      }

      vector<vector<int>> res;
      heights = move(terrain);
      for (auto it = pacific.begin(); it != pacific.end(); ++it) {
        if (atlantic.count(*it)) {
          res.emplace_back(vector<int>{*it / n, *it % n});
        }
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q417, sample_input01) {
  solution                    = new Solution();
  vector<vector<int>> heights = {
      {1, 2, 2, 3, 5},
      {3, 2, 3, 4, 4},
      {2, 4, 5, 3, 1},
      {6, 7, 1, 4, 5},
      {5, 1, 1, 2, 4}
  };
  vector<vector<int>> exp = {
      {0, 4},
      {1, 3},
      {1, 4},
      {2, 2},
      {3, 0},
      {3, 1},
      {4, 0}
  };
  vector<vector<int>> act = solution->pacificAtlantic(heights);
  EXPECT_EQ_ANY_ORDER(act, exp);
  delete solution;
}

TEST_F(q417, sample_input02) {
  solution                    = new Solution();
  vector<vector<int>> heights = {
      {2, 1},
      {1, 2}
  };
  vector<vector<int>> exp = {
      {0, 0},
      {0, 1},
      {1, 0},
      {1, 1}
  };
  vector<vector<int>> act = solution->pacificAtlantic(heights);
  EXPECT_EQ_ANY_ORDER(act, exp);
  delete solution;
}