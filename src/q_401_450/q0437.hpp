
#ifndef LEETCODE_Q437_H__
#define LEETCODE_Q437_H__
#include <iostream>
#include <leetcode/treenode.hpp>

namespace l437 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 437.
 *      Path Sum III
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary tree and an integer ‘targetSum’ , return
 *   “the number of paths where the sum of the valuesalong the path equals”
 *    ‘targetSum’
 *   The path does not need to start or end at the root or a leaf, but it
 *   must go downwards (i.e., traveling only from parent nodes to child
 *   nodes).
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[0, 1000]’ .
 *   • ‘-10⁹ ≤ Node.val ≤ 10⁹’
 *   • ‘-1000 ≤ targetSum ≤ 1000’
 *
 */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
 private:
  int helper(const TreeNode* const p, int target, int sum = 0) {
    if (p == nullptr) return 0;
    sum += p->val;
    return helper(p->left, target, sum) +
           helper(p->right, target, sum) +
           (sum == target ? 1 : 0);
  }

 public:
  int pathSum(TreeNode* root, int targetSum) {
    if (root == nullptr) return 0;
    return helper(root, targetSum) +
           pathSum(root->left, targetSum) +
           pathSum(root->right, targetSum);
  }
};
}  // namespace l437

#endif