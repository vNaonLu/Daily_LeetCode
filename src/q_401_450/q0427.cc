#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * The file is generated by LeetCodeDailyTools
 *
 * 427.
 *      Construct Quad Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a ‘n × n’ matrix ‘grid’ of ‘0's’ and ‘1's’ only. We want to
 *   represent the ‘grid’ with a
 *   Return “the root of the Quad-Tree” representing the ‘grid’
 *   Notice that you can assign the value of a node to “True” or “False”
 *   when ‘isLeaf’ is “False” , and both are “accepted” in the
 *   A Quad-Tree is a tree data structure in which each internal node has
 *   exactly four children. Besides, each node has two
 *       -  ‘val’ : True if the node represents a grid of 1's or False if
 *   the node represents a grid of
 *       -  ‘isLeaf’ : True if the node is leaf node on the tree or False
 *   if the node has the four
 *   class Node
 *       public boolean
 *       public boolean
 *       public Node
 *       public Node
 *       public Node
 *       public Node
 *   We can construct a Quad-Tree from a two-dimensional area using the
 *   following
 *       1. If the current grid has the same value (i.e all ‘1's’ or all
 *   ‘0's’ ) set ‘isLeaf’ True and set ‘val’ to the value of the grid and
 *   set the four children to Null and
 *       2. If the current grid has different values, set ‘isLeaf’ to False
 *   and set ‘val’ to any value and divide the current grid into four
 *   sub-grids as shown in the
 *       3. Recurse for each of the children with the proper
 *   If you want to know more about the Quad-Tree, you can refer to the <a
 *    “Quad-Tree format:”
 *   The output represents the serialized format of a Quad-Tree using level
 *   order traversal, where ‘null’ signifies a path terminator where no
 *   node exists
 *   It is very similar to the serialization of the binary tree. The only
 *   difference is that the node is represented as a list ‘[isLeaf, val]’
 *   If the value of ‘isLeaf’ or ‘val’ is True we represent it as “1” in
 *   the list ‘[isLeaf, val]’ and if the value of ‘isLeaf’ or ‘val’ is
 *   False we represent it as “0” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = grid.length = grid[i].length’
 *   • ‘n = 2ˣ’ where ‘0 ≤ x ≤ 6’
 *
 * see more details: https://leetcode.com/problems/construct-quad-tree/
 */

struct q427 : public ::testing::Test {
  // Leetcode answer here
  class Node {
  public:
    bool  val;
    bool  isLeaf;
    Node *topLeft;
    Node *topRight;
    Node *bottomLeft;
    Node *bottomRight;

    Node() {
      val         = false;
      isLeaf      = false;
      topLeft     = NULL;
      topRight    = NULL;
      bottomLeft  = NULL;
      bottomRight = NULL;
    }

    Node(bool _val, bool _isLeaf) {
      val         = _val;
      isLeaf      = _isLeaf;
      topLeft     = NULL;
      topRight    = NULL;
      bottomLeft  = NULL;
      bottomRight = NULL;
    }

    Node(bool _val, bool _isLeaf, Node *_topLeft, Node *_topRight,
         Node *_bottomLeft, Node *_bottomRight) {
      val         = _val;
      isLeaf      = _isLeaf;
      topLeft     = _topLeft;
      topRight    = _topRight;
      bottomLeft  = _bottomLeft;
      bottomRight = _bottomRight;
    }
  };

  class Solution {
  private:
    Node *construct(vector<vector<int>> &grid, pair<int, int> row,
                    pair<int, int> col) {
      Node *res               = new Node();
      auto [row_beg, row_end] = row;
      auto [col_beg, col_end] = col;
      auto val                = grid[row_beg][col_beg];
      bool value_not_unique   = false;
      for (int i = row_beg; i < row_end && !value_not_unique; ++i) {
        for (int j = col_beg; j < col_end; ++j) {
          if (val != grid[i][j]) {
            value_not_unique = true;
            break;
          }
        }
      }
      if (value_not_unique) {
        auto  row_mid      = row_beg + (row_end - row_beg) / 2;
        auto  col_mid      = col_beg + (col_end - col_beg) / 2;
        auto *top_left     = construct(grid, make_pair(row_beg, row_mid),
                                       make_pair(col_beg, col_mid));
        auto *top_right    = construct(grid, make_pair(row_beg, row_mid),
                                       make_pair(col_mid, col_end));
        auto *bottom_left  = construct(grid, make_pair(row_mid, row_end),
                                       make_pair(col_beg, col_mid));
        auto *bottom_right = construct(grid, make_pair(row_mid, row_end),
                                       make_pair(col_mid, col_end));
        res->topLeft       = top_left;
        res->topRight      = top_right;
        res->bottomLeft    = bottom_left;
        res->bottomRight   = bottom_right;
        res->isLeaf        = false;
        res->val           = top_left->val | top_right->val | bottom_left->val |
                   bottom_right->val;
      } else {
        res->val    = val;
        res->isLeaf = true;
      }
      return res;
    }

  public:
    Node *construct(vector<vector<int>> &grid) {
      return construct(grid, make_pair(0, grid.size()),
                       make_pair(0, grid.size()));
    }
  };

  class Solution *solution;
};

TEST_F(q427, NOT_IMPLEMENT) { EXPECT_TRUE("NOT IMPLEMENT"); }
