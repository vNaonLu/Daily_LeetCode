#include <gtest/gtest.h>
#include <iostream>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1146.
 *       Snapshot Array
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Implement a SnapshotArray that supports the following
 *       -  ‘SnapshotArray(int length)’ initializes an array-like data
 *   structure with the given length. “Initially, each element equals 0”
 *       -  ‘void set(index, val)’ sets the element at the given ‘index’ to
 *   be equal to ‘val’
 *       -  ‘int snap()’ takes a snapshot of the array and returns the
 *   ‘snap_id’ : the total number of times we called ‘snap()’ minus ‘1’
 *       -  ‘int get(index, snap_id)’ returns the value at the given
 *   ‘index’ , at the time we took the snapshot with the given ‘snap_id’ 
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ length≤ 50000’
 *   • At most ‘50000’ calls will be made to ‘set’ , ‘snap’ , and ‘get’ .
 *   • ‘0 ≤ index<length’
 *   • ‘0 ≤snap_id <’ (the total number of times we call ‘snap()’ )
 *   • ‘0 ≤val ≤ 10^9’
 *
 */

struct q1146 : public ::testing::Test {
  // Leetcode answer here
class SnapshotArray {
private:
    int snap_idx = 0;
    vector<map<int, int>> data;
public:
    SnapshotArray(int length) : data(length, {{0,0}}), snap_idx{0} {
    }
    
    void set(int index, int val) {
        data[index][snap_idx] = val;
    }
    
    int snap() {
        return snap_idx++;
    }
    
    int get(int index, int snap_id) {
        return (--data[index].upper_bound(snap_id))->second;
    }
};

  class SnapshotArray *snapshot_array;
};

TEST_F(q1146, sample_input01) {
  int length = 3;
  snapshot_array = new SnapshotArray(length);
  snapshot_array->set(0, 5);
  EXPECT_EQ(snapshot_array->snap(), 0);
  snapshot_array->set(0, 6);
  EXPECT_EQ(snapshot_array->get(0, 0), 5);
  delete snapshot_array;
}