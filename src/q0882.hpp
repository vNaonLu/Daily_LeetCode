
#ifndef LEETCODE_Q882_H__
#define LEETCODE_Q882_H__
#include <iostream>
#include <limits>
#include <queue>
#include <unordered_map>
#include <vector>

namespace l882 {
using namespace std;

/**
  * this file is generated by gquestion.py
  *
  * 882. Reachable Nodes In Subdivided Graph
  *
  * You are given an undirected graph (the “"original
  * graph"“ ) with n nodes labeled from 0 to n - 1 .
  * You decide to “subdivide“ each edge in the graph
  * into a chain of nodes, with the number of new nodes
  * varying between each edge.
  * The graph is given as a 2D array of edges where
  * edges[i] = [u⎽(i), v⎽(i), cnt⎽(i)] indicates that
  * there is an edge between nodes u⎽(i) and v⎽(i) in
  * the original graph, and cnt⎽(i) is the total number
  * of new nodes that you will “subdivide“ the edge
  * into. Note that cnt⎽(i) == 0 means you will not
  * subdivide the edge.
  * To “subdivide“ the edge [u⎽(i), v⎽(i)] , replace
  * it with (cnt⎽(i) + 1) new edges and cnt⎽(i) new
  * nodes. The new nodes are x⎽(1) , x⎽(2) , ...,
  * x⎽(cnt⎽(i)) , and the new edges are [u⎽(i), x⎽(1)] ,
  * [x⎽(1), x⎽(2)] , [x⎽(2), x⎽(3)] , ...,
  * [x⎽(cnt⎽(i)+1), x⎽(cnt⎽(i))] , [x⎽(cnt⎽(i)), v⎽(i)] .
  * In this “new graph“ , you want to know how many
  * nodes are “reachable“ from the node 0 , where a
  * node is “reachable“ if the distance is maxMoves or
  * less.
  * Given the original graph and maxMoves , return
  * the number of nodes that are “reachable“ from node 0
  * in the new graph .
  *
  * Constraints:
  * -  0 <= edges.length <= min(n * (n - 1) / 2, 10^(4)) 
  * -  edges[i].length == 3 
  * -  0 <= u⎽(i) < v⎽(i) < n 
  * - There are “no multiple edges“ in the graph.
  * -  0 <= cnt⎽(i) <= 10^(4) 
  * -  0 <= maxMoves <= 10^(9) 
  * -  1 <= n <= 3000 
  *
*/
class Solution {
 public:
  int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {
    vector<int> dist(n, numeric_limits<int>::max());
    unordered_map<int, unordered_map<int, int>> g;
    for (auto& e : edges) g[e[0]][e[1]] = g[e[1]][e[0]] = e[2] + 1;
    auto cmp = [](const pair<int, int>& a, const pair<int, int>& b) { return a.second > b.second; };

    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);
    pq.push({0, 0});
    dist[0] = 0;
    while (!pq.empty()) {
      auto u = pq.top().first;
      pq.pop();
      if (dist[u] >= maxMoves) break;
      for (auto n_w : g[u]) {
        int v = n_w.first, w = n_w.second;
        if (dist[u] + w < dist[v]) {
          dist[v] = w + dist[u];
          pq.push({v, dist[v]});
        }
      }
    }

    int res = 0;
    for (int i = 0; i < n; i++)
      if (dist[i] <= maxMoves) res++;
    for (auto& e : edges) {
      int a = dist[e[0]] >= maxMoves ? 0 : min(maxMoves - dist[e[0]], e[2]);
      int b = dist[e[1]] >= maxMoves ? 0 : min(maxMoves - dist[e[1]], e[2]);
      res += min(a + b, e[2]);
    }
    return res;
  }
};
}  // namespace l882
#endif