#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/listnode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 328.
 *      Odd Even Linked List
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘head’ of a singly linked list, group all the nodes with odd
 *   indices together followed by the nodes with even indices, and return
 *   “the reordered list”
 *   The “first” node is considered “odd” , and the “second” node is “even”
 *   , and so
 *   Note that the relative order inside both the even and odd groups
 *   should remain as it was in the
 *   You must solve the problemin ‘O(1)’ extra space complexity and ‘O(n)’
 *   time complexity.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n =’ number of nodes in the linked list
 *   • ‘0 ≤ n ≤ 10⁴’
 *   • ‘-10⁶ ≤ Node.val ≤ 10⁶’
 *
 */

struct q328 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    ListNode* oddEvenList(ListNode* head) {
      if (head == nullptr) return nullptr;
      ListNode *odd = head,
               *even = head->next,
               *even_head = even;
      while (even != nullptr && even->next != nullptr) {
        odd->next = even->next;
        odd = odd->next;
        even->next = odd->next;
        even = even->next;
      }
      odd->next = even_head;
      return head;
    }
  };

  class Solution *solution;
};

TEST_F(q328, sample_input01) {
  solution = new Solution();
  ListNode* head = ListNode::generate({1, 2, 3, 4, 5});
  ListNode* exp = ListNode::generate({1, 3, 5, 2, 4});
  EXPECT_LISTNODE_EQ(solution->oddEvenList(head), exp);
  delete solution;
}

TEST_F(q328, sample_input02) {
  solution = new Solution();
  ListNode* head = ListNode::generate({2, 1, 3, 5, 6, 4, 7});
  ListNode* exp = ListNode::generate({2, 3, 6, 7, 1, 5, 4});
  EXPECT_LISTNODE_EQ(solution->oddEvenList(head), exp);
  delete solution;
}