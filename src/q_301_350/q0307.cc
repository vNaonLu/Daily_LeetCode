#include <gtest/gtest.h>
#include <iostream>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 307.
 *      Range Sum Query - Mutable
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an integer array ‘nums’ , handle multiple queries of the
 *   following
 *       1.  “Update” the value of an element in ‘nums’
 *       2. Calculate the “sum” of the elements of ‘nums’ between indices
 *   ‘left’ and ‘right’ “inclusive” where ‘left ≤ right’
 *   Implement the ‘NumArray’
 *       -  ‘NumArray(int[] nums)’ Initializes the object with the integer
 *   array ‘nums’
 *       -  ‘void update(int index, int val)’ “Updates” the value of
 *   ‘nums[index]’ to be ‘val’
 *       -  ‘int sumRange(int left, int right)’ Returns the “sum” of the
 *   elements of ‘nums’ between indices ‘left’ and ‘right’ “inclusive”
 *   (i.e. ‘nums[left] + nums[left + 1] + ... + nums[right]’ ).
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ nums.length ≤ 3 × 10⁴’
 *   • ‘-100 ≤ nums[i] ≤ 100’
 *   • ‘0 ≤ index < nums.length’
 *   • ‘-100 ≤ val ≤ 100’
 *   • ‘0 ≤ left ≤ right < nums.length’
 *   • At most ‘3 × 10⁴’ calls will be made to ‘update’ and ‘sumRange’ .
 *
 */

struct q307 : public ::testing::Test {
  // Leetcode answer here
  class NumArray {
  private:
    size_t n = 0;
    vector<int> tree;

    static vector<int> buildTree(vector<int> &nums) {
      vector<int> res(nums.size() * 2);
      for (int i = nums.size(), j = 0; i < 2 * nums.size(); ++i, ++j) {
        res[i] = nums[j];
      }

      for (int i = nums.size() - 1; i > 0; --i) {
        res[i] = res[i * 2 + 1] + res[i * 2];
      }

      return res;
    }

  public:
    NumArray(vector<int> &nums) : n{nums.size()}, tree{buildTree(nums)} {
    }

    void update(int index, int val) {
      index += n;
      tree[index] = val;

      while (index > 0) {
        int left = index;
        int right = index;
        if (index & 1) {
          left = index - 1;
        } else {
          right = index + 1;
        }

        tree[index / 2] = tree[left] + tree[right];
        index /= 2;
      }
    }

    int sumRange(int left, int right) {
      int lo = left + n;
      int hi = right + n;
      int res = 0;
      while (lo <= hi) {
        if (lo & 1) {
          res += tree[lo++];
        }
        if (!(hi & 1)) {
          res += tree[hi--];
        }

        lo /= 2;
        hi /= 2;
      }

      return res;
    }
  };

  /**
   * Your NumArray object will be instantiated and called as such:
   * NumArray* obj = new NumArray(nums);
   * obj->update(index,val);
   * int param_2 = obj->sumRange(left,right);
   */

  class NumArray *num_array;
};

TEST_F(q307, sample_input01) {
  vector<int> nums = {1, 3, 5};
  num_array = new NumArray(nums);
  EXPECT_EQ(num_array->sumRange(0, 2), 9);
  num_array->update(1, 2);
  EXPECT_EQ(num_array->sumRange(0, 2), 8);
  delete num_array;
}