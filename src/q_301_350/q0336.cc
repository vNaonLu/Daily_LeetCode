#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 336.
 *      Palindrome Pairs
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a list of “unique” words, return all the pairs of the
 *   “<i>distinct</i>” indices ‘(i, j)’ in the given list, so that the
 *   concatenation of the two words ‘words[i] + words[j]’ is a palindrome.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ words.length ≤ 5000’
 *   • ‘0 ≤ words[i].length ≤ 300’
 *   • ‘words[i]’ consists of lower-case English letters.
 *
 */

struct q336 : public ::testing::Test {
  // Leetcode answer here
  struct TrieNode {
    TrieNode   *next[26] = {};
    int         index    = -1;
    vector<int> palindromeIndexes;
  };

  class Solution {
    TrieNode root;
    void     add(string &s, int i) {
          auto node = &root;
          for (int j = s.size() - 1; j >= 0; --j) {
            if (isPalindrome(s, 0, j))
          node->palindromeIndexes.push_back(i);
        int c = s[j] - 'a';
            if (!node->next[c])
          node->next[c] = new TrieNode();
        node = node->next[c];
      }
          node->index = i;
          node->palindromeIndexes.push_back(i);
    }

    bool isPalindrome(string &s, int i, int j) {
      while (i < j && s[i] == s[j])
        ++i, --j;
      return i >= j;
    }

  public:
    vector<vector<int>> palindromePairs(vector<string> &A) {
      int N = A.size();
      for (int i = 0; i < N; ++i)
        add(A[i], i);
      vector<vector<int>> ans;
      for (int i = 0; i < N; ++i) {
        auto s    = A[i];
        auto node = &root;
        for (int j = 0; j < s.size() && node; ++j) {
          if (node->index != -1 && node->index != i &&
              isPalindrome(s, j, s.size() - 1))
            ans.push_back({i, node->index});
          node = node->next[s[j] - 'a'];
        }
        if (!node)
          continue;
        for (int j : node->palindromeIndexes) {
          if (i != j)
            ans.push_back({i, j});
        }
      }
      return ans;
    }
  };

  class Solution *solution;
};

TEST_F(q336, sample_input01) {
  solution                  = new Solution();
  vector<string>      words = {"abcd", "dcba", "lls", "s", "sssll"};
  vector<vector<int>> exp   = {
        {0, 1},
        {1, 0},
        {2, 4},
        {3, 2}
  };
  vector<vector<int>> act = solution->palindromePairs(words);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q336, sample_input02) {
  solution                  = new Solution();
  vector<string>      words = {"bat", "tab", "cat"};
  vector<vector<int>> exp   = {
        {0, 1},
        {1, 0}
  };
  vector<vector<int>> act = solution->palindromePairs(words);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q336, sample_input03) {
  solution                  = new Solution();
  vector<string>      words = {"a", ""};
  vector<vector<int>> exp   = {
        {0, 1},
        {1, 0}
  };
  vector<vector<int>> act = solution->palindromePairs(words);
  EXPECT_EQ(act, exp);
  delete solution;
}