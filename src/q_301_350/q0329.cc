#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 329.
 *      Longest Increasing Path in a Matrix
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an ‘m x n’ integers ‘matrix’ , return “the length of the longest
 *   increasing path in ” ‘matrix’
 *   From each cell, you can either move in four directions: left, right,
 *   up, or down. You “may not” move “diagonally” or move “outside the
 *   boundary” (i.e., wrap-around is not allowed).
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘m = matrix.length’
 *   • ‘n = matrix[i].length’
 *   • ‘1 ≤ m, n ≤ 200’
 *   • ‘0 ≤ matrix[i][j] ≤ 2³¹ - 1’
 *
 */

struct q329 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    int m, n;

    bool valid(int x, int y) {
      return x >= 0 && x < m && y >= 0 && y < n;
    }

    int helper(vector<vector<int>> &mat, vector<vector<int>> &dp, int x, int y) {
      if (!valid(x, y)) return 0;

      if (dp[x][y] != -1) return dp[x][y];

      int l1 = 0, l2 = 0, l3 = 0, l4 = 0;

      if (valid(x + 1, y) && mat[x + 1][y] > mat[x][y]) {
        l1 = helper(mat, dp, x + 1, y);
      }
      if (valid(x, y + 1) && mat[x][y + 1] > mat[x][y]) {
        l2 = helper(mat, dp, x, y + 1);
      }
      if (valid(x - 1, y) && mat[x - 1][y] > mat[x][y]) {
        l3 = helper(mat, dp, x - 1, y);
      }
      if (valid(x, y - 1) && mat[x][y - 1] > mat[x][y]) {
        l4 = helper(mat, dp, x, y - 1);
      }

      return dp[x][y] = 1 + max({l1, l2, l3, l4});
    }

   public:
    int longestIncreasingPath(vector<vector<int>> &matrix) {
      m = matrix.size();
      n = matrix.front().size();
      vector<vector<int>> dp(m, vector<int>(n, -1));
      int res = 0;

      for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
          if (dp[i][j] == -1) {
            res = max(res, helper(matrix, dp, i, j));
          }
        }
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q329, sample_input01) {
  solution = new Solution();
  vector<vector<int>> matrix = {{9, 9, 4}, {6, 6, 8}, {2, 1, 1}};
  int exp = 4;
  int act = solution->longestIncreasingPath(matrix);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q329, sample_input02) {
  solution = new Solution();
  vector<vector<int>> matrix = {{3, 4, 5}, {3, 2, 6}, {2, 2, 1}};
  int exp = 4;
  int act = solution->longestIncreasingPath(matrix);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q329, sample_input03) {
  solution = new Solution();
  vector<vector<int>> matrix = {{1}};
  int exp = 1;
  int act = solution->longestIncreasingPath(matrix);
  EXPECT_EQ(act, exp);
  delete solution;
}