#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/anyorder.hpp>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 350.
 *      Intersection of Two Arrays II
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given two integer arrays ‘nums1’ and ‘nums2’ , return “an array of
 *   their intersection” . Each element in the result must appear as many
 *   times as it shows in both arrays and you may return the result in “any
 *   order” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ nums1.length, nums2.length ≤ 1000’
 *   • ‘0 ≤ nums1[i], nums2[i] ≤ 1000’
 *   • What if the given array is already sorted? How would you optimize your algorithm?
 *   • What if ‘nums1’ 's size is small compared to ‘nums2’ 's size? Which algorithm is better?
 *   • What if elements of ‘nums2’ are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?
 *
 */

struct q350 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
      sort(nums1.begin(), nums1.end());
      sort(nums2.begin(), nums2.end());
      vector<int> res;
      res.reserve(min(nums1.size(), nums2.size()));
      while (!nums1.empty() && !nums2.empty()) {
        if (nums1.back() == nums2.back()) {
          res.push_back(nums1.back());
          nums1.pop_back();
          nums2.pop_back();
        } else if (nums1.back() > nums2.back()) {
          nums1.pop_back();
        } else {
          nums2.pop_back();
        }
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q350, sample_input01) {
  solution = new Solution();
  vector<int> nums1 = {1, 2, 2, 1};
  vector<int> nums2 = {2, 2};
  vector<int> exp = {2, 2};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->intersect(nums1, nums2), exp);
  delete solution;
}

TEST_F(q350, sample_input02) {
  solution = new Solution();
  vector<int> nums1 = {4, 9, 5};
  vector<int> nums2 = {9, 4, 9, 8, 4};
  vector<int> exp = {4, 9};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->intersect(nums1, nums2), exp);
  delete solution;
}