#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 338.
 *      Counting Bits
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an integer ‘n’ , return “an array ” ‘ans’ “ of length ” ‘n + 1’
 *   “ such that for each ” ‘i’ “ ” ( ‘0 ≤ i ≤ n’ ) “, ” ‘ans[i]’ “ is the
 *   “number of ” ” ‘1’ “ “'s” in the binary representation of ” ‘i’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘0 ≤ n ≤ 10⁵’
 *   • It is very easy to come up with a solution with a runtime of ‘O(n log n)’ . Can you do it in linear time ‘O(n)’ and possibly in a single pass?
 *   • Can you do it without using any built-in function (i.e., like ‘__builtin_popcount’ in C++)?
 *
 */

struct q338 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    vector<int> countBits(int n) {
      vector<int> res(n + 1, 0);
      for (int i = 1; i<=n; ++i){
        int tmp = i;
        while(tmp != 0){
          tmp &= tmp - 1;
          ++res[i];
        }
      }
        return res;
    }
  };

  class Solution *solution;
};

TEST_F(q338, sample_input01) {
  solution = new Solution();
  int n = 2;
  vector<int> exp = {0, 1, 1};
  EXPECT_EQ(solution->countBits(n), exp);
  delete solution;
}

TEST_F(q338, sample_input02) {
  solution = new Solution();
  int n = 5;
  vector<int> exp = {0, 1, 1, 2, 1, 2};
  EXPECT_EQ(solution->countBits(n), exp);
  delete solution;
}