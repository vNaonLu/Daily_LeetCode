
#ifndef LEETCODE_Q338_H__
#define LEETCODE_Q338_H__
#include <iostream>
#include <vector>

namespace l338 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 338.
  *      Counting Bits
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given an integer ‘n’ , return “an array ” ‘ans’ “ of length ” ‘n + 1’
  *   “ such that for each ” ‘i’ “ ” ( ‘0 ≤ i ≤ n’ ) “, ” ‘ans[i]’ “ is the
  *   “number of ” ” ‘1’ “ “&#39;s” in the binary representation of ” ‘i’.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘0 ≤ n ≤ 10⁵’
  *   • It is very easy to come up with a solution with a runtime of ‘O(n log n)’ . Can you do it in linear time ‘O(n)’ and possibly in a single pass?
  *   • Can you do it without using any built-in function (i.e., like ‘__builtin_popcount’ in C++)?
  *
*/

class Solution {
 public:
  vector<int> countBits(int n) {
    vector<int> res(n + 1, 0);
    for (int i = 1; i<=n; ++i){
      int tmp = i;
      while(tmp != 0){
        tmp &= tmp - 1;
        ++res[i];
      }
    }
      return res;
  }
};
}  // namespace l338

#endif