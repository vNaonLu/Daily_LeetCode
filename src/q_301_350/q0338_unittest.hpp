
#ifndef Q338_UNITTEST_H__
#define Q338_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0338.hpp"
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 338.
  *      Counting Bits
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given an integer ‘n’ , return “an array ” ‘ans’ “ of length ” ‘n + 1’
  *   “ such that for each ” ‘i’ “ ” ( ‘0 ≤ i ≤ n’ ) “, ” ‘ans[i]’ “ is the
  *   “number of ” ” ‘1’ “ “&#39;s” in the binary representation of ” ‘i’.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘0 ≤ n ≤ 10⁵’
  *   • It is very easy to come up with a solution with a runtime of ‘O(n log n)’ . Can you do it in linear time ‘O(n)’ and possibly in a single pass?
  *   • Can you do it without using any built-in function (i.e., like ‘__builtin_popcount’ in C++)?
  *
*/

TEST(q338, sample_input01) {
  l338::Solution solver;
  int n = 2;
  vector<int> exp = {0, 1, 1};
  EXPECT_EQ(solver.countBits(n), exp);
}

TEST(q338, sample_input02) {
  l338::Solution solver;
  int n = 5;
  vector<int> exp = {0, 1, 1, 2, 1, 2};
  EXPECT_EQ(solver.countBits(n), exp);
}

#endif