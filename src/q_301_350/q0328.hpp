
#ifndef LEETCODE_Q328_H__
#define LEETCODE_Q328_H__
#include <iostream>
#include <leetcode/listnode.hpp>

namespace l328 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 328.
 *      Odd Even Linked List
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘head’ of a singly linked list, group all the nodes with odd
 *   indices together followed by the nodes with even indices, and return
 *   “the reordered list”
 *   The “first” node is considered “odd” , and the “second” node is “even”
 *   , and so
 *   Note that the relative order inside both the even and odd groups
 *   should remain as it was in the
 *   You must solve the problemin ‘O(1)’ extra space complexity and ‘O(n)’
 *   time complexity.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n =’ number of nodes in the linked list
 *   • ‘0 ≤ n ≤ 10⁴’
 *   • ‘-10⁶ ≤ Node.val ≤ 10⁶’
 *
 */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
 public:
  ListNode* oddEvenList(ListNode* head) {
    if (head == nullptr) return nullptr;
    ListNode *odd = head,
             *even = head->next,
             *even_head = even;
    while (even != nullptr && even->next != nullptr) {
      odd->next = even->next;
      odd = odd->next;
      even->next = odd->next;
      even = even->next;
    }
    odd->next = even_head;
    return head;
  }
};
}  // namespace l328

#endif