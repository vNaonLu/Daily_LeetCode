
#ifndef LEETCODE_Q1254_H__
#define LEETCODE_Q1254_H__
#include <iostream>
#include <queue>
#include <vector>

namespace l1254 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1254.
 *       Number of Closed Islands
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a 2D ‘grid’ consists of ‘0s’ (land)and ‘1s’ (water). An “island”
 *   is a maximal 4-directionally connected group of ‘<font
 *   face="monospace">0</font>s’ and a “closed island” is an island
 *   “totally” (all left, top, right, bottom) surrounded by ‘1s.’
 *   Return the number of “closed islands” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ grid.length, grid[0].length ≤ 100’
 *   • ‘0 ≤ grid[i][j] ≤1’
 *
 */

class Solution {
 private:
  vector<int> direct = {0, 1, 1, 0, 0, -1, -1, 0};

 public:
  int closedIsland(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
    int res = 0;
    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < n; ++j) {
        if (grid[i][j] == 0) {
          bool surround = true;
          queue<pair<int, int>> q;
          grid[i][j] = 1;
          q.emplace(i, j);
          while (!q.empty()) {
            auto cur = q.front();
            q.pop();
            for (int d = 0; d < direct.size(); ++d) {
              int x = cur.first + direct[d];
              int y = cur.second + direct[++d];
              if (x < 0 || x >= m || y < 0 || y >= n) {
                surround = false;
                continue;
              }
              if (grid[x][y] == 0) {
                grid[x][y] = 1;
                q.emplace(x, y);
              }
            }
          }
          if (surround) ++res;
        }
      }
    }
    return res;
  }
};
}  // namespace l1254

#endif