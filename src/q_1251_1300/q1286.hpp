
#ifndef LEETCODE_Q1286_H__
#define LEETCODE_Q1286_H__
#include <iostream>
#include <queue>

namespace l1286 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1286.
 *       Iterator for Combination
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Design the ‘CombinationIterator’
 *       -  ‘CombinationIterator(string characters, int combinationLength)’
 *   Initializes the object witha string ‘characters’ of “sorted distinct”
 *   lowercase English letters and a number ‘combinationLength’ as
 *       -  ‘next()’ Returns the next combination of length
 *   ‘combinationLength’ in “lexicographical order”
 *       -  ‘hasNext()’ Returns ‘true’ if and only ifthere exists a next
 *   combination.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ combinationLength ≤characters.length ≤ 15’
 *   • All the characters of ‘characters’ are “unique” .
 *   • At most ‘10⁴’ calls will be made to ‘next’ and ‘hasNext’ .
 *   • It's guaranteed that allcallsof the function ‘next’ are valid.
 *
 */

class CombinationIterator {
 private:
  queue<string> _combine;

  void combine_helper(const string &s, int L, string &t, int beg = 0) {
    if (t.size() == L) {
      _combine.emplace(t);
    } else {
      for (int i = beg; i < s.size(); ++i) {
        t.push_back(s[i]);
        combine_helper(s, L, t, i + 1);
        t.pop_back();
      }
    }
  }

 public:
  CombinationIterator(string characters, int combinationLength) {
    string tmp;
    combine_helper(characters, combinationLength, tmp);
  }

  string next() {
    auto res = _combine.front();
    _combine.pop();
    return res;
  }

  bool hasNext() {
    return !_combine.empty();
  }
};

/**
 * Your CombinationIterator object will be instantiated and called as such:
 * CombinationIterator* obj = new CombinationIterator(characters, combinationLength);
 * string param_1 = obj->next();
 * bool param_2 = obj->hasNext();
 */
}  // namespace l1286

#endif