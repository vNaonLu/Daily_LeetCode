#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1288.
 *       Remove Covered Intervals
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an array ‘intervals’ where ‘intervals[i] = [lᵢ, rᵢ]’ represent
 *   the interval ‘[lᵢ, rᵢ)’ , remove all intervals that are covered by
 *   another interval in the
 *   The interval ‘[a, b)’ is covered by the interval ‘[c, d)’ if and only
 *   if ‘c ≤ a’ and ‘b ≤ d’
 *   Return “the number of remaining intervals” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ intervals.length ≤ 1000’
 *   • ‘intervals[i].length = 2’
 *   • ‘0 ≤ lᵢ ≤ rᵢ ≤ 10⁵’
 *   • All the given intervals are “unique” .
 *
 */

struct q1288 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int removeCoveredIntervals(vector<vector<int>> &intervals) {
      sort(intervals.begin(), intervals.end(), [](const vector<int> &x, const vector<int> &y) {
        return x[0] == y[0] ? x[1] > y[1] : x[0] < y[0];
      });
      int         res = intervals.size();
      vector<int> curr = intervals.front();
      for (auto it = intervals.begin() + 1; it != intervals.end(); ++it) {
        int l = curr[0],
            r = curr[1];
        if (l <= (*it)[0] && r >= (*it)[1]) {
          --res;
        } else {
          curr = *it;
        }
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1288, sample_input01) {
  solution = new Solution();
  vector<vector<int>> intervals = {{1, 4}, {3, 6}, {2, 8}};
  int exp = 2;
  int act = solution->removeCoveredIntervals(intervals);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1288, sample_input02) {
  solution = new Solution();
  vector<vector<int>> intervals = {{1, 4}, {2, 3}};
  int exp = 1;
  int act = solution->removeCoveredIntervals(intervals);
  EXPECT_EQ(act, exp);
  delete solution;
}