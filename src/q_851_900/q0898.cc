#include <gtest/gtest.h>
#include <iostream>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 898.
 *      Bitwise ORs of Subarrays
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   We have an array ‘arr’ of non-negative
 *   For every (contiguous) subarray ‘sub = [arr[i], arr[i + 1], ...,
 *   arr[j]]’ (with ‘i ≤ j’ ), we take the bitwise OR of all the elements
 *   in ‘sub’ , obtaining a result ‘arr[i] | arr[i + 1] | ... | arr[j]’
 *   Return the number of possible results. Results that occur more than
 *   once are only counted once in the final answer
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ nums.length ≤ 5 × 10⁴’
 *   • ‘0 ≤ nums[i]≤ 10⁹’
 *
 */

struct q898 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int subarrayBitwiseORs(vector<int>& arr) {
      vector<int> res;
      int l = 0, r;
      for (const auto& a : arr) {
        r = res.size();
        res.push_back(a);
        for (int i = l; i < r; ++i) {
          int val = res[i] | a;
          if (res.back() != val)
            res.push_back(val);
        }
        l = r;
      }
      return unordered_set(res.begin(), res.end()).size();
    }
  };

  class Solution *solution;
};

TEST_F(q898, sample_input01) {
  solution = new Solution();
  vector<int> arr = {0};
  int exp = 1;
  EXPECT_EQ(solution->subarrayBitwiseORs(arr), exp);
  delete solution;
}

TEST_F(q898, sample_input02) {
  solution = new Solution();
  vector<int> arr = {1, 1, 2};
  int exp = 3;
  EXPECT_EQ(solution->subarrayBitwiseORs(arr), exp);
  delete solution;
}

TEST_F(q898, sample_input03) {
  solution = new Solution();
  vector<int> arr = {1, 2, 4};
  int exp = 6;
  EXPECT_EQ(solution->subarrayBitwiseORs(arr), exp);
  delete solution;
}