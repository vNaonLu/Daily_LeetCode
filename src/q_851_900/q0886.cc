#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 886.
 *      Possible Bipartition
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   We want to split a group of ‘n’ people (labeled from ‘1’ to ‘n’ ) into
 *   two groups of “any size” . Each person may dislike some other people,
 *   and they should not go into the same
 *   Given the integer ‘n’ and the array ‘dislikes’ where ‘dislikes[i] =
 *   [aᵢ, bᵢ]’ indicates that the person labeled ‘aᵢ’ does not like the
 *   person labeled ‘bᵢ’ , return ‘true’ “if it is possible to split
 *   everyone into two groups in this way” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n ≤ 2000’
 *   • ‘0 ≤ dislikes.length ≤ 10⁴’
 *   • ‘dislikes[i].length = 2’
 *   • ‘1 ≤ dislikes[i][j] ≤ n’
 *   • ‘aᵢ < bᵢ’
 *   • All the pairs of ‘dislikes’ are “unique” .
 *
 */

struct q886 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    bool possibleBipartition(int n, vector<vector<int>> &dislikes) {
      vector<unordered_set<int>> graph(n + 1);

      for (auto &v : dislikes) {
        graph[v[0]].emplace(v[1]);
        graph[v[1]].emplace(v[0]);
      }

      vector<bool> grouped(n + 1, false),
                   visited(n + 1, false);

      for (int i = 1; i <= n; ++i) {
        if (visited[i]) continue;
        queue<int> q;
        q.emplace(i);
        visited[i] = true;

        while (!q.empty()) {
          auto x = q.front(); q.pop();

          for (auto &y : graph[x]) {
            if (!visited[y]) {
              visited[y] = true;
              grouped[y] = !grouped[x];
              q.emplace(y);
            } else {
              if (grouped[x] == grouped[y]) {
                return false;
              }
            }
          }
        }
      }

      return true;
    }
  };

  class Solution *solution;
};

TEST_F(q886, sample_input01) {
  solution = new Solution();
  int n = 4;
  vector<vector<int>> dislikes = {{1, 2}, {1, 3}, {2, 4}};
  bool exp = true;
  bool act = solution->possibleBipartition(n, dislikes);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q886, sample_input02) {
  solution = new Solution();
  int n = 3;
  vector<vector<int>> dislikes = {{1, 2}, {1, 3}, {2, 3}};
  bool exp = false;
  bool act = solution->possibleBipartition(n, dislikes);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q886, sample_input03) {
  solution = new Solution();
  int n = 5;
  vector<vector<int>> dislikes = {{1, 2}, {2, 3}, {3, 4}, {4, 5}, {1, 5}};
  bool exp = false;
  bool act = solution->possibleBipartition(n, dislikes);
  EXPECT_EQ(act, exp);
  delete solution;
}