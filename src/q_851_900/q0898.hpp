
#ifndef LEETCODE_Q898_H__
#define LEETCODE_Q898_H__
#include <iostream>
#include <unordered_set>
#include <vector>

namespace l898 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 898.
  *      Bitwise ORs of Subarrays
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   We have an array ‘arr’ of non-negative integers.
  *   
  *   For every (contiguous) subarray ‘sub = [arr[i], arr[i + 1], ...,
  *   arr[j]]’ (with ‘i ≤ j’ ), we take the bitwise OR of all the elements
  *   in ‘sub’ , obtaining a result ‘arr[i] | arr[i + 1] | ... | arr[j]’.
  *   
  *   Return the number of possible results. Results that occur more than
  *   once are only counted once in the final.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘1 ≤ nums.length ≤ 5 × 10⁴’
  *   • ‘0 ≤ nums[i]≤ 10⁹’
  *
*/

class Solution {
 public:
  int subarrayBitwiseORs(vector<int>& arr) {
    vector<int> res;
    int l = 0, r;
    for (const auto& a : arr) {
      r = res.size();
      res.push_back(a);
      for (int i = l; i < r; ++i) {
        int val = res[i] | a;
        if (res.back() != val)
          res.push_back(val);
      }
      l = r;
    }
    return unordered_set(res.begin(), res.end()).size();
  }
};
}  // namespace l898

#endif