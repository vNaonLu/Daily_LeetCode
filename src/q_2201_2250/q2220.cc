#include <gtest/gtest.h>
#include <iostream>

using namespace std;

/**
 * The file is generated by LeetCodeDailyTools
 *
 * 2220.
 *       Minimum Bit Flips to Convert Number
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   A “bit flip” of a number ‘x’ is choosing a bit in the binary
 *   representation of ‘x’ and “flipping” it from either ‘0’ to ‘1’ or ‘1’
 *   to ‘0’
 *       - For example, for ‘x = 7’ , the binary representation is ‘111’
 *   and we may choose any bit (including any leading zeros not shown) and
 *   flip it. We can flip the first bit from the right to get ‘110’ , flip
 *   the second bit from the right to get ‘101’ , flip the fifth bit from
 *   the right (a leading zero) to get ‘10111’ ,
 *   Given two integers ‘start’ and ‘goal’ , return “ the “minimum” number
 *   of “bit flips” to convert ” ‘start’ “ to ” ‘goal’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘0 ≤ start, goal ≤ 10⁹’
 *
 * see more details:
 * https://leetcode.com/problems/minimum-bit-flips-to-convert-number/
 */

struct q2220 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    int minBitFlips(int start, int goal) {
      int res = 0;
      while (start != 0 || goal != 0) {
        if ((start & 1) ^ (goal & 1)) {
          ++res;
        }
        start >>= 1;
        goal >>= 1;
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q2220, sample_input01) {
  solution  = new Solution();
  int start = 10;
  int goal  = 7;
  int exp   = 3;
  int act   = solution->minBitFlips(start, goal);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q2220, sample_input02) {
  solution  = new Solution();
  int start = 3;
  int goal  = 4;
  int exp   = 3;
  int act   = solution->minBitFlips(start, goal);
  EXPECT_EQ(act, exp);
  delete solution;
}
