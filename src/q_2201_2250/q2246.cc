#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 2246.
 *       Longest Path With Different Adjacent Characters
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given a “tree” (i.e. a connected, undirected graph that has no
 *   cycles) “rooted” at node ‘0’ consisting of ‘n’ nodes numbered from ‘0’
 *   to ‘n - 1’ . The tree is represented by a “0-indexed” array ‘parent’
 *   of size ‘n’ , where ‘parent[i]’ is the parent of node ‘i’ . Since node
 *   ‘0’ is the root, ‘parent[0] = -1’
 *   You are also given a string ‘s’ of length ‘n’ , where ‘s[i]’ is the
 *   character assigned to node ‘i’
 *   Return “the length of the “longest path” in the tree such that no pair
 *   of “adjacent” nodes on the path have the same character assigned to
 *   them.”
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = parent.length = s.length’
 *   • ‘1 ≤ n ≤ 10⁵’
 *   • ‘0 ≤ parent[i] ≤ n - 1’ for all ‘i ≥ 1’
 *   • ‘parent[0] = -1’
 *   • ‘parent’ represents a valid tree.
 *   • ‘s’ consists of only lowercase English letters.
 *
 */

struct q2246 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    int dfs(vector<vector<int>> &x, int &res, int i, string &s) {
      if (x[i].size() == 0) {
        return 1;
      }
      vector<int> e;
      int         len1 = 0, len2 = 0;
      for (int j = 0; j < x[i].size(); ++j) {
        auto tmp = dfs(x, res, x[i][j], s);
        if (s[x[i][j]] == s[i]) {
          tmp = 0;
        }
        if (tmp > len1) {
          len2 = len1;
          len1 = tmp;
        } else if (tmp > len2) {
          len2 = tmp;
        }
      }
      res = max(res, len1 + len2 + 1);
      return len1 + 1;
    }

  public:
    int longestPath(vector<int> &parent, string s) {
      auto                n = parent.size();
      vector<vector<int>> x(n);
      int                 res = 1;
      for (int i = 0; i < n; ++i) {
        if (parent[i] != -1) {
          x[parent[i]].emplace_back(i);
        }
      }
      dfs(x, res, 0, s);
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q2246, sample_input01) {
  solution           = new Solution();
  vector<int> parent = {-1, 0, 0, 1, 1, 2};
  string      s      = "abacbe";
  int         exp    = 3;
  int         act    = solution->longestPath(parent, s);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q2246, sample_input02) {
  solution           = new Solution();
  vector<int> parent = {-1, 0, 0, 0};
  string      s      = "aabc";
  int         exp    = 3;
  int         act    = solution->longestPath(parent, s);
  EXPECT_EQ(act, exp);
  delete solution;
}
