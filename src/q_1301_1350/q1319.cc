#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <unordered_map>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1319.
 *       Number of Operations to Make Network Connected
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   There are ‘n’ computers numbered from ‘0’ to ‘n - 1’ connected by
 *   ethernet cables ‘connections’ forming a network where ‘connections[i]
 *   = [aᵢ, bᵢ]’ represents a connection between computers ‘aᵢ’ and ‘bᵢ’ .
 *   Any computer can reach any other computer directly or indirectly
 *   through the
 *   You are given an initial computer network ‘connections’ . You can
 *   extract certain cables between two directly connected computers, and
 *   place them between any pair of disconnected computers to make them
 *   directly
 *   Return “the minimum number of times you need to do this in order to
 *   make all the computers connected” . If it is not possible, return ‘-1’
 *   .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n ≤ 10⁵’
 *   • ‘1 ≤ connections.length ≤ min(n × (n - 1) / 2, 10⁵)’
 *   • ‘connections[i].length = 2’
 *   • ‘0 ≤ aᵢ, bᵢ < n’
 *   • ‘aᵢ ≠ bᵢ’
 *   • There are no repeated connections.
 *   • No two computers are connected by more than one cable.
 *
 */

struct q1319 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int makeConnected(int n, vector<vector<int>> &connections) {
      if (n - 1 > connections.size()) return -1;

      unordered_map<int, unordered_set<int>> graph;
      unordered_set<int>                     visited;
      int                                    res = 0;

      for (const auto &v : connections) {
        auto x = v[0], y = v[1];
        graph[x].insert(y);
        graph[y].insert(x);
      }

      for (int i = 0; i < n; ++i) {
        if (visited.emplace(i).second) {
          queue<int> q;
          q.emplace(i);

          ++res;
          while (!q.empty()) {
            auto x = q.front(); q.pop();
            for (const auto &y : graph[x]) {
              if (visited.emplace(y).second) {
                q.emplace(y);
              }
            }
          }
        }
      }
      return --res;
    }
  };

  class Solution *solution;
};

TEST_F(q1319, sample_input01) {
  solution = new Solution();
  int n = 4;
  vector<vector<int>> connections = {{0, 1}, {0, 2}, {1, 2}};
  int exp = 1;
  int act = solution->makeConnected(n, connections);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1319, sample_input02) {
  solution = new Solution();
  int n = 6;
  vector<vector<int>> connections = {{0, 1}, {0, 2}, {0, 3}, {1, 2}, {1, 3}};
  int exp = 2;
  int act = solution->makeConnected(n, connections);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1319, sample_input03) {
  solution = new Solution();
  int n = 6;
  vector<vector<int>> connections = {{0, 1}, {0, 2}, {0, 3}, {1, 2}};
  int exp = -1;
  int act = solution->makeConnected(n, connections);
  EXPECT_EQ(act, exp);
  delete solution;
}