#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1654.
 *       Minimum Jumps to Reach Home
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   A certain bug's home is on the x-axis at position ‘x’ . Help them get
 *   there from position ‘0’
 *   The bug jumps according to the following
 *       - It can jump exactly ‘a’ positions “forward” (to the
 *       - It can jump exactly ‘b’ positions “backward” (to the
 *       - It cannot jump backward twice in a
 *       - It cannot jump to any ‘forbidden’
 *   The bug may jump forward “beyond” its home, but it “cannot jump” to
 *   positions numbered with “negative”
 *   Given an array of integers ‘forbidden’ , where ‘forbidden[i]’ means
 *   that the bug cannot jump to the position ‘forbidden[i]’ , and integers
 *   ‘a’ , ‘b’ , and ‘x’ , return “the minimum number of jumps needed for
 *   the bug to reach its home” . If there is no possible sequence of jumps
 *   that lands the bug on position ‘x’ , return ‘-1.’ 
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ forbidden.length ≤ 1000’
 *   • ‘1 ≤ a, b, forbidden[i] ≤ 2000’
 *   • ‘0 ≤ x ≤ 2000’
 *   • All the elements in ‘forbidden’ are distinct.
 *   • Position ‘x’ is not forbidden.
 *
 */

struct q1654 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int minimumJumps(vector<int> &forbidden, int a, int b, int x) {
      unordered_set<int> forbid, fwvisit, bwvisit;
      for (auto &x : forbidden) {
        forbid.insert(x);
      }

      int res = 0;
      queue<pair<int, bool>> pos;
      pos.emplace(0, false);

      while (!pos.empty()) {
        auto temp = move(pos);

        while (!temp.empty()) {
          auto [curr, last_is_bw] = temp.front(); temp.pop();

          if (curr == x) return res;

          if (!forbid.count(curr + a) && !fwvisit.count(curr + a) && curr + a <= 10000) {
            fwvisit.insert(curr + a);
            pos.emplace(curr + a, false);
          }

          if (!last_is_bw && !forbid.count(curr - b) && !bwvisit.count(curr - b) && curr - b > 0) {
            bwvisit.insert(curr - b);
            pos.emplace(curr - b, true);
          }
        }

        ++res;
      }

      return -1;
    }
  };

  class Solution *solution;
};

TEST_F(q1654, sample_input01) {
  solution = new Solution();
  vector<int> forbidden = {14, 4, 18, 1, 15};
  int a = 3;
  int b = 15;
  int x = 9;
  int exp = 3;
  int act = solution->minimumJumps(forbidden, a, b, x);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1654, sample_input02) {
  solution = new Solution();
  vector<int> forbidden = {8, 3, 16, 6, 12, 20};
  int a = 15;
  int b = 13;
  int x = 11;
  int exp = -1;
  int act = solution->minimumJumps(forbidden, a, b, x);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1654, sample_input03) {
  solution = new Solution();
  vector<int> forbidden = {1, 6, 2, 14, 5, 17, 4};
  int a = 16;
  int b = 9;
  int x = 7;
  int exp = 2;
  int act = solution->minimumJumps(forbidden, a, b, x);
  EXPECT_EQ(act, exp);
  delete solution;
}