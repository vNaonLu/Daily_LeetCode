#include <algorithm>
#include <gtest/gtest.h>
#include <iostream>
#include <set>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1657.
 *       Determine if Two Strings Are Close
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Two strings are considered “close” if you can attain one from the
 *   other using the following
 *       - Operation 1: Swap any two “existing”
 *           - For example, ‘a<u>b</u>cd<u>e</u> -> a<u>e</u>cd<u>b</u>’
 *
 *       - Operation 2: Transform “every” occurrence of one “existing”
 *   character into another “existing” character, and do the same with the
 *   other
 *           - For example, ‘<u>aa</u>c<u>abb</u> -> <u>bb</u>c<u>baa</u>’
 *   (all ‘a’ 's turn into ‘b’ 's, and all ‘b’ 's turn into ‘a’
 *
 *   You can use the operations on either string as many times as
 *   Given two strings, ‘word1’ and ‘word2’ , return ‘true’ “ if ” ‘word1’
 *   “ and ” ‘word2’ “ are “close” , and ” ‘false’ “ otherwise.”
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ word1.length, word2.length ≤ 10⁵’
 *   • ‘word1’ and ‘word2’ containonly lowercase English letters.
 *
 */

struct q1657 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    bool closeStrings(string word1, string word2) {
      if (word1.size() != word2.size()) {
        return false;
      }
      if (set(word1.begin(), word1.end()) != set(word2.begin(), word2.end())) {
        return false;
      }

      auto n     = word1.size();
      auto freq1 = vector<int>(26, 0);
      auto freq2 = vector<int>(26, 0);
      for (int i = 0; i < n; ++i) {
        ++freq1[word1[i] - 'a'];
        ++freq2[word2[i] - 'a'];
      }
      sort(freq1.rbegin(), freq1.rend());
      sort(freq2.rbegin(), freq2.rend());
      for (int i = 0; i < 26; ++i) {
        if (freq1[i] != freq2[i]) {
          return false;
        }
      }

      return true;
    }
  };

  class Solution *solution;
};

TEST_F(q1657, sample_input01) {
  solution     = new Solution();
  string word1 = "abc";
  string word2 = "bca";
  bool   exp   = true;
  bool   act   = solution->closeStrings(word1, word2);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1657, sample_input02) {
  solution     = new Solution();
  string word1 = "a";
  string word2 = "aa";
  bool   exp   = false;
  bool   act   = solution->closeStrings(word1, word2);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1657, sample_input03) {
  solution     = new Solution();
  string word1 = "cabbba";
  string word2 = "abbccc";
  bool   exp   = true;
  bool   act   = solution->closeStrings(word1, word2);
  EXPECT_EQ(act, exp);
  delete solution;
}