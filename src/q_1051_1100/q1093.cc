#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1093.
 *       Statistics from a Large Sample
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given a large sample of integers in the range ‘[0, 255]’ .
 *   Since the sample is so large, it is represented by an array ‘count’
 *   where ‘count[k]’ is the “number of times” that ‘k’ appears in the
 *   Calculate the following
 *       -  ‘minimum’ : The minimum element in the
 *       -  ‘maximum’ : The maximum element in the
 *       -  ‘mean’ : The average of the sample, calculated as the total sum
 *   of all elements divided by the total number of
 *       -  ‘median’
 *           - If the sample has an odd number of elements, then the
 *   ‘median’ is the middle element once the sample is
 *           - If the sample has an even number of elements, then the
 *   ‘median’ is the average of the two middle elements once the sample is
 *      
 *       -  ‘mode’ : The number that appears the most in the sample. It is
 *   guaranteed to be “unique”
 *   Return “the statistics of the sample as an array of floating-point
 *   numbers ” ‘[minimum, maximum, mean, median, mode]’ “. Answers within ”
 *   ‘10⁻⁵’ “ of the actual answer will be accepted.” 
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘count.length = 256’
 *   • ‘0 ≤ count[i] ≤ 10⁹’
 *   • ‘1 ≤ sum(count) ≤ 10⁹’
 *   • The mode of the sample that ‘count’ represents is “unique” .
 *
 */

struct q1093 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    vector<double> sampleStats(vector<int> &count) {
      vector<double>         res(5, 0);
      vector<pair<int, int>> seq_set;
      int max_appear = 0,
          num = 0;
      res.front() = std::numeric_limits<double>::max();
      for (int i = 0; i < count.size(); ++i) {
        if (count[i] > 0) {
          seq_set.emplace_back(i, count[i]);
          num += count[i];
          res[0] = min<double>(res[0], i);
          res[1] = max<double>(res[1], i);
          res[2] += static_cast<double>(i) * static_cast<double>(count[i]);

          if (max_appear < count[i]) {
            res[4] = i;
            max_appear = count[i];
          }
        }
      }

      res[2] /= static_cast<double>(num);

      if (num & 1) {
        int median = 0, target = (num + 1) / 2;
        for (auto &[x, cnt] : seq_set) {
          median += cnt;
          if (median >= target) {
            res[3] = x;
            break;
          }
        }
      } else {
        int median = 0, target = num / 2;
        auto beg = seq_set.begin();
        while (beg != seq_set.end()) {
          auto &[x, cnt] = *(beg++);
          median += cnt;
          if (median > target) {
            res[3] = x;
            break;
          } else if (median == target) {
            res[3] = (static_cast<double>(x) + static_cast<double>((*beg).first)) / 2.0;
            break;
          }
        }
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1093, sample_input01) {
  solution = new Solution();
  vector<int> count = {0, 1, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  vector<double> exp = {1.00000, 3.00000, 2.37500, 2.50000, 3.00000};
  vector<double> act = solution->sampleStats(count);
  ASSERT_EQ(exp.size(), act.size());
  for (int i = 0; i < exp.size(); ++i) {
    EXPECT_NEAR(exp[i], act[i], 0.0001);
  }
  delete solution;
}

TEST_F(q1093, sample_input02) {
  solution = new Solution();
  vector<int> count = {0, 4, 3, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  vector<double> exp = {1.00000, 4.00000, 2.18182, 2.00000, 1.00000};
  vector<double> act = solution->sampleStats(count);
  ASSERT_EQ(exp.size(), act.size());
  for (int i = 0; i < exp.size(); ++i) {
    EXPECT_NEAR(exp[i], act[i], 0.0001);
  }
  delete solution;
}