#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1053.
 *       Previous Permutation With One Swap
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an array of positive integers ‘arr’ (not necessarily distinct),
 *   return “the lexicographically largest permutation that is smaller
 *   than” ‘arr’ , that can be “made with exactly one swap” (A “swap”
 *   exchanges the positions of two numbers ‘arr[i]’ and ‘arr[j]’ ). If it
 *   cannot be done, then return the same array.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ arr.length ≤ 10⁴’
 *   • ‘1 ≤ arr[i] ≤ 10⁴’
 *
 */

struct q1053 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    vector<int> prevPermOpt1(vector<int>& arr) {
      for (int i = arr.size() - 2; i >= 0; --i) {
        if (arr[i] > arr[i + 1]) {
          int largest = arr[i];
          int smaller = numeric_limits<int>::min(),
              index;
          for (int j = i + 1; j < arr.size(); ++j) {
            if (arr[j] < arr[i] && arr[j] > smaller) {
              smaller = arr[j];
              index = j;
            }
          }
          arr[i] = smaller;
          arr[index] = largest;
          break;
        }
      }
      return arr;
    }
  };

  class Solution *solution;
};

TEST_F(q1053, sample_input01) {
  solution = new Solution();
  vector<int> arr = {3, 2, 1};
  vector<int> exp = {3, 1, 2};
  vector<int> act = solution->prevPermOpt1(arr);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1053, sample_input02) {
  solution = new Solution();
  vector<int> arr = {1, 1, 5};
  vector<int> exp = {1, 1, 5};
  vector<int> act = solution->prevPermOpt1(arr);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1053, sample_input03) {
  solution = new Solution();
  vector<int> arr = {1, 9, 4, 6, 7};
  vector<int> exp = {1, 7, 4, 6, 9};
  vector<int> act = solution->prevPermOpt1(arr);
  EXPECT_EQ(act, exp);
  delete solution;
}