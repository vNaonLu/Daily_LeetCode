
#ifndef LEETCODE_Q973_H__
#define LEETCODE_Q973_H__
#include <iostream>
#include <queue>
#include <vector>

namespace l973 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 973.
  *      K Closest Points to Origin
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given an array of ‘points’ where ‘points[i] = [xᵢ, yᵢ]’ represents a
  *   point on the “X-Y” plane and an integer ‘k’ , return the ‘k’ closest
  *   points to the origin ‘(0, 0)’.
  *   
  *   The distance between two points on the “X-Y” plane is the Euclidean
  *   distance (i.e., ‘&radic;(x₁ - x₂)² + (y₁ - y₂)²’ ).
  *   
  *   You may return the answer in “any order” . The answer is “guaranteed”
  *   to be “unique” (except for the order that it is in).
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘1 ≤ k ≤ points.length ≤ 10⁴’
  *   • ‘-10⁴ < xᵢ, yᵢ < 10⁴’
  *
*/

class Solution {
 private:
  using pii = pair<int, int>;

 public:
  vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
    vector<vector<int>> res;
    priority_queue<pii, vector<pii>, greater<pii>> pq;
    for (int i = 0; i < points.size(); ++i) 
      pq.push(make_pair(points[i][0] * points[i][0] + points[i][1] * points[i][1],
                        i));
    while(k--){
      auto top = pq.top();
      pq.pop();
      res.push_back(points[top.second]);
    }
    return res;
  }
};
}  // namespace l973

#endif