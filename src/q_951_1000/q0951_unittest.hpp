
#ifndef Q951_UNITTEST_H__
#define Q951_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0951.hpp"
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 951.
 *      Flip Equivalent Binary Trees
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   For a binary tree “T” , we can define a “flip operation” as follows:
 *   choose any node, and swap the left and right child
 *   A binary tree “X” is “flip equivalent” to a binary tree “Y” if and
 *   only if we can make “X” equal to “Y” after some number of flip
 *   Given the roots of two binary trees ‘root1’ and ‘root2’ , return
 *   ‘true’ if the two trees are flip equivelent or ‘false’ otherwise.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in each tree is in the range ‘[0, 100]’ .
 *   • Each tree will have “unique node values” in the range ‘[0, 99]’ .
 *
 */

TEST(q951, sample_input01) {
  l951::Solution solver;
  TreeNode* root1 = TreeNode::generate({1, 2, 3, 4, 5, 6, NULL_TREENODE, NULL_TREENODE, NULL_TREENODE, 7, 8});
  TreeNode* root2 = TreeNode::generate({1, 3, 2, NULL_TREENODE, 6, 4, 5, NULL_TREENODE, NULL_TREENODE, NULL_TREENODE, NULL_TREENODE, 8, 7});
  bool exp = true;
  EXPECT_EQ(solver.flipEquiv(root1, root2), exp);
}

TEST(q951, sample_input02) {
  l951::Solution solver;
  TreeNode* root1 = TreeNode::generate({});
  TreeNode* root2 = TreeNode::generate({});
  bool exp = true;
  EXPECT_EQ(solver.flipEquiv(root1, root2), exp);
}

TEST(q951, sample_input03) {
  l951::Solution solver;
  TreeNode* root1 = TreeNode::generate({});
  TreeNode* root2 = TreeNode::generate({1});
  bool exp = false;
  EXPECT_EQ(solver.flipEquiv(root1, root2), exp);
}

TEST(q951, sample_input04) {
  l951::Solution solver;
  TreeNode* root1 = TreeNode::generate({0, NULL_TREENODE, 1});
  TreeNode* root2 = TreeNode::generate({});
  bool exp = false;
  EXPECT_EQ(solver.flipEquiv(root1, root2), exp);
}

TEST(q951, sample_input05) {
  l951::Solution solver;
  TreeNode* root1 = TreeNode::generate({0, NULL_TREENODE, 1});
  TreeNode* root2 = TreeNode::generate({0, 1});
  bool exp = true;
  EXPECT_EQ(solver.flipEquiv(root1, root2), exp);
}

#endif