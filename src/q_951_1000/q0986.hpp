
#ifndef LEETCODE_Q986_H__
#define LEETCODE_Q986_H__
#include <algorithm>
#include <iostream>
#include <vector>

namespace l986 {
using namespace std;

/**
  * this file is generated by gquestion.py
  *
  * 986. Interval List Intersections
  *
  * You are given two lists of closed intervals,
  * firstList and secondList , where firstList[i] =
  * [start⎽(i), end⎽(i)] and secondList[j] = [start⎽(j),
  * end⎽(j)] . Each list of intervals is pairwise
  * “disjoint“ and in “sorted order“ .
  * Return the intersection of these two interval
  * lists .
  * A “closed interval“ [a, b] (with a <= b ) denotes
  * the set of real numbers x with a <= x <= b .
  * The “intersection“ of two closed intervals is a
  * set of real numbers that are either empty or
  * represented as a closed interval. For example, the
  * intersection of [1, 3] and [2, 4] is [2, 3] .
  *
  * Constraints:
  * -  0 <= firstList.length, secondList.length <= 1000 
  * -  firstList.length + secondList.length >= 1 
  * -  0 <= start⎽(i) < end⎽(i) <= 10^(9) 
  * -  end⎽(i) < start⎽(i+1) 
  * -  0 <= start⎽(j) < end⎽(j) <= 10^(9) 
  * -  end⎽(j) < start⎽(j+1) 
  *
*/
class Solution {
 public:
  vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList, vector<vector<int>>& secondList) {
    vector<vector<int>> res;
    auto fit = firstList.begin();
    auto sit = secondList.begin();
    int lo, hi;
    while (fit != firstList.end() && sit != secondList.end()) {
      lo = max((*fit)[0], (*sit)[0]);
      hi = min((*fit)[1], (*sit)[1]);
      if (lo <= hi) {
        res.push_back({lo, hi});
      }

      if ((*fit)[1] < (*sit)[1]) {
        ++fit;
      } else {
        ++sit;
      }
    }
    return res;
  }
};
}  // namespace l986
#endif