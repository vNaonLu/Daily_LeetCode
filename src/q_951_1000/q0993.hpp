
#ifndef LEETCODE_Q993_H__
#define LEETCODE_Q993_H__
#include <iostream>
#include <leetcode/treenode.hpp>
#include <queue>

namespace l993 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 993.
 *      Cousins in Binary Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary tree with unique values and the values of
 *   two different nodes of the tree ‘x’ and ‘y’ , return ‘true’ “if the
 *   nodes corresponding to the values ” ‘x’ “ and ” ‘y’ “ in the tree are
 *   “cousins” , or ” ‘false’ “ otherwise.”
 *   Two nodes of a binary tree are “cousins” if they have the same depth
 *   with different
 *   Note that in a binary tree, the root node is at the depth ‘0’ , and
 *   children of each depth ‘k’ node are at the depth ‘k + 1’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[2, 100]’ .
 *   • ‘1 ≤ Node.val ≤ 100’
 *   • Each node has a “unique” value.
 *   • ‘x ≠ y’
 *   • ‘x’ and ‘y’ are exist in the tree.
 *
 */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
 public:
  bool isCousins(TreeNode* root, int x, int y) {
    queue<pair<TreeNode*, TreeNode*>> q;
    TreeNode *xparent = nullptr,
             *yparent = nullptr;
    q.push(make_pair(root, nullptr));
    while (!q.empty() && xparent == nullptr && yparent == nullptr) {
      int node_same_level = q.size();
      while (node_same_level--) {
        auto p = q.front();
        q.pop();
        if (p.first->val == x)
          xparent = p.second;
        else if (p.first->val == y)
          yparent = p.second;
        if (p.first->left) q.push(make_pair(p.first->left, p.first));
        if (p.first->right) q.push(make_pair(p.first->right, p.first));
      }
    }
    return xparent != nullptr && yparent != nullptr && xparent != yparent;
  }
};
}  // namespace l993

#endif