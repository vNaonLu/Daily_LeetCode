
#ifndef LEETCODE_Q994_H__
#define LEETCODE_Q994_H__
#include <iostream>
#include <queue>
#include <vector>

namespace l994 {
using namespace std;

/**
 * this file is generated by gquestion.py
 *
 * 994. Rotting Oranges
 *
 * You are given an m x n grid where each cell can
 * have one of three values:
 * -  0 representing an empty cell,
 * -  1 representing a fresh orange, or
 * -  2 representing a rotten orange.
 * Every minute, any fresh orange that is
 * “4-directionally adjacent“ to a rotten orange becomes
 * rotten.
 * Return the minimum number of minutes that must
 * elapse until no cell has a fresh orange . If this is
 * impossible, return -1 .
 *
 * Constraints:
 * -  m == grid.length
 * -  n == grid[i].length
 * -  1 <= m, n <= 10
 * -  grid[i][j] is 0 , 1 , or 2 .
 *
 */
class Solution {
 private:
  vector<int> direct = {1, 0, 0, 1, -1, 0, 0, -1};

 public:
  int orangesRotting(vector<vector<int>>& grid) {
    queue<pair<int, int>> rot;
    int m = grid.size(), n = grid[0].size();

    int fresh_count = 0;
    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < n; ++j) {
        if (grid[i][j] == 2)
          rot.emplace(i, j);
        else if (grid[i][j] == 1)
          ++fresh_count;
      }
    }

    int res = 0;
    int rot_count = 0;
    while (!rot.empty()) {
      int rot_size = rot.size();
      while (rot_size-- > 0) {
        auto current = rot.front();
        rot.pop();
        for (int i = 0; i < direct.size(); ++i) {
          int x = current.first + direct[i];
          int y = current.second + direct[++i];
          if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 1) {
            ++rot_count;
            grid[x][y] = 2;
            rot.emplace(x, y);
          }
        }
      }
      ++res;
    }
    return fresh_count == 0 ? 0 : rot_count == fresh_count ? res - 1
                                                           : -1;
  }
};
}  // namespace l994
#endif