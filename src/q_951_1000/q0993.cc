#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 993.
 *      Cousins in Binary Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary tree with unique values and the values of
 *   two different nodes of the tree ‘x’ and ‘y’ , return ‘true’ “if the
 *   nodes corresponding to the values ” ‘x’ “ and ” ‘y’ “ in the tree are
 *   “cousins” , or ” ‘false’ “ otherwise.”
 *   Two nodes of a binary tree are “cousins” if they have the same depth
 *   with different
 *   Note that in a binary tree, the root node is at the depth ‘0’ , and
 *   children of each depth ‘k’ node are at the depth ‘k + 1’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[2, 100]’ .
 *   • ‘1 ≤ Node.val ≤ 100’
 *   • Each node has a “unique” value.
 *   • ‘x ≠ y’
 *   • ‘x’ and ‘y’ are exist in the tree.
 *
 */

struct q993 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    bool isCousins(TreeNode* root, int x, int y) {
      queue<pair<TreeNode*, TreeNode*>> q;
      TreeNode *xparent = nullptr,
               *yparent = nullptr;
      q.push(make_pair(root, nullptr));
      while (!q.empty() && xparent == nullptr && yparent == nullptr) {
        int node_same_level = q.size();
        while (node_same_level--) {
          auto p = q.front();
          q.pop();
          if (p.first->val == x)
            xparent = p.second;
          else if (p.first->val == y)
            yparent = p.second;
          if (p.first->left) q.push(make_pair(p.first->left, p.first));
          if (p.first->right) q.push(make_pair(p.first->right, p.first));
        }
      }
      return xparent != nullptr && yparent != nullptr && xparent != yparent;
    }
  };

  class Solution *solution;
};

TEST_F(q993, sample_input01) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1, 2, 3, 4});
  int x = 4;
  int y = 3;
  bool exp = false;
  EXPECT_EQ(solution->isCousins(root, x, y), exp);
  delete solution;
}

TEST_F(q993, sample_input02) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1, 2, 3, NULL_TREENODE, 4, NULL_TREENODE, 5});
  int x = 5;
  int y = 4;
  bool exp = true;
  EXPECT_EQ(solution->isCousins(root, x, y), exp);
  delete solution;
}

TEST_F(q993, sample_input03) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1, 2, 3, NULL_TREENODE, 4});
  int x = 2;
  int y = 3;
  bool exp = false;
  EXPECT_EQ(solution->isCousins(root, x, y), exp);
  delete solution;
}