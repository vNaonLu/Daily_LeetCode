
#ifndef LEETCODE_Q376_H__
#define LEETCODE_Q376_H__
#include <iostream>
#include <vector>

namespace l376 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 376.
 *      Wiggle Subsequence
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   A “wiggle sequence” is a sequence where the differences between
 *   successive numbers strictly alternate between positive and negative.
 *   The first difference (if one exists) may be either positive or
 *   negative. A sequence with one element and a sequence with two
 *   non-equal elements are trivially wiggle
 *       - For example, ‘[1, 7, 4, 9, 2, 5]’ is a “wiggle sequence” because
 *   the differences ‘(6, -3, 5, -7, 3)’ alternate between positive and
 *       - In contrast, ‘[1, 4, 7, 2, 5]’ and ‘[1, 7, 4, 5, 5]’ are not
 *   wiggle sequences. The first is not because its first two differences
 *   are positive, and the second is not because its last difference is
 *   A “subsequence” is obtained by deleting some elements (possibly zero)
 *   from the original sequence, leaving the remaining elements in their
 *   original
 *   Given an integer array ‘nums’ , return “the length of the longest
 *   “wiggle subsequence” of ” ‘nums’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ nums.length ≤ 1000’
 *   • ‘0 ≤ nums[i] ≤ 1000’
 *
 */

class Solution {
 public:
  int wiggleMaxLength(vector<int>& nums) {
    if (nums.size() < 2) return nums.size();
    vector<int> up(nums.size(), 1);
    vector<int> down(nums.size(), 1);
    for (int i = 1; i < nums.size(); ++i) {
      if(nums[i] > nums[i-1]){
        up[i] = down[i - 1] + 1;
        down[i] = down[i - 1];
      }else if(nums[i] < nums[i-1]){
        down[i] = up[i - 1] + 1;
        up[i] = up[i - 1];
      }else{
        down[i] = down[i - 1];
        up[i] = up[i - 1];
      }
    }
    return max(up.back(), down.back());
  }
};
}  // namespace l376

#endif