#include <gtest/gtest.h>
#include <iostream>
#include <string>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 394.
 *      Decode String
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an encoded string, return its decoded
 *   The encoding rule is: ‘k[encoded_string]’ , where the ‘encoded_string’
 *   inside the square brackets is being repeated exactly ‘k’ times. Note
 *   that ‘k’ is guaranteed to be a positive
 *   You may assume that the input string is always valid; No extra white
 *   spaces, square brackets are well-formed,
 *   Furthermore, you may assume that the original data does not contain
 *   any digits and that digits are only for those repeat numbers, ‘k’ .
 *   For example, there won't be input like ‘3a’ or ‘2[4]’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ s.length ≤ 30’
 *   • ‘s’ consists of lowercase English letters, digits, and square brackets ‘'[]'’ .
 *   • ‘s’ is guaranteed to be “a valid” input.
 *   • All the integers in ‘s’ are in the range ‘[1, 300]’ .
 *
 */

struct q394 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    string helper(string str, int times) {
      string result = "";
      for (int i = 0; i < times; i++) result += str;
      return result;
    }

   public:
    string decodeString(string s) {
      int i = 0;
      while (i < s.size()) {
        if (s[i] != ']') {
          i++; continue;
        }
        int j = i;
        while (s[j] != '[') j--;
        string repeatLetters = s.substr(j + 1, i - j - 1);
        int k = j;
        j--;
        while ((j > 0) && (isdigit(s[j]))) j--;
        if (j != 0) j++;
        int repeatTimes = stoi(s.substr(j, k - j));
        s.replace(j, i - j + 1, helper(repeatLetters, repeatTimes));
        i = j + repeatLetters.size() * repeatTimes;
      }
      return s;
    }
  };

  class Solution *solution;
};

TEST_F(q394, sample_input01) {
  solution = new Solution();
  string s = "3[a]2[bc]";
  string exp = "aaabcbc";
  string act = solution->decodeString(s);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q394, sample_input02) {
  solution = new Solution();
  string s = "3[a2[c]]";
  string exp = "accaccacc";
  string act = solution->decodeString(s);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q394, sample_input03) {
  solution = new Solution();
  string s = "2[abc]3[cd]ef";
  string exp = "abcabccdcdcdef";
  string act = solution->decodeString(s);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q394, sample_input04) {
  solution = new Solution();
  string s = "abc3[cd]xyz";
  string exp = "abccdcdcdxyz";
  string act = solution->decodeString(s);
  EXPECT_EQ(act, exp);
  delete solution;
}