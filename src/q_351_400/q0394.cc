#include <gtest/gtest.h>
#include <iostream>
#include <string>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 394.
 *      Decode String
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an encoded string, return its decoded
 *   The encoding rule is: ‘k[encoded_string]’ , where the ‘encoded_string’
 *   inside the square brackets is being repeated exactly ‘k’ times. Note
 *   that ‘k’ is guaranteed to be a positive
 *   You may assume that the input string is always valid; No extra white
 *   spaces, square brackets are well-formed,
 *   Furthermore, you may assume that the original data does not contain
 *   any digits and that digits are only for those repeat numbers, ‘k’ .
 *   For example, there won't be input like ‘3a’ or ‘2[4]’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ s.length ≤ 30’
 *   • ‘s’ consists of lowercase English letters, digits, and square brackets
 * ‘'[]'’ . • ‘s’ is guaranteed to be “a valid” input. • All the integers in ‘s’
 * are in the range ‘[1, 300]’ .
 *
 */

struct q394 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    template <typename Iterator> int toInteger(Iterator beg, Iterator end) {
      auto res = 0;
      while (beg != end) {
        res = res * 10 + (*beg++ - '0');
      }
      return res;
    }

    template <typename Iterator>
    Iterator findDigit(Iterator beg, Iterator end) {
      while (beg != end) {
        if (!isdigit(*beg)) {
          return beg;
        }
        ++beg;
      }
      return end;
    }

    template <typename Iterator> Iterator findPair(Iterator beg, Iterator end) {
      /// the first must be '['
      assert(*beg == '[');
      auto cnt = (int)1;
      while (++beg != end) {
        if (*beg == '[') {
          ++cnt;
        } else if (*beg == ']') {
          if (--cnt == 0) {
            return beg;
          }
        }
      }
      return end;
    }

    template <typename Iterator> string solve(Iterator beg, Iterator end) {
      auto res   = string("");
      auto it    = beg;
      auto times = (int)1;
      while (it != end) {
        if (*it == '[') {
          auto next = findPair(it, end);
          auto sub  = solve(++it, next);
          auto cnt  = (int)0;
          while (++cnt <= times) {
            res += sub;
          }
          times = (int)1;
          it    = ++next; /// *next == ']'
        } else if (isdigit(*it)) {
          auto next = findDigit(it, end);
          times     = toInteger(it, next);
          it        = next;
        } else {
          res += *it++;
        }
      }
      return res;
    }

  public:
    string decodeString(string s) { return solve(s.begin(), s.end()); }
  };

  class Solution *solution;
};

TEST_F(q394, sample_input01) {
  solution   = new Solution();
  string s   = "3[a]2[bc]";
  string exp = "aaabcbc";
  string act = solution->decodeString(s);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q394, sample_input02) {
  solution   = new Solution();
  string s   = "3[a2[c]]";
  string exp = "accaccacc";
  string act = solution->decodeString(s);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q394, sample_input03) {
  solution   = new Solution();
  string s   = "2[abc]3[cd]ef";
  string exp = "abcabccdcdcdef";
  string act = solution->decodeString(s);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q394, sample_input04) {
  solution   = new Solution();
  string s   = "abc3[cd]xyz";
  string exp = "abccdcdcdxyz";
  string act = solution->decodeString(s);
  EXPECT_EQ(act, exp);
  delete solution;
}