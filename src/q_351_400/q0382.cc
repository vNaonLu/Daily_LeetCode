#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/listnode.hpp>
#include <random>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 382.
 *      Linked List Random Node
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a singly linked list, return a random node's value from the
 *   linked list. Each node must have the “same probability” of being
 *   Implement the ‘Solution’
 *       -  ‘Solution(ListNode head)’ Initializes the object with the
 *   integer array
 *       -  ‘int getRandom()’ Chooses a node randomly from the list and
 *   returns its value. All the nodes of the list should be equally likely
 *   to be choosen.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the linked list will be in the range ‘[1, 10⁴]’ .
 *   • ‘-10⁴ ≤ Node.val ≤ 10⁴’
 *   • At most ‘10⁴’ calls will be made to ‘getRandom’ .
 *   • What if the linked list is extremely large and its length is unknown to you?
 *   • Could you solve this efficiently without using extra space?
 *
 */

struct q382 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    random_device rd;
    vector<int> dataset_;

   public:
    Solution(ListNode* head) {
      while (nullptr != head) {
        dataset_.emplace_back(head->val);
        head = head->next;
      }
    }

    int getRandom() {
      mt19937_64 rng(rd());
      uniform_int_distribution<> dist(0, dataset_.size() - 1);
      return dataset_.at(dist(rng));
    }
  };

  class Solution *solution;
};
