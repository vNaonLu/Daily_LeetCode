
#ifndef LEETCODE_Q153_H__
#define LEETCODE_Q153_H__
#include <iostream>
#include <vector>

namespace l153 {
using namespace std;

/**
  * this file is generated by gquestion.py
  *
  * 153. Find Minimum in Rotated Sorted Array
  *
  * Suppose an array of length n sorted in ascending
  * order is “rotated“ between 1 and n times. For
  * example, the array nums = [0,1,2,4,5,6,7] might
  * become:
  * -  [4,5,6,7,0,1,2] if it was rotated 4 times.
  * -  [0,1,2,4,5,6,7] if it was rotated 7 times.
  * Notice that “rotating“ an array [a[0], a[1],
  * a[2], ..., a[n-1]] 1 time results in the array
  * [a[n-1], a[0], a[1], a[2], ..., a[n-2]] .
  * Given the sorted rotated array nums of “unique“
  * elements, return the minimum element of this array
  * .
  * You must write an algorithm that runs in O(log n)
  * time. 
  *
  * Constraints:
  * -  n == nums.length 
  * -  1 <= n <= 5000 
  * -  -5000 <= nums[i] <= 5000 
  * - All the integers of nums are “unique“ .
  * -  nums is sorted and rotated between 1 and n times.
  *
*/
class Solution {
 public:
  int findMin(vector<int>& nums) {
    int beg = 0, end = nums.size() - 1;
    if (nums[end] >= nums[beg])
      return nums[beg];
    else {
      while (beg <= end) {
        int mid = beg + (end - beg) / 2;
        if (mid + 1 < nums.size() && nums[mid] > nums[mid + 1]) return nums[mid + 1];
        if (mid - 1 >= 0 && nums[mid - 1] > nums[mid]) return nums[mid];
        if (nums[mid] > nums[0])
          beg = mid + 1;
        else
          end = mid - 1;
      }
      return -1;
    }
  }
};
}  // namespace l153
#endif