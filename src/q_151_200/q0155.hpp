
#ifndef LEETCODE_Q155_H__
#define LEETCODE_Q155_H__
#include <iostream>

namespace l155 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 155.
  *      Min Stack
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Design a stack that supports push, pop, top, and retrieving the
  *   minimum element in constant time.
  *   
  *   Implement the ‘MinStack’.
  *   
  *   - ‘MinStack()’ initializes the stack object.
  *   
  *   - ‘void push(int val)’ pushes the element ‘val’ onto the stack.
  *   
  *   - ‘void pop()’ removes the element on the top of the stack.
  *   
  *   - ‘int top()’ gets the top element of the stack.
  *   
  *   - ‘int getMin()’ retrieves the minimum element in the stack.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘-2³¹ ≤ val ≤ 2³¹ - 1’
  *   • Methods ‘pop’ , ‘top’ and ‘getMin’ operations will always be called on “non-empty” stacks.
  *   • At most ‘3 × 10⁴’ calls will be made to ‘push’ , ‘pop’ , ‘top’ , and ‘getMin’ .
  *
*/

class MinStack {
 private:
  pair<int, int> data[30001];
  int it;

 public:
  MinStack() {
    it = -1;
  }

  inline void push(int val) {
    int m = numeric_limits<int>::max();
    if (it >= 0) {
      m = min(data[it].first, data[it].second);
    }
    data[++it] = make_pair(val, m);
  }

  inline void pop() {
    --it;
  }

  inline int top() {
    return data[it].first;
  }

  inline int getMin() {
    return min(data[it].first, data[it].second);
  }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
}  // namespace l155

#endif