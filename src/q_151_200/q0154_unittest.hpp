
#ifndef Q154_UNITTEST_H__
#define Q154_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0154.hpp"
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 154.
 *      Find Minimum in Rotated Sorted Array II
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Suppose an array of length ‘n’ sorted in ascending order is “rotated”
 *   between ‘1’ and ‘n’ times. For example, the array ‘nums =
 *   [0,1,4,4,5,6,7]’ might
 *       -  ‘[4,5,6,7,0,1,4]’ if it was rotated ‘4’
 *       -  ‘[0,1,4,4,5,6,7]’ if it was rotated ‘7’
 *   Notice that “rotating” an array ‘[a[0], a[1], a[2], ..., a[n-1]]’ 1
 *   time results in the array ‘[a[n-1], a[0], a[1], a[2], ..., a[n-2]]’
 *   Given the sorted rotated array ‘nums’ that may contain “duplicates” ,
 *   return “the minimum element of this array”
 *   You must decrease the overall operation steps as much as possible.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = nums.length’
 *   • ‘1 ≤ n ≤ 5000’
 *   • ‘-5000 ≤ nums[i] ≤ 5000’
 *   • ‘nums’ is sorted and rotated between ‘1’ and ‘n’ times.
 *
 */

TEST(q154, sample_input01) {
  l154::Solution solver;
  vector<int> nums = {1, 3, 5};
  int exp = 1;
  EXPECT_EQ(solver.findMin(nums), exp);
}

TEST(q154, sample_input02) {
  l154::Solution solver;
  vector<int> nums = {2, 2, 2, 0, 1};
  int exp = 0;
  EXPECT_EQ(solver.findMin(nums), exp);
}

#endif