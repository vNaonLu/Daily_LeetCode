#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 152.
 *      Maximum Product Subarray
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an integer array ‘nums’ , find a contiguous non-empty subarray
 *   within the array that has the largest product, and return “the
 *   product”
 *   The test cases are generated so that the answer will fit in a “32-bit”
 *   A “subarray” is a contiguous subsequence of the array.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ nums.length ≤ 2 × 10⁴’
 *   • ‘-10 ≤ nums[i] ≤ 10’
 *   • The product of any prefix or suffix of ‘nums’ is “guaranteed” to fit in a “32-bit” integer.
 *
 */

struct q152 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int maxProduct(vector<int>& nums) {
      int res = nums[0], prod = nums[0];
      for (int i = 1; i < nums.size(); ++i) {
        if (prod == 0) prod = 1;
        prod *= nums[i];
        res = max(res, prod);
      }
      prod = 1;
      for (int i = nums.size() - 1; i >= 0; --i) {
        if (prod == 0) prod = 1;
        prod *= nums[i];
        res = max(res, prod);
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q152, sample_input01) {
  solution = new Solution();
  vector<int> nums = {2, 3, -2, 4};
  int exp = 6;
  EXPECT_EQ(solution->maxProduct(nums), exp);
  delete solution;
}

TEST_F(q152, sample_input02) {
  solution = new Solution();
  vector<int> nums = {-2, 0, -1};
  int exp = 0;
  EXPECT_EQ(solution->maxProduct(nums), exp);
  delete solution;
}