
#ifndef Q191_UNITTEST_H__
#define Q191_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0191.hpp"
using namespace std;

/**
  * this file is generated by gquestion.py
  *
  * 191. Number of 1 Bits
  *
  * Write a function that takes an unsigned integer
  * and returns the number of ';1'; bits it has (also
  * known as the <a
  * href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank">Hamming
  * weight</a>).
  * “Note:“ 
  * - Note that in some languages, such as Java,
  * there is no unsigned integer type. In this case, the
  * input will be given as a signed integer type. It
  * should not affect your implementation, as the
  * integer';s internal binary representation is the same,
  * whether it is signed or unsigned.
  * - In Java, the compiler represents the signed
  * integers using <a
  * href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank">2';s
  * complement notation</a>. Therefore, in “Example 3“ , the
  * input represents the signed integer. -3 .
  *
  * Constraints:
  * - The input must be a “binary string“ of length 32 .
  *  “Follow up:“ If this function is called many times, how would you optimize it?
  *
*/

TEST(q191, sample_input01) {
  uint32_t n = 0b00000000000000000000000000001011;
  int exp = 3;
  l191::Solution solver;
  EXPECT_EQ(solver.hammingWeight(n), exp);
}

TEST(q191, sample_input02) {
  uint32_t n = 0b00000000000000000000000010000000;
  int exp = 1;
  l191::Solution solver;
  EXPECT_EQ(solver.hammingWeight(n), exp);
}

TEST(q191, sample_input03) {
  uint32_t n = 0b11111111111111111111111111111101;
  int exp = 31;
  l191::Solution solver;
  EXPECT_EQ(solver.hammingWeight(n), exp);
}

#endif