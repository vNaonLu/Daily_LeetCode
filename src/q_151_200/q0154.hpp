
#ifndef LEETCODE_Q154_H__
#define LEETCODE_Q154_H__
#include <iostream>
#include <vector>

namespace l154 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 154.
 *      Find Minimum in Rotated Sorted Array II
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Suppose an array of length ‘n’ sorted in ascending order is “rotated”
 *   between ‘1’ and ‘n’ times. For example, the array ‘nums =
 *   [0,1,4,4,5,6,7]’ might
 *       -  ‘[4,5,6,7,0,1,4]’ if it was rotated ‘4’
 *       -  ‘[0,1,4,4,5,6,7]’ if it was rotated ‘7’
 *   Notice that “rotating” an array ‘[a[0], a[1], a[2], ..., a[n-1]]’ 1
 *   time results in the array ‘[a[n-1], a[0], a[1], a[2], ..., a[n-2]]’
 *   Given the sorted rotated array ‘nums’ that may contain “duplicates” ,
 *   return “the minimum element of this array”
 *   You must decrease the overall operation steps as much as possible.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = nums.length’
 *   • ‘1 ≤ n ≤ 5000’
 *   • ‘-5000 ≤ nums[i] ≤ 5000’
 *   • ‘nums’ is sorted and rotated between ‘1’ and ‘n’ times.
 *
 */

class Solution {
 public:
  int findMin(vector<int>& nums) {
    int l = 0, r = nums.size() - 1;
    while (l < r) {
      int m = l + (r - l) / 2;

      if (nums[m] > nums[r]) {
        l = m + 1;
      } else if (nums[r] > nums[m]) {
        r = m;
      } else {
        --r;
      }
    }
    return nums[r];
  }
};
}  // namespace l154

#endif