
#ifndef Q153_UNITTEST_H__
#define Q153_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0153.hpp"
using namespace std;

/**
  * this file is generated by gquestion.py
  *
  * 153. Find Minimum in Rotated Sorted Array
  *
  * Suppose an array of length n sorted in ascending
  * order is “rotated“ between 1 and n times. For
  * example, the array nums = [0,1,2,4,5,6,7] might
  * become:
  * -  [4,5,6,7,0,1,2] if it was rotated 4 times.
  * -  [0,1,2,4,5,6,7] if it was rotated 7 times.
  * Notice that “rotating“ an array [a[0], a[1],
  * a[2], ..., a[n-1]] 1 time results in the array
  * [a[n-1], a[0], a[1], a[2], ..., a[n-2]] .
  * Given the sorted rotated array nums of “unique“
  * elements, return the minimum element of this array
  * .
  * You must write an algorithm that runs in O(log n)
  * time. 
  *
  * Constraints:
  * -  n == nums.length 
  * -  1 <= n <= 5000 
  * -  -5000 <= nums[i] <= 5000 
  * - All the integers of nums are “unique“ .
  * -  nums is sorted and rotated between 1 and n times.
  *
*/

TEST(q153, sample_input01) {
  vector<int> nums = {3, 4, 5, 1, 2};
  int exp = 1;
  l153::Solution solver;
  EXPECT_EQ(solver.findMin(nums), exp);
}

TEST(q153, sample_input02) {
  vector<int> nums = {4, 5, 6, 7, 0, 1, 2};
  int exp = 0;
  l153::Solution solver;
  EXPECT_EQ(solver.findMin(nums), exp);
}

TEST(q153, sample_input03) {
  vector<int> nums = {11, 13, 15, 17};
  int exp = 11;
  l153::Solution solver;
  EXPECT_EQ(solver.findMin(nums), exp);
}

#endif