
#ifndef LEETCODE_Q173_H__
#define LEETCODE_Q173_H__
#include <iostream>
#include <leetcode/treenode.hpp>

namespace l173 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 173.
  *      Binary Search Tree Iterator
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Implement the ‘BSTIterator’ class that represents an iterator over the
  *   “<a href="https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)"
  *   target="_blank">in-order traversal</a>” of a binary search tree.
  *   
  *   - ‘BSTIterator(TreeNode root)’ Initializes an object of the
  *   ‘BSTIterator’ class. The ‘root’ of the BST is given as part of the
  *   constructor. The pointer should be initialized to a non-existent
  *   number smaller than any element in the BST.
  *   
  *   - ‘boolean hasNext()’ Returns ‘true’ if there exists a number in the
  *   traversal to the right of the pointer, otherwise returns ‘false’.
  *   
  *   - ‘int next()’ Moves the pointer to the right, then returns the
  *   number at the pointer.
  *   
  *   Notice that by initializing the pointer to a non-existent smallest
  *   number, the first call to ‘next()’ will return the smallest element in
  *   the BST.
  *   
  *   You may assume that ‘next()’ calls will always be valid. That is,
  *   there will be at least a next number in the in-order traversal when
  *   ‘next()’ is called.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • The number of nodes in the tree is in the range ‘[1, 10⁵]’ .
  *   • ‘0 ≤ Node.val ≤ 10⁶’
  *   • At most ‘10⁵’ calls will be made to ‘hasNext’ , and ‘next’ .
  *   • Could you implement ‘next()’ and ‘hasNext()’ to run in average ‘O(1)’ time and use ‘O(h)’ memory, where ‘h’ is the height of the tree?
  *
*/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class BSTIterator {
 private:
  int index;
  vector<int> traverse;

  void traverseHelper(TreeNode* p) {
    if (p == nullptr) return;
    traverseHelper(p->left);
    traverse.push_back(p->val);
    traverseHelper(p->right);
  }

 public:
  BSTIterator(TreeNode* root) {
    index = -1;
    traverse.clear();
    traverseHelper(root);
  }

  int next() {
    return traverse[++index];
  }

  bool hasNext() {
    return index < (int)traverse.size() - 1;
  }
};

/**
 * Your BSTIterator object will be instantiated and called as such:
 * BSTIterator* obj = new BSTIterator(root);
 * int param_1 = obj->next();
 * bool param_2 = obj->hasNext();
 */
}  // namespace l173

#endif