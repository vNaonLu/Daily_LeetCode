#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 2359.
 *       Find Closest Node to Given Two Nodes
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given a “directed” graph of ‘n’ nodes numbered from ‘0’ to ‘n
 *   - 1’ , where each node has “at most one” outgoing
 *   The graph is represented with a given “0-indexed” array ‘edges’ of
 *   size ‘n’ , indicating that there is a directed edge from node ‘i’ to
 *   node ‘edges[i]’ . If there is no outgoing edge from ‘i’ , then
 *   ‘edges[i] = -1’
 *   You are also given two integers ‘node1’ and ‘node2’
 *   Return “the “index” of the node that can be reached from both ”
 *   ‘node1’ “ and ” ‘node2’ “, such that the “maximum” between the
 *   distance from ” ‘node1’ “ to that node, and from ” ‘node2’ “ to that
 *   node is “minimized” ” . If there are multiple answers, return the node
 *   with the “smallest” index, and if no possible answer exists, return
 *   ‘-1’
 *   Note that ‘edges’ may contain cycles.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = edges.length’
 *   • ‘2 ≤ n ≤ 10⁵’
 *   • ‘-1 ≤ edges[i] < n’
 *   • ‘edges[i] ≠ i’
 *   • ‘0 ≤ node1, node2 < n’
 *
 */

struct q2359 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    void dfs(vector<int> &e, int node, vector<int> &d, int dis = 0) {
      d[node] = dis;
      if (e[node] != -1 && d[e[node]] == numeric_limits<int>::max()) {
        dfs(e, e[node], d, dis + 1);
      }
    }

  public:
    int closestMeetingNode(vector<int> &edges, int node1, int node2) {
      int         n = edges.size();
      vector<int> dis1(n, numeric_limits<int>::max());
      vector<int> dis2(n, numeric_limits<int>::max());
      dfs(edges, node1, dis1);
      dfs(edges, node2, dis2);
      int ans = numeric_limits<int>::max();
      int res = -1;
      for (int i = 0; i < n; ++i) {
        if (max(dis1[i], dis2[i]) < ans) {
          ans = max(dis1[i], dis2[i]);
          res = i;
        }
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q2359, sample_input01) {
  solution          = new Solution();
  vector<int> edges = {2, 2, 3, -1};
  int         node1 = 0;
  int         node2 = 1;
  int         exp   = 2;
  int         act   = solution->closestMeetingNode(edges, node1, node2);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q2359, sample_input02) {
  solution          = new Solution();
  vector<int> edges = {1, 2, -1};
  int         node1 = 0;
  int         node2 = 2;
  int         exp   = 2;
  int         act   = solution->closestMeetingNode(edges, node1, node2);
  EXPECT_EQ(act, exp);
  delete solution;
}
