#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1609.
 *       Even Odd Tree
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   A binary tree is named “Even-Odd” if it meets the following
 *       - The root of the binary tree is at level index ‘0’ , its children
 *   are at level index ‘1’ , their children are at level index ‘2’ ,
 *       - For every “even-indexed” level, all nodes at the level have
 *   “odd” integer values in “strictly increasing” order (from left to
 *       - For every “odd-indexed” level, all nodes at the level have
 *   “even” integer values in “strictly decreasing” order (from left to
 *   Given the ‘root’ of a binary tree, “return ” ‘true’ “ if the binary
 *   tree is “Even-Odd” , otherwise return ” ‘false’ “.” 
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[1, 10⁵]’ .
 *   • ‘1 ≤ Node.val ≤ 10⁶’
 *
 */

struct q1609 : public ::testing::Test {
  // Leetcode answer here
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    void evaluate_tree(TreeNode *p, int level, vector<vector<int>> &memo) {
        if (p != nullptr) {
            if (level >= memo.size()) {
                memo.resize(level + 1);
            }
            
            memo[level].emplace_back(p->val);
            evaluate_tree(p->left, level + 1, memo);
            evaluate_tree(p->right, level + 1, memo);
        }
    }
    
    template <typename iterator>
    bool is_odd_increasing(iterator beg, iterator end) {
        if (beg != end) {
            auto next = beg+1;
            if ((*beg & 1) == 0) {
                return false;
            }
            
            while (next != end) {
                if ((*next & 1) == 0 || *next <= *beg) {
                    return false;
                }
                next = ++beg + 1;
            }
        }
        
        return true;
    }
    
    template <typename iterator>
    bool is_even_decreasing(iterator beg, iterator end) {
        if (beg != end) {
            auto next = beg+1;
            if ((*beg & 1) == 1) {
                return false;
            }
            
            while (next != end) {
                if ((*next & 1) == 1 || *next >= *beg) {
                    return false;
                }
                next = ++beg + 1;
            }
        }
        
        return true;
    }
    
public:
    bool isEvenOddTree(TreeNode* root) {
        vector<vector<int>> levels;
        evaluate_tree(root, 0, levels);
        
        for (int i=0; i<levels.size(); ++i) {
            auto &v = levels[i];
            if ((i & 1) == 0) {
                if (!is_odd_increasing(v.begin(), v.end())) {
                    
                    return false;
                }
            } else {
                if (!is_even_decreasing(v.begin(), v.end())) {
                    
                    return false;
                }
            }
        }
        
        return true;
    }
};

  class Solution *solution;
};

TEST_F(q1609, sample_input01) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1, 10, 4, 3, NULL_TREENODE, 7, 9, 12, 8, 6, NULL_TREENODE, NULL_TREENODE, 2});
  bool exp = true;
  bool act = solution->isEvenOddTree(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}

TEST_F(q1609, sample_input02) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({5, 4, 2, 3, 3, 7});
  bool exp = false;
  bool act = solution->isEvenOddTree(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}

TEST_F(q1609, sample_input03) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({5, 9, 1, 3, 5, 7});
  bool exp = false;
  bool act = solution->isEvenOddTree(root);
  EXPECT_EQ(act, exp);
  TreeNode::release(root);
  delete solution;
}