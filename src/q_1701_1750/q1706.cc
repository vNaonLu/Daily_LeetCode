#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1706.
 *       Where Will the Ball Fall
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You have a 2-D ‘grid’ of size ‘m x n’ representing a box, and you have
 *   ‘n’ balls. The box is open on the top and bottom
 *   Each cell in the box has a diagonal board spanning two corners of the
 *   cell that can redirect a ball to the right or to the
 *       - A board that redirects the ball to the right spans the top-left
 *   corner to the bottom-right corner and is represented in the grid as
 *   ‘1’
 *       - A board that redirects the ball to the left spans the top-right
 *   corner to the bottom-left corner and is represented in the grid as
 *   ‘-1’
 *   We drop one ball at the top of each column of the box. Each ball can
 *   get stuck in the box or fall out of the bottom. A ball gets stuck if
 *   it hits a 'V' shaped pattern between two boards or if a board
 *   redirects the ball into either wall of the
 *   Return “an array ” ‘answer’ “ of size ” ‘n’ “ where ” ‘answer[i]’ “ is
 *   the column that the ball falls out of at the bottom after dropping the
 *   ball from the ” ‘iᵗʰ’ “ column at the top, or ‘-1’ <em> if the ball
 *   gets stuck in the box” .</em>
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘m = grid.length’
 *   • ‘n = grid[i].length’
 *   • ‘1 ≤ m, n ≤ 100’
 *   • ‘grid[i][j]’ is ‘1’ or ‘-1’ .
 *
 */

struct q1706 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    vector<int> findBall(vector<vector<int>> &grid) {
      auto m   = grid.size();
      auto n   = grid.front().size();
      auto res = vector<int>(n, -1);
      auto beg = res.begin();
      while (beg != res.end()) {
        auto col = distance(res.begin(), beg);
        auto row = 0;
        while (row < m) {
          auto next_col = col + grid[row][col];
          if (next_col >= 0 && next_col < n &&
              grid[row][col] * grid[row][next_col] == 1) {
            col = next_col;
            ++row;
          } else {
            break;
          }
        }
        *beg++ = row == m ? col : -1;
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1706, sample_input01) {
  solution                 = new Solution();
  vector<vector<int>> grid = {
      { 1,  1,  1, -1, -1},
      { 1,  1,  1, -1, -1},
      {-1, -1, -1,  1,  1},
      { 1,  1,  1,  1, -1},
      {-1, -1, -1, -1, -1}
  };
  vector<int> exp = {1, -1, -1, -1, -1};
  vector<int> act = solution->findBall(grid);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1706, sample_input02) {
  solution                 = new Solution();
  vector<vector<int>> grid = {{-1}};
  vector<int>         exp  = {-1};
  vector<int>         act  = solution->findBall(grid);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1706, sample_input03) {
  solution                 = new Solution();
  vector<vector<int>> grid = {
      { 1,  1,  1,  1,  1,  1},
      {-1, -1, -1, -1, -1, -1},
      { 1,  1,  1,  1,  1,  1},
      {-1, -1, -1, -1, -1, -1}
  };
  vector<int> exp = {0, 1, 2, 3, 4, -1};
  vector<int> act = solution->findBall(grid);
  EXPECT_EQ(act, exp);
  delete solution;
}