#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1519.
 *       Number of Nodes in the Sub-Tree With the Same Label
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given a tree (i.e. a connected, undirected graph that has no
 *   cycles) consisting of ‘n’ nodes numbered from ‘0’ to ‘n - 1’ and
 *   exactly ‘n - 1’  ‘edges’ . The “root” of the tree is the node ‘0’ ,
 *   and each node of the tree has “a label” which is a lower-case
 *   character given in the string ‘labels’ (i.e. The node with the number
 *   ‘i’ has the label ‘labels[i]’
 *   The ‘edges’ array is given on the form ‘edges[i] = [aᵢ, bᵢ]’ , which
 *   means there is an edge between nodes ‘aᵢ’ and ‘bᵢ’ in the
 *   Return “an array of size ‘n’ ” where ‘ans[i]’ is the number of nodes
 *   in the subtree of the ‘iᵗʰ’ node which have the same label as node ‘i’
 *   A subtree of a tree ‘T’ is the tree consisting of a node in ‘T’ and
 *   all of its descendant nodes.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n ≤ 10⁵’
 *   • ‘edges.length = n - 1’
 *   • ‘edges[i].length = 2’
 *   • ‘0 ≤ aᵢ, bᵢ < n’
 *   • ‘aᵢ ≠ bᵢ’
 *   • ‘labels.length = n’
 *   • ‘labels’ is consisting of only of lowercase English letters.
 *
 */

struct q1519 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    vector<int> dfs(vector<vector<int>> &path, string &s, vector<int> &vis,
                    int idx, vector<int> &res) {
      vector<int> tmp(26);
      vis[idx] = 1;
      for (auto x : path[idx]) {
        if (!vis[x]) {
          auto children = dfs(path, s, vis, x, res);
          ++tmp[s[x] - 'a'];
          for (int i = 0; i < 26; ++i) {
            tmp[i] += children[i];
          }
        }
      }
      res[idx] += tmp[s[idx] - 'a'] + 1;
      return tmp;
    }

  public:
    vector<int> countSubTrees(int n, vector<vector<int>> &edges,
                              string labels) {
      vector<int>         res(n);
      vector<int>         vis(n);
      vector<vector<int>> path(n);
      for (auto &v : edges) {
        path[v[0]].emplace_back(v[1]);
        path[v[1]].emplace_back(v[0]);
      }
      dfs(path, labels, vis, 0, res);
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1519, sample_input01) {
  solution                  = new Solution();
  int                 n     = 7;
  vector<vector<int>> edges = {
      {0, 1},
      {0, 2},
      {1, 4},
      {1, 5},
      {2, 3},
      {2, 6}
  };
  string      labels = "abaedcd";
  vector<int> exp    = {2, 1, 1, 1, 1, 1, 1};
  vector<int> act    = solution->countSubTrees(n, edges, labels);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1519, sample_input02) {
  solution                  = new Solution();
  int                 n     = 4;
  vector<vector<int>> edges = {
      {0, 1},
      {1, 2},
      {0, 3}
  };
  string      labels = "bbbb";
  vector<int> exp    = {4, 2, 1, 1};
  vector<int> act    = solution->countSubTrees(n, edges, labels);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1519, sample_input03) {
  solution                  = new Solution();
  int                 n     = 5;
  vector<vector<int>> edges = {
      {0, 1},
      {0, 2},
      {1, 3},
      {0, 4}
  };
  string      labels = "aabab";
  vector<int> exp    = {3, 2, 1, 1, 1};
  vector<int> act    = solution->countSubTrees(n, edges, labels);
  EXPECT_EQ(act, exp);
  delete solution;
}
