#include <gtest/gtest.h>
#include <array>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1926.
 *       Nearest Exit from Entrance in Maze
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given an ‘m x n’ matrix ‘maze’ ( “0-indexed” ) with empty
 *   cells (represented as ‘'.'’ ) and walls (represented as ‘'+'’ ). You
 *   are also given the ‘entrance’ of the maze, where ‘entrance =
 *   [entrance⎽(row), entrance⎽(col)]’ denotes the row and column of the
 *   cell you are initially standing
 *   In one step, you can move one cell “up” , “down” , “left” , or “right”
 *   . You cannot step into a cell with a wall, and you cannot step outside
 *   the maze. Your goal is to find the “nearest exit” from the ‘entrance’
 *   . An “exit” is defined as an “empty cell” that is at the “border” of
 *   the ‘maze’ . The ‘entrance’ “does not count” as an
 *   Return “the “number of steps” in the shortest path from the ”
 *   ‘entrance’ “ to the nearest exit, or ” ‘-1’ “ if no such path exists” 
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘maze.length = m’
 *   • ‘maze[i].length = n’
 *   • ‘1 ≤ m, n ≤ 100’
 *   • ‘maze[i][j]’ is either ‘'.'’ or ‘'+'’ .
 *   • ‘entrance.length = 2’
 *   • ‘0 ≤ entrance⎽(row) < m’
 *   • ‘0 ≤ entrance⎽(col) < n’
 *   • ‘entrance’ will always be an empty cell.
 *
 */

struct q1926 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    int m, n;
    constexpr static array<int, 8> dir = {1, 0, 0, 1, -1, 0, 0, -1};

    inline bool is_valid(int x, int y) {
      return x >= 0 && x < m && y >= 0 && y < n;
    }

    inline bool is_bound(int x, int y) {
      return x == 0 || x == m - 1 || y == 0 || y == n - 1;
    }

   public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
      m = maze.size();
      n = maze[0].size();

      int                   res = 0;
      queue<pair<int, int>> q;
      q.emplace(entrance[0], entrance[1]);
      maze[q.front().first][q.front().second] = '+';

      while (!q.empty()) {
        auto temp = move(q);
        ++res;

        while (!temp.empty()) {
          auto [x, y] = temp.front();
          temp.pop();

          for (int i = 0; i < dir.size(); ++i) {
            int dx = x + dir[i],
                dy = y + dir[++i];

            if (is_valid(dx, dy) && maze[dx][dy] == '.') {
              if (is_bound(dx, dy)) {
                return res;
              } else {
                q.emplace(dx, dy);
                maze[dx][dy] = '+';
              }
            }
          }
        }
      }

      return -1;
    }
  };

  class Solution *solution;
};

TEST_F(q1926, sample_input01) {
  solution = new Solution();
  vector<vector<char>> maze = {{'+', '+', '.', '+'}, {'.', '.', '.', '+'}, {'+', '+', '+', '.'}};
  vector<int> entrance = {1, 2};
  int exp = 1;
  int act = solution->nearestExit(maze, entrance);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1926, sample_input02) {
  solution = new Solution();
  vector<vector<char>> maze = {{'+', '+', '+'}, {'.', '.', '.'}, {'+', '+', '+'}};
  vector<int> entrance = {1, 0};
  int exp = 2;
  int act = solution->nearestExit(maze, entrance);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1926, sample_input03) {
  solution = new Solution();
  vector<vector<char>> maze = {{'.', '+'}};
  vector<int> entrance = {0, 0};
  int exp = -1;
  int act = solution->nearestExit(maze, entrance);
  EXPECT_EQ(act, exp);
  delete solution;
}