#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>
#include <unordered_map>
#include <vector>

using namespace std;

/**
 * The file is generated by LeetCodeDailyTools
 *
 * 652.
 *      Find Duplicate Subtrees
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary tree, return all “duplicate subtrees”
 *   For each kind of duplicate subtrees, you only need to return the root
 *   node of any “one” of
 *   Two trees are “duplicate” if they have the “same structure” with the
 *   “same node values” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of the nodes in the tree will be in the range ‘[1, 5000]’
 *   • ‘-200 ≤ Node.val ≤ 200’
 *
 * see more details: https://leetcode.com/problems/find-duplicate-subtrees/
 */

struct q652 : public ::testing::Test {
  // Leetcode answer here

  class Solution {
  private:
    string findDuplicates(TreeNode *node, unordered_map<string, int> &frequency,
                          vector<TreeNode *> &result) {
      if (!node) {
        return "#";
      }

      string leftIdentifier  = findDuplicates(node->left, frequency, result);
      string rightIdentifier = findDuplicates(node->right, frequency, result);
      string identifier =
          to_string(node->val) + "," + leftIdentifier + "," + rightIdentifier;
      frequency[identifier]++;

      if (frequency[identifier] == 2) {
        result.push_back(node);
      }

      return identifier;
    }

  public:
    vector<TreeNode *> findDuplicateSubtrees(TreeNode *root) {
      unordered_map<string, int> frequency;
      vector<TreeNode *>         result;
      findDuplicates(root, frequency, result);
      return result;
    }
  };

  class Solution *solution;
};

TEST_F(q652, NOT_IMPLEMENT) { EXPECT_TRUE("NOT IMPLEMENT"); }
