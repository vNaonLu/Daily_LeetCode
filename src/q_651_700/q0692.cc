#include <gtest/gtest.h>
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 692.
 *      Top K Frequent Words
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an array of strings ‘words’ and an integer ‘k’ , return “the ”
 *   ‘k’ “ most frequent strings”
 *   Return the answer “sorted” by “the frequency” from highest to lowest.
 *   Sort the words with the same frequency by their “lexicographical
 *   order” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ words.length ≤ 500’
 *   • ‘1 ≤ words[i] ≤ 10’
 *   • ‘words[i]’ consists of lowercase English letters.
 *   • ‘k’ is in the range ‘[1, The number of “unique” words[i]]’
 *
 */

struct q692 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    vector<string> topKFrequent(vector<string> &words, int k) {
      unordered_map<string_view, int> cnt;
      vector<string> res;

      for (auto &s : words) {
        auto find = cnt.find(s);
        if (find == cnt.end()) {
          find = cnt.emplace(s, 1).first;
          res.emplace_back(s);
        } else {
          ++find->second;
        }
      }

      sort(res.begin(), res.end(), [&](auto &x, auto &y) {
        return cnt[x] > cnt[y] || (cnt[x] == cnt[y] && x < y);
      });

      res.resize(k);

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q692, sample_input01) {
  solution = new Solution();
  vector<string> words = {"i", "love", "leetcode", "i", "love", "coding"};
  int k = 2;
  vector<string> exp = {"i", "love"};
  vector<string> act = solution->topKFrequent(words, k);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q692, sample_input02) {
  solution = new Solution();
  vector<string> words = {"the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"};
  int k = 4;
  vector<string> exp = {"the", "is", "sunny", "day"};
  vector<string> act = solution->topKFrequent(words, k);
  EXPECT_EQ(act, exp);
  delete solution;
}