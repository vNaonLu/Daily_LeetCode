#include <gtest/gtest.h>
#include <iostream>
#include <stack>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 682.
 *      Baseball Game
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are keeping score for a baseball game with strange rules. The game
 *   consists of several rounds, where the scores of past rounds may affect
 *   future rounds'
 *   At the beginning of the game, you start with an empty record. You are
 *   given a list of strings ‘ops’ , where ‘ops[i]’ is the ‘iᵗʰ’ operation
 *   you must apply to the record and is one of the
 *       1. An integer ‘x’ - Record a new score of ‘x’
 *       2.  ‘'+'’ - Record a new score that is the sum of the previous two
 *   scores. It is guaranteed there will always be two previous
 *       3.  ‘'D'’ - Record a new score that is double the previous score.
 *   It is guaranteed there will always be a previous
 *       4.  ‘'C'’ - Invalidate the previous score, removing it from the
 *   record. It is guaranteed there will always be a previous
 *   Return “the sum of all the scores on the record” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ ops.length ≤ 1000’
 *   • ‘ops[i]’ is ‘'C'’ , ‘'D'’ , ‘'+'’ , or a string representing an integer in the range ‘[-3 × 10⁴, 3 × 10⁴]’ .
 *   • For operation ‘'+'’ , there will always be at least two previous scores on the record.
 *   • For operations ‘'C'’ and ‘'D'’ , there will always be at least one previous score on the record.
 *
 */

struct q682 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int calPoints(vector<string> &ops) {
      int sum = 0;
      stack<int> scores;

      for (auto &s : ops) {
        if (s == "D") {
          sum += scores.top() * 2;
          scores.emplace(scores.top() * 2);
        } else if (s == "C") {
          sum -= scores.top();
          scores.pop();
        } else if (s == "+") {
          auto x = scores.top();
          scores.pop();
          auto y = scores.top();
          scores.emplace(x);
          scores.emplace(x + y);
          sum += x + y;
        } else {
          auto x = stoi(s);
          sum += x;
          scores.emplace(x);
        }
      }

      return sum;
    }
  };

  class Solution *solution;
};

TEST_F(q682, sample_input01) {
  solution = new Solution();
  vector<string> ops = {"5", "2", "C", "D", "+"};
  int exp = 30;
  int act = solution->calPoints(ops);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q682, sample_input02) {
  solution = new Solution();
  vector<string> ops = {"5", "-2", "4", "C", "D", "9", "+", "+"};
  int exp = 27;
  int act = solution->calPoints(ops);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q682, sample_input03) {
  solution = new Solution();
  vector<string> ops = {"1"};
  int exp = 1;
  int act = solution->calPoints(ops);
  EXPECT_EQ(act, exp);
  delete solution;
}