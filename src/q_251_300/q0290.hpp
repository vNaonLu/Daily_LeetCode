
#ifndef LEETCODE_Q290_H__
#define LEETCODE_Q290_H__
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

namespace l290 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 290. Word Pattern
  * Given a pattern and a string s , find if s
  * follows the same pattern.
  * Here  “follow”  means a full match, such that
  * there is a bijection between a letter in pattern and
  * a  “non-empty”  word in s .
  *
  * Constraints:
  * -  1 <= pattern.length <= 300 
  * -  pattern contains only lower-case English letters.
  * -  1 <= s.length <= 3000 
  * -  s contains only lower-case English letters and spaces '; '; .
  * -  s “does not contain” any leading or trailing spaces.
  * - All the words in s are separated by a “single space” .
  *
*/
class Solution {
 public:
  bool wordPattern(string pattern, string s) {
    vector<string> words;
    for (int i = 0, l = 0; i < s.size(); ++i) {
      if (s[i] == ' ') {
        string word = s.substr(l, i - l);
        if (!word.empty()) words.push_back(word);
        l = i + 1;
      } else if (i == s.size() - 1) {
        string word = s.substr(l, i - l + 1);
        if (!word.empty()) words.push_back(word);
      }
    }

    if (pattern.size() != words.size()) return false;

    unordered_map<char, string> p2w;
    unordered_map<string, char> w2p;
    for (int i = 0; i < pattern.size(); ++i) {
      if ((p2w.count(pattern[i]) && p2w[pattern[i]] == words[i] &&
           w2p.count(words[i]) && w2p[words[i]] == pattern[i]) ||
          (!p2w.count(pattern[i]) && !w2p.count(words[i]))) {
        p2w[pattern[i]] = words[i];
        w2p[words[i]] = pattern[i];
      } else {
        return false;
      }
    }
    return true;
  }
};
}  // namespace l290
#endif