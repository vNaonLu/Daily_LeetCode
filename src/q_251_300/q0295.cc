#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 295.
 *      Find Median from Data Stream
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   The “median” is the middle value in an ordered integer list. If the
 *   size of the list is even, there is no middle value, and the median is
 *   the mean of the two middle
 *       - For example, for ‘arr = [2,3,4]’ , the median is ‘3’
 *       - For example, for ‘arr = [2,3]’ , the median is ‘(2 + 3) / 2 =
 *   2.5’
 *   Implement the MedianFinder
 *       -  ‘MedianFinder()’ initializes the ‘MedianFinder’
 *       -  ‘void addNum(int num)’ adds the integer ‘num’ from the data
 *   stream to the data
 *       -  ‘double findMedian()’ returns the median of all elements so
 *   far. Answers within ‘10⁻⁵’ of the actual answer will be accepted.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘-10⁵ ≤ num ≤ 10⁵’
 *   • There will be at least one element in the data structure before calling
 * ‘findMedian’ . • At most ‘5 × 10⁴’ calls will be made to ‘addNum’ and
 * ‘findMedian’ . • If all integer numbers from the stream are in the range ‘[0,
 * 100]’ , how would you optimize your solution? • If ‘99%’ of all integer
 * numbers from the stream are in the range ‘[0, 100]’ , how would you optimize
 * your solution?
 *
 */

struct q295 : public ::testing::Test {
  // Leetcode answer here
  class MedianFinder {
  private:
    priority_queue<int>                            max_heap_;
    priority_queue<int, vector<int>, greater<int>> min_heap_;

  public:
    MedianFinder() {}

    void addNum(int num) {
      if (max_heap_.empty() || (max_heap_.top() > num)) {
        max_heap_.emplace(num);
      } else {
        min_heap_.emplace(num);
      }

      if (max_heap_.size() > min_heap_.size() + 1) {
        min_heap_.emplace(max_heap_.top());
        max_heap_.pop();
      } else if (max_heap_.size() + 1 < min_heap_.size()) {
        max_heap_.emplace(min_heap_.top());
        min_heap_.pop();
      }
    }

    double findMedian() {
      if (max_heap_.size() == min_heap_.size()) {
        return max_heap_.empty() ? 0
                                 : (max_heap_.top() + min_heap_.top()) / 2.0;
      } else {
        return max_heap_.size() > min_heap_.size() ? max_heap_.top()
                                                   : min_heap_.top();
      }
    }
  };

  class MedianFinder *median_finder;
};

TEST_F(q295, sample_input01) {
  median_finder = new MedianFinder();
  median_finder->addNum(1);
  median_finder->addNum(2);
  EXPECT_DOUBLE_EQ(median_finder->findMedian(), 1.5);
  median_finder->addNum(3);
  EXPECT_DOUBLE_EQ(median_finder->findMedian(), 2.0);
  delete median_finder;
}