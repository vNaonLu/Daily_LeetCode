#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/anyorder.hpp>
#include <leetcode/treenode.hpp>
#include <string>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 257.
 *      Binary Tree Paths
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary tree, return “all root-to-leaf paths in
 *   “any order” ”
 *   A “leaf” is a node with no children.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[1, 100]’ .
 *   • ‘-100 ≤ Node.val ≤ 100’
 *
 */

struct q257 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    void helper(TreeNode *p, vector<string> &res, vector<int> &cur) {
      if (p == nullptr) return;
      cur.push_back(p->val);
      if (p->left == nullptr && p->right == nullptr) {
        string path = to_string(cur.front());
        for (int i = 1; i < cur.size(); ++i)
          path += "->" + to_string(cur[i]);
        res.push_back(path);
      }else{
        helper(p->left, res, cur);
        helper(p->right, res, cur);
      }
      cur.pop_back();
    }
   public:
    vector<string> binaryTreePaths(TreeNode *root) {
      vector<string> res;
      vector<int> tmp;
      helper(root, res, tmp);
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q257, sample_input01) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1, 2, 3, NULL_TREENODE, 5});
  vector<string> exp = {"1->2->5", "1->3"};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->binaryTreePaths(root), exp);
  delete solution;
}

TEST_F(q257, sample_input02) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({1});
  vector<string> exp = {"1"};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->binaryTreePaths(root), exp);
  delete solution;
}