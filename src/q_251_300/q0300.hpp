
#ifndef LEETCODE_Q300_H__
#define LEETCODE_Q300_H__
#include <algorithm>
#include <iostream>
#include <vector>

namespace l300 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 300.
  *      Longest Increasing Subsequence
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given an integer array ‘nums’ , return the length of the longest
  *   strictly increasing subsequence.
  *   
  *   A “subsequence” is a sequence that can be derived from an array by
  *   deleting some or no elements without changing the order of the
  *   remaining elements. For example, ‘[3,6,2,7]’ is a subsequence of the
  *   array ‘[0,3,1,6,2,2,7]’.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘1 ≤ nums.length ≤ 2500’
  *   • ‘-10⁴ ≤ nums[i] ≤ 10⁴’
  *
*/

class Solution {
 public:
  int lengthOfLIS(vector<int>& nums) {
    int res = 0;
    vector<int> piles(nums.size(), numeric_limits<int>::max());
    for (int i = 0; i < nums.size(); ++i) {
      int idx = lower_bound(piles.begin(), piles.end(), nums[i]) - piles.begin();
      piles[idx] = nums[i];
      res = max(res, idx + 1);
    }
    return res;
  }
};
}  // namespace l300

#endif