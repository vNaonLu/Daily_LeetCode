
#ifndef LEETCODE_Q782_H__
#define LEETCODE_Q782_H__
#include <cmath>
#include <iostream>
#include <vector>

namespace l782 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 782. Transform to Chessboard
  * You are given an n x n binary grid board . In
  * each move, you can swap any two rows with each other,
  * or any two columns with each other.
  * Return the minimum number of moves to transform
  * the board into a “chessboard board” . If the task
  * is impossible, return -1 .
  * A “chessboard board” is a board where no 0 's
  * and no 1 's are 4-directionally adjacent.
  *
  * Constraints:
  * -  n == board.length 
  * -  n == board[i].length 
  * -  2 <= n <= 30 
  * -  board[i][j] is either 0 or 1 .
  *
*/

class Solution {
 private:
  int isRawSame(const vector<vector<int>> &vec, const int &a, const int &b) {
    for (int col = 0; col < vec[a].size(); ++col) {
      if (vec[a][col] != vec[b][col]) {
        return false;
      }
    }
    return true;
  }

  int minSwap(const vector<int> &vec) {
    int ans1 = 0;
    int ans2 = 0;
    for (int i = 0; i < vec.size(); ++i) {
      if (vec[i] != i % 2) {
        ++ans1;
      }  // {0, 1, 0, 1, .....}
      if (vec[i] != (i + 1) % 2) {
        ++ans2;
      }  // {1, 0, 1, 0, .....}
    }

    if (ans1 % 2 != 0) {
      return ans2 / 2;
    } else if (ans2 % 2 != 0) {
      return ans1 / 2;
    } else {
      return min(ans1 / 2, ans2 / 2);
    }
  }

  int isValid(const vector<int> &vec) {
    int c1 = 0;
    int c2 = 0;
    for (const auto &v : vec) {
      v == 0 ? ++c1 : ++c2;
    }
    return abs(c1 - c2) <= 1;
  }

  int findRawDiff(const vector<vector<int>> &board, vector<int> &diffRaw, vector<int> &raw) {
    diffRaw.push_back(0);
    for (int i = 1; i < board.size(); ++i) {
      int d = 0;

      for (d = 0; d < diffRaw.size(); ++d) {
        if (isRawSame(board, i, diffRaw[d]))
          break;
      }

      if (d > 1) {
        return -1;
      } else if (d == diffRaw.size()) {
        diffRaw.push_back(i);
      }

      raw[i] = d;
    }

    return 1;
  }

 public:
  int movesToChessboard(vector<vector<int>> &board) {
    int n = board.size();

    vector<int> raw(n, 0), col(n, 0);
    vector<int> diffRaw, diffCol;

    if (findRawDiff(board, diffRaw, raw) == -1)
      return -1;

    vector<vector<int>> tBoard(n, vector<int>(n));
    for (int i = 0; i < board.size(); ++i) {
      for (int j = 0; j < board.size(); ++j) {
        tBoard[j][i] = board[i][j];
      }
    }

    if (findRawDiff(tBoard, diffCol, col) == -1)
      return -1;

    if (diffRaw.size() != 2 || diffCol.size() != 2 || !isValid(raw) || !isValid(col))
      return -1;

    return minSwap(raw) + minSwap(col);
  }
};
}  // namespace l782

#endif