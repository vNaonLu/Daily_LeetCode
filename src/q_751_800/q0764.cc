#include <gtest/gtest.h>
#include <iostream>
#include <unordered_map>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 764.
 *      Largest Plus Sign
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given an integer ‘n’ . You have an ‘n x n’ binary grid ‘grid’
 *   with all values initially ‘1’ 's except for some indices given in the
 *   array ‘mines’ . The ‘iᵗʰ’ element of the array ‘mines’ is defined as
 *   ‘mines[i] = [xᵢ, yᵢ]’ where ‘grid[xᵢ][yᵢ] = 0’
 *   Return “the order of the largest “axis-aligned” plus sign of ” 1 “'s
 *   contained in ” ‘grid’ . If there is none, return ‘0’
 *   An “axis-aligned plus sign” of ‘1’ 's of order ‘k’ has some center
 *   ‘grid[r][c] = 1’ along with four arms of length ‘k - 1’ going up,
 *   down, left, and right, and made of ‘1’ 's. Note that there could be
 *   ‘0’ 's or ‘1’ 's beyond the arms of the plus sign, only the relevant
 *   area of the plus sign is checked for ‘1’ 's.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n ≤ 500’
 *   • ‘1 ≤ mines.length ≤ 5000’
 *   • ‘0 ≤ xᵢ, yᵢ < n’
 *   • All the pairs ‘(xᵢ, yᵢ)’ are “unique” .
 *
 */

struct q764 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {
      unordered_map<int, bool> banned;
      vector<vector<int>> dp(n, vector<int>(n));
      for (vector<int> mine : mines) {
        banned.insert({mine[0] * n + mine[1], true});
      }
      int res = 0, count;
      for (int i = 0; i < n; ++i) {
        count = 0;
        for (int j = 0; j < n; ++j) {
          count = banned.count(i * n + j) ? 0 : count + 1;
          dp[i][j] = count;
        }
        count = 0;
        for (int j = n - 1; j > -1; --j) {
          count = banned.count(i * n + j) ? 0 : count + 1;
          dp[i][j] = min(dp[i][j], count);
        }
      }
      for (int i = 0; i < n; ++i) {
        count = 0;
        for (int j = 0; j < n; ++j) {
          count = banned.count(j * n + i) ? 0 : count + 1;
          dp[j][i] = min(dp[j][i], count);
        }
        count = 0;
        for (int j = n - 1; j > -1; --j) {
          count = banned.count(j * n + i) ? 0 : count + 1;
          dp[j][i] = min(dp[j][i], count);
          res = max(res, dp[j][i]);
        }
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q764, sample_input01) {
  solution = new Solution();
  int n = 5;
  vector<vector<int>> mines = {{4, 2}};
  int exp = 2;
  EXPECT_EQ(solution->orderOfLargestPlusSign(n, mines), exp);
  delete solution;
}

TEST_F(q764, sample_input02) {
  solution = new Solution();
  int n = 1;
  vector<vector<int>> mines = {{0, 0}};
  int exp = 0;
  EXPECT_EQ(solution->orderOfLargestPlusSign(n, mines), exp);
  delete solution;
}