#include <gtest/gtest.h>
#include <iostream>
#include <queue>
#include <string>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 752.
 *      Open the Lock
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You have a lock in front of you with 4 circular wheels. Each wheel has
 *   10 slots: ‘'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'’ . The
 *   wheels can rotate freely and wrap around: for example we can turn
 *   ‘'9'’ to be ‘'0'’ , or ‘'0'’ to be ‘'9'’ . Each move consists of
 *   turning one wheel one
 *   The lock initially starts at ‘'0000'’ , a string representing the
 *   state of the 4
 *   You are given a list of ‘deadends’ dead ends, meaning if the lock
 *   displays any of these codes, the wheels of the lock will stop turning
 *   and you will be unable to open
 *   Given a ‘target’ representing the value of the wheels that will unlock
 *   the lock, return the minimum total number of turns required to open
 *   the lock, or -1 if it is impossible.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ deadends.length ≤ 500’
 *   • ‘deadends[i].length = 4’
 *   • ‘target.length = 4’
 *   • target “will not be” in the list ‘deadends’ .
 *   • ‘target’ and ‘deadends[i]’ consist of digits only.
 *
 */

struct q752 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    unordered_set<int> dends;
    unordered_set<int> memos;
    inline int encode(uint8_t (&n)[4]) noexcept {
      int *res = reinterpret_cast<int *>(n);
      return *res;
    }
    inline int encode(const string &s) noexcept {
      uint8_t temp[4];
      for (int i = 0; i < 4; ++i) temp[i] = s[i] - '0';
      return encode(temp);
    }
    inline void decode(int n, uint8_t (&out)[4]) noexcept {
      uint8_t *temp = reinterpret_cast<uint8_t *>(&n);
      memcpy(out, temp, 4);
    }
    inline bool check(int n) noexcept {
      return memos.find(n) == memos.end() && dends.find(n) == dends.end();
    }
   public:
    int openLock(vector<string> &deadends, string target) {
      int        t = encode(target);
      int        res = 0;
      queue<int> step;
      for (const auto &s : deadends) {
        int code = encode(s);
        if (code == 0) return -1;
        dends.insert(code);
      }
      step.push(0);
      memos.insert(0);
      while (true != step.empty()) {
        queue<int> curr;
        swap(curr, step);
        while (true != curr.empty()) {
          uint8_t lock[4];
          decode(curr.front(), lock);
          if (curr.front() == t) return res;
          curr.pop();
          /// turn once
          for (int i = 0; i < 4; ++i) {
            uint8_t old = lock[i];
            lock[i] = old == 9 ? 0 : old + 1;
            int frward = encode(lock);
            lock[i] = old == 0 ? 9 : old - 1;
            int bkward = encode(lock);
            lock[i] = old;
            if (check(frward)) {
              memos.insert(frward);
              step.push(frward);
            }
            if (check(bkward)) {
              memos.insert(bkward);
              step.push(bkward);
            }
          }
        }
        ++res;
      }
      return -1;
    }
  };

  class Solution *solution;
};

TEST_F(q752, sample_input01) {
  solution = new Solution();
  vector<string> deadends = {"0201", "0101", "0102", "1212", "2002"};
  string target = "0202";
  int exp = 6;
  int act = solution->openLock(deadends, target);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q752, sample_input02) {
  solution = new Solution();
  vector<string> deadends = {"8888"};
  string target = "0009";
  int exp = 1;
  int act = solution->openLock(deadends, target);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q752, sample_input03) {
  solution = new Solution();
  vector<string> deadends = {"8887", "8889", "8878", "8898", "8788", "8988", "7888", "9888"};
  string target = "8888";
  int exp = -1;
  int act = solution->openLock(deadends, target);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q752, input01) {
  solution = new Solution();
  vector<string> deadends = {"0000"};
  string target = "8888";
  int exp = -1;
  int act = solution->openLock(deadends, target);
  EXPECT_EQ(act, exp);
  delete solution;
}