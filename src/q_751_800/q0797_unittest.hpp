
#ifndef Q797_UNITTEST_H__
#define Q797_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0797.hpp"
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 797. All Paths From Source to Target
  * Given a directed acyclic graph ( “DAG” ) of n
  * nodes labeled from 0 to n - 1 , find all possible
  * paths from node 0 to node n - 1 and return them in
  * “any order” .
  * The graph is given as follows: graph[i] is a list
  * of all nodes you can visit from node i (i.e.,
  * there is a directed edge from node i to node
  * graph[i][j] ).
  *
  * Constraints:
  * -  n == graph.length 
  * -  2 <= n <= 15 
  * -  0 <= graph[i][j] < n 
  * -  graph[i][j] != i (i.e., there will be no self-loops).
  * - All the elements of graph[i] are “unique” .
  * - The input graph is “guaranteed” to be a “DAG” .
  *
*/

TEST(q797, sample_input01) {
  l797::Solution solver;
  vector<vector<int>> graph = {{1, 2}, {3}, {3}, {}};
  vector<vector<int>> exp = {{0, 1, 3}, {0, 2, 3}};
  EXPECT_EQ(solver.allPathsSourceTarget(graph), exp);
}

TEST(q797, sample_input02) {
  l797::Solution solver;
  vector<vector<int>> graph = {{4, 3, 1}, {3, 2, 4}, {3}, {4}, {}};
  vector<vector<int>> exp = {{0, 4}, {0, 3, 4}, {0, 1, 3, 4}, {0, 1, 2, 3, 4}, {0, 1, 4}};
  EXPECT_EQ(solver.allPathsSourceTarget(graph), exp);
}

TEST(q797, sample_input03) {
  l797::Solution solver;
  vector<vector<int>> graph = {{1}, {}};
  vector<vector<int>> exp = {{0, 1}};
  EXPECT_EQ(solver.allPathsSourceTarget(graph), exp);
}

TEST(q797, sample_input04) {
  l797::Solution solver;
  vector<vector<int>> graph = {{1, 2, 3}, {2}, {3}, {}};
  vector<vector<int>> exp = {{0, 1, 2, 3}, {0, 2, 3}, {0, 3}};
  EXPECT_EQ(solver.allPathsSourceTarget(graph), exp);
}

#endif