#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/anyorder.hpp>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 797.
 *      All Paths From Source to Target
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a directed acyclic graph ( “DAG” ) of ‘n’ nodes labeled from ‘0’
 *   to ‘n - 1’ , find all possible paths from node ‘0’ to node ‘n - 1’ and
 *   return them in “any order”
 *   The graph is given as follows: ‘graph[i]’ is a list of all nodes you
 *   can visit from node ‘i’ (i.e., there is a directed edge from node ‘i’
 *   to node ‘graph[i][j]’ ).
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = graph.length’
 *   • ‘2 ≤ n ≤ 15’
 *   • ‘0 ≤ graph[i][j] < n’
 *   • ‘graph[i][j] ≠ i’ (i.e., there will be no self-loops).
 *   • All the elements of ‘graph[i]’ are “unique” .
 *   • The input graph is “guaranteed” to be a “DAG” .
 *
 */

struct q797 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    void helper(vector<vector<int>> &graph, vector<vector<int>> &r, vector<int> &path, int target = 0) {
      path.push_back(target);
      if (target == graph.size() - 1) {
        r.push_back(path);
      } else {
        for (const int &dest : graph[target]) {
          if (find(path.begin(), path.end(), dest) == path.end())
            helper(graph, r, path, dest);
        }
      }
      path.pop_back();
    }
   public:
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>> &graph) {
      vector<vector<int>> res;
      vector<int> path;
      helper(graph, res, path);
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q797, sample_input01) {
  solution = new Solution();
  vector<vector<int>> graph = {{1, 2}, {3}, {3}, {}};
  vector<vector<int>> exp = {{0, 1, 3}, {0, 2, 3}};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->allPathsSourceTarget(graph), exp);
  delete solution;
}

TEST_F(q797, sample_input02) {
  solution = new Solution();
  vector<vector<int>> graph = {{4, 3, 1}, {3, 2, 4}, {3}, {4}, {}};
  vector<vector<int>> exp = {{0, 4}, {0, 3, 4}, {0, 1, 3, 4}, {0, 1, 2, 3, 4}, {0, 1, 4}};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->allPathsSourceTarget(graph), exp);
  delete solution;
}

TEST_F(q797, sample_input03) {
  solution = new Solution();
  vector<vector<int>> graph = {{1}, {}};
  vector<vector<int>> exp = {{0, 1}};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->allPathsSourceTarget(graph), exp);
  delete solution;
}

TEST_F(q797, sample_input04) {
  solution = new Solution();
  vector<vector<int>> graph = {{1, 2, 3}, {2}, {3}, {}};
  vector<vector<int>> exp = {{0, 1, 2, 3}, {0, 2, 3}, {0, 3}};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->allPathsSourceTarget(graph), exp);
  delete solution;
}

TEST_F(q797, sample_input05) {
  solution = new Solution();
  vector<vector<int>> graph = {{1, 3}, {2}, {3}, {}};
  vector<vector<int>> exp = {{0, 1, 2, 3}, {0, 3}};
  // Try EXPECT_EQ_ANY_ORDER_RECURSIVE
  // if the element is also matched in any order.
  EXPECT_EQ_ANY_ORDER(solution->allPathsSourceTarget(graph), exp);
  delete solution;
}