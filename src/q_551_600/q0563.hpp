
#ifndef LEETCODE_Q563_H__
#define LEETCODE_Q563_H__
#include <iostream>
#include <leetcode/treenode.hpp>

namespace l563 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 563.
 *      Binary Tree Tilt
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary tree, return “the sum of every tree
 *   node's “tilt” .”
 *   The “tilt” of a tree node is the “absolute difference” between the sum
 *   of all left subtree node “values” and all right subtree node “values”
 *   . If a node does not have a left child, then the sum of the left
 *   subtree node “values” is treated as ‘0’ . The rule is similar if there
 *   the node does not have a right child.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[0, 10⁴]’ .
 *   • ‘-1000 ≤ Node.val ≤ 1000’
 *
 */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
 private:
  int helper(TreeNode *p, int &res) {
    if (nullptr == p) return 0;
    int L = helper(p->left, res),
        R = helper(p->right, res);
    res += abs(L - R);
    return p->val + L + R;
  }

 public:
  int findTilt(TreeNode *root) {
    int res = 0;
    helper(root, res);
    return res;
  }
};
}  // namespace l563

#endif