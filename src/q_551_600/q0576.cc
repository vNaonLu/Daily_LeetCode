#include <gtest/gtest.h>
#include <iostream>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 576.
 *      Out of Boundary Paths
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   There is an ‘m x n’ grid with a ball. The ball is initially at the
 *   position ‘[startRow, startColumn]’ . You are allowed to move the ball
 *   to one of the four adjacent cells in the grid (possibly out of the
 *   grid crossing the grid boundary). You can apply “at most” ‘maxMove’
 *   moves to the
 *   Given the five integers ‘m’ , ‘n’ , ‘maxMove’ , ‘startRow’ ,
 *   ‘startColumn’ , return the number of paths to move the ball out of the
 *   grid boundary. Since the answer can be very large, return it “modulo”
 *   ‘10⁹ + 7’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ m, n ≤ 50’
 *   • ‘0 ≤ maxMove ≤ 50’
 *   • ‘0 ≤ startRow < m’
 *   • ‘0 ≤ startColumn < n’
 *
 */

struct q576 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    constexpr static int kMod = 1e9 + 7;

  public:
    int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
      int res = 0;
      vector<vector<long>> dp(m, vector<long>(n, 0));
      dp[startRow][startColumn] = 1;
      for (int step = 0; step < maxMove; ++step) {
        vector<vector<long>> tmp(m, vector<long>(n));

        for (int i = 0; i < m; ++i) {
          for (int j = 0; j < n; ++j) {
            if (i == m - 1) {
              res += dp[i][j];
              res %= kMod;
            }
            if (j == n - 1) {
              res += dp[i][j];
              res %= kMod;
            }
            if (i == 0) {
              res += dp[i][j];
              res %= kMod;
            }
            if (j == 0) {
              res += dp[i][j];
              res %= kMod;
            }

            tmp[i][j] = (i > 0 ? dp[i - 1][j] : 0) + (i < m - 1 ? dp[i + 1][j] : 0) % kMod;
            tmp[i][j] += (j > 0 ? dp[i][j - 1] : 0) + (j < n - 1 ? dp[i][j + 1] : 0) % kMod;
            tmp[i][j] %= kMod;
          }
        }

        dp = move(tmp);
      }

      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q576, sample_input01) {
  solution = new Solution();
  int m = 2;
  int n = 2;
  int maxMove = 2;
  int startRow = 0;
  int startColumn = 0;
  int exp = 6;
  int act = solution->findPaths(m, n, maxMove, startRow, startColumn);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q576, sample_input02) {
  solution = new Solution();
  int m = 1;
  int n = 3;
  int maxMove = 3;
  int startRow = 0;
  int startColumn = 1;
  int exp = 12;
  int act = solution->findPaths(m, n, maxMove, startRow, startColumn);
  EXPECT_EQ(act, exp);
  delete solution;
}