
#ifndef LEETCODE_Q221_H__
#define LEETCODE_Q221_H__
#include <iostream>
#include <vector>

namespace l221 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 221.
 *      Maximal Square
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an ‘m x n’ binary ‘matrix’ filled with ‘0’ 's and ‘1’ 's, “find
 *   the largest square containing only” ‘1’ 's “and return its area” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘m = matrix.length’
 *   • ‘n = matrix[i].length’
 *   • ‘1 ≤ m, n ≤ 300’
 *   • ‘matrix[i][j]’ is ‘'0'’ or ‘'1'’ .
 *
 */

class Solution {
 public:
  int maximalSquare(vector<vector<char>>& matrix) {
    int m = matrix.size(),
        n = matrix[0].size();
    vector<vector<int>> dp(m, vector<int>(n, 0));

    int res = 0;
    for (int i = 0; i < m; ++i) {
      dp[i][0] = matrix[i][0] == '1' ? 1 : 0;
      res = max(res, dp[i][0]);
    }
    for (int i = 0; i < n; ++i) {
      dp[0][i] = matrix[0][i] == '1' ? 1 : 0;
      res = max(res, dp[0][i]);
    }
    for (int i = 1; i < m; ++i) {
      for (int j = 1; j < n; ++j) {
        if (matrix[i][j] == '1') {
          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
          res = max(res, dp[i][j]);
        }
      }
    }

    return res * res;
  }
};
}  // namespace l221

#endif