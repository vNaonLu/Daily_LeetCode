#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 222.
 *      Count Complete Tree Nodes
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a “complete” binary tree, return the number of the
 *   nodes in the
 *   According to “<a
 *   href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees"
 *   target="_blank">Wikipedia</a>” , every level, except possibly the
 *   last, is completely filled in a complete binary tree, and all nodes in
 *   the last level are as far left as possible. It can have between ‘1’
 *   and ‘2ʰ’ nodes inclusive at the last level ‘h’
 *   Design an algorithm that runs in less than<code
 *   data-stringify-type="code">O(n)</code>time complexity.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[0, 5 × 10⁴]’ .
 *   • ‘0 ≤ Node.val ≤ 5 × 10⁴’
 *   • The tree is guaranteed to be “complete” .
 *
 */

struct q222 : public ::testing::Test {
  // Leetcode answer here
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  private:
    template <typename Op>
    int calcHeight(TreeNode *p, Op f) {
      if (p == nullptr) {
        return 0;
      } else {
        return 1 + calcHeight(f(p), f);
      }
    }

  public:
    int countNodes(TreeNode *root) {
      int lh = calcHeight(root, [](TreeNode *p) { return p->left; }),
          rh = calcHeight(root, [](TreeNode *p) { return p->right; });

      if (lh == rh) {
        return pow(2, lh) - 1;
      } else {
        return 1 + countNodes(root->left) + countNodes(root->right);
      }
    }
  };

  class Solution *solution;
};

TEST_F(q222, sample_input01) {
  solution = new Solution();
  TreeNode *root = TreeNode::generate({1, 2, 3, 4, 5, 6});
  int exp = 6;
  EXPECT_EQ(solution->countNodes(root), exp);
  delete solution;
}

TEST_F(q222, sample_input02) {
  solution = new Solution();
  TreeNode *root = TreeNode::generate({});
  int exp = 0;
  EXPECT_EQ(solution->countNodes(root), exp);
  delete solution;
}

TEST_F(q222, sample_input03) {
  solution = new Solution();
  TreeNode *root = TreeNode::generate({1});
  int exp = 1;
  EXPECT_EQ(solution->countNodes(root), exp);
  delete solution;
}