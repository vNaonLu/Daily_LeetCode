
#ifndef Q222_UNITTEST_H__
#define Q222_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0222.hpp"
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 222.
 *      Count Complete Tree Nodes
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a “complete” binary tree, return the number of the
 *   nodes in the
 *   According to “<a
 *   href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees"
 *   target="_blank">Wikipedia</a>” , every level, except possibly the
 *   last, is completely filled in a complete binary tree, and all nodes in
 *   the last level are as far left as possible. It can have between ‘1’
 *   and ‘2ʰ’ nodes inclusive at the last level ‘h’
 *   Design an algorithm that runs in less than<code
 *   data-stringify-type="code">O(n)</code>time complexity.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is in the range ‘[0, 5 × 10⁴]’ .
 *   • ‘0 ≤ Node.val ≤ 5 × 10⁴’
 *   • The tree is guaranteed to be “complete” .
 *
 */

TEST(q222, sample_input01) {
  l222::Solution solver;
  TreeNode* root = TreeNode::generate({1, 2, 3, 4, 5, 6});
  int exp = 6;
  EXPECT_EQ(solver.countNodes(root), exp);
}

TEST(q222, sample_input02) {
  l222::Solution solver;
  TreeNode* root = TreeNode::generate({});
  int exp = 0;
  EXPECT_EQ(solver.countNodes(root), exp);
}

TEST(q222, sample_input03) {
  l222::Solution solver;
  TreeNode* root = TreeNode::generate({1});
  int exp = 1;
  EXPECT_EQ(solver.countNodes(root), exp);
}

#endif