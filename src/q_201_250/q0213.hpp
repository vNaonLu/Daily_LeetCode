
#ifndef LEETCODE_Q213_H__
#define LEETCODE_Q213_H__
#include <algorithm>
#include <iostream>
#include <vector>

namespace l213 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 213.
  *      House Robber II
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   You are a professional robber planning to rob houses along a street.
  *   Each house has a certain amount of money stashed. All houses at this
  *   place are “arranged in a circle.” That means the first house is the
  *   neighbor of the last one. Meanwhile, adjacent houses have a security
  *   system connected, and “it will automatically contact the police if two
  *   adjacent houses were broken into on the same night”.
  *   
  *   Given an integer array ‘nums’ representing the amount of money of each
  *   house, return “the maximum amount of money you can rob tonight
  *   “without alerting the police” ”.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘1 ≤ nums.length ≤ 100’
  *   • ‘0 ≤ nums[i] ≤ 1000’
  *
*/

class Solution {
 private:
  int helper(vector<int>& prices) {
    if (prices.empty()) return 0;
    if (prices.size() == 1) return prices[0];
    vector<int> res(prices.size(), 0);
    res[0] = prices[0];
    res[1] = max(prices[1], prices[0]);
    for (int i = 2; i < prices.size(); ++i)
      res[i] = max(res[i - 1], res[i - 2] + prices[i]);
    return res.back();
  }

 public:
  int rob(vector<int>& nums) {
    if (nums.empty())
      return 0;
    else if (nums.size() == 1)
      return nums[0];
    vector<int> rob_first(nums.begin(), nums.end() - 1);
    vector<int> not_rob_first(nums.begin() + 1, nums.end());
    return max(helper(rob_first),
               helper(not_rob_first));
  }
};
}  // namespace l213

#endif