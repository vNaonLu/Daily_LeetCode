
#ifndef Q209_UNITTEST_H__
#define Q209_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0209.hpp"
using namespace std;

/**
  * this file is generated by gquestion.py
  *
  * 209. Minimum Size Subarray Sum
  * Given an array of positive integers nums and a
  * positive integer target , return the minimal length
  * of a “contiguous subarray“ [nums⎽(l), nums⎽(l+1),
  * ..., nums⎽(r-1), nums⎽(r)] of which the sum is
  * greater than or equal to target . If there is no such
  * subarray, return 0 instead.
  *
  * Constraints:
  * -  1 <= target <= 10^(9) 
  * -  1 <= nums.length <= 10^(5) 
  * -  1 <= nums[i] <= 10^(5) 
  *  “Follow up:“ If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)) .
  *
*/

TEST(q209, sample_input01) {
  int target = 7;
  vector<int> nums = {2, 3, 1, 2, 4, 3};
  int exp = 2;
  l209::Solution solver;
  EXPECT_EQ(solver.minSubArrayLen(target, nums), exp);
}

TEST(q209, sample_input02) {
  int target = 4;
  vector<int> nums = {1, 4, 4};
  int exp = 1;
  l209::Solution solver;
  EXPECT_EQ(solver.minSubArrayLen(target, nums), exp);
}

TEST(q209, sample_input03) {
  int target = 11;
  vector<int> nums = {1, 1, 1, 1, 1, 1, 1, 1};
  int exp = 0;
  l209::Solution solver;
  EXPECT_EQ(solver.minSubArrayLen(target, nums), exp);
}

TEST(q209, input01) {
  int target = 11;
  vector<int> nums = {1, 2, 3, 4, 5};
  int exp = 3;
  l209::Solution solver;
  EXPECT_EQ(solver.minSubArrayLen(target, nums), exp);
}

TEST(q209, input02) {
  int target = 15;
  vector<int> nums = {1, 2, 3, 4, 5};
  int exp = 5;
  l209::Solution solver;
  EXPECT_EQ(solver.minSubArrayLen(target, nums), exp);
}

#endif