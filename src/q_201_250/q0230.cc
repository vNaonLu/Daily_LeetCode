#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/treenode.hpp>
#include <stack>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 230.
 *      Kth Smallest Element in a BST
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given the ‘root’ of a binary search tree, and an integer ‘k’ , return
 *   “the” ‘kᵗʰ’ “smallest value ( “1-indexed” ) of all the values of the
 *   nodes in the tree” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the tree is ‘n’ .
 *   • ‘1 ≤ k ≤ n ≤ 10⁴’
 *   • ‘0 ≤ Node.val ≤ 10⁴’
 *
 */

struct q230 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int kthSmallest(TreeNode* root, int k) {
      stack<TreeNode*> traverse;
      while(true){
        while(root != nullptr){
          traverse.push(root);
          root = root->left;
        }
        root = traverse.top();
        traverse.pop();
        if (--k == 0) return root->val;
        root = root->right;
      }
    }
  };

  class Solution *solution;
};

TEST_F(q230, sample_input01) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({3, 1, 4, NULL_TREENODE, 2});
  int k = 1;
  int exp = 1;
  EXPECT_EQ(solution->kthSmallest(root, k), exp);
  delete solution;
}

TEST_F(q230, sample_input02) {
  solution = new Solution();
  TreeNode* root = TreeNode::generate({5, 3, 6, 2, 4, NULL_TREENODE, NULL_TREENODE, 1});
  int k = 3;
  int exp = 3;
  EXPECT_EQ(solution->kthSmallest(root, k), exp);
  delete solution;
}