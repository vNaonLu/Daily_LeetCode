#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1463.
 *       Cherry Pickup II
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given a ‘rows x cols’ matrix ‘grid’ representing a field of
 *   cherries where ‘grid[i][j]’ represents the number of cherries that you
 *   can collect from the ‘(i, j)’
 *   You have two robots that can collect cherries for
 *       -  “Robot #1” is located at the “top-left corner” ‘(0, 0)’ ,
 *       -  “Robot #2” is located at the “top-right corner” ‘(0, cols - 1)’
 *   Return “the maximum number of cherries collection using both robots by
 *   following the rules below”
 *       - From a cell ‘(i, j)’ , robots can move to cell ‘(i + 1, j - 1)’
 *   , ‘(i + 1, j)’ , or ‘(i + 1, j + 1)’
 *       - When any robot passes through a cell, It picks up all cherries,
 *   and the cell becomes an empty
 *       - When both robots stay in the same cell, only one takes the
 *       - Both robots cannot move outside of the grid at any
 *       - Both robots should reach the bottom row in ‘grid’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘rows = grid.length’
 *   • ‘cols = grid[i].length’
 *   • ‘2 ≤ rows, cols ≤ 70’
 *   • ‘0 ≤ grid[i][j] ≤ 100’
 *
 */

struct q1463 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    int m, n;
    vector<vector<int>> grid;
    vector<vector<vector<int>>> dpcache;
    int dp(int row, int col1, int col2) {
      if (col1 < 0 || col1 >= n || col2 < 0 || col2 >= n) return 0;
      if (dpcache[row][col1][col2] != -1) return dpcache[row][col1][col2];
      int res = 0;
      res += grid[row][col1];
      if (col1 != col2) res += grid[row][col2];
      if (row != m - 1) {
        int max_value = std::numeric_limits<int>::min();
        for (int new_col1 = col1 - 1; new_col1 <= col1 + 1; ++new_col1)
          for (int new_col2 = col2 - 1; new_col2 <= col2 + 1; ++new_col2)
            max_value = max(max_value, dp(row + 1, new_col1, new_col2));
        res += max_value;
      }
      dpcache[row][col1][col2] = res;
      return res;
    }

   public:
    int cherryPickup(vector<vector<int>>& grid) {
      this->grid = grid;
      m = grid.size(), n = grid[0].size();
      dpcache.clear();
      vector<vector<int>> tmp(n, vector<int>(n, -1));
      dpcache.resize(m, tmp);
      return dp(0, 0, n - 1);
    }
  };

  class Solution *solution;
};

TEST_F(q1463, sample_input01) {
  solution = new Solution();
  vector<vector<int>> grid = {{3, 1, 1}, {2, 5, 1}, {1, 5, 5}, {2, 1, 1}};
  int exp = 24;
  int act = solution->cherryPickup(grid);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1463, sample_input02) {
  solution = new Solution();
  vector<vector<int>> grid = {{1, 0, 0, 0, 0, 0, 1}, {2, 0, 0, 0, 0, 3, 0}, {2, 0, 9, 0, 0, 0, 0}, {0, 3, 0, 5, 4, 0, 0}, {1, 0, 2, 3, 0, 0, 6}};
  int exp = 28;
  int act = solution->cherryPickup(grid);
  EXPECT_EQ(act, exp);
  delete solution;
}