#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py v1.0
 *
 * 931.
 *      Minimum Falling Path Sum
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an ‘n x n’ array of integers ‘matrix’ , return “the “minimum
 *   sum” of any “falling path” through” ‘matrix’
 *   A “falling path” starts at any element in the first row and chooses
 *   the element in the next row that is either directly below or
 *   diagonally left/right. Specifically, the next element from position
 *   ‘(row, col)’ will be ‘(row + 1, col - 1)’ , ‘(row + 1, col)’ , or
 *   ‘(row + 1, col + 1)’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = matrix.length = matrix[i].length’
 *   • ‘1 ≤ n ≤ 100’
 *   • ‘-100 ≤ matrix[i][j] ≤ 100’
 *
 */

struct q931 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    vector<vector<int>> dp;
    int helper(const vector<vector<int>>& m, int col, int row) {
      if (row >= m.size()) return 0;
      if (dp[row][col] == numeric_limits<int>::max()) {
        if (col == 0) {
          dp[row][col] = m[row][col] + min(helper(m, col, row + 1), helper(m, col + 1, row + 1));
        } else if (col == m.size() - 1) {
          dp[row][col] = m[row][col] + min(helper(m, col - 1, row + 1), helper(m, col, row + 1));
        } else {
          dp[row][col] = m[row][col] + min({helper(m, col - 1, row + 1),
                                            helper(m, col, row + 1),
                                            helper(m, col + 1, row + 1)});
        }
      }
      return dp[row][col];
    }
   public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
      dp.resize(matrix.size(), vector<int>(matrix.size(),
                                           numeric_limits<int>::max()));
      int res = numeric_limits<int>::max();
      for (int i = 0; i < matrix.size(); ++i) {
        res = min(res, helper(matrix, i, 0));
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q931, sample_input01) {
  solution = new Solution();
  vector<vector<int>> matrix = {{2, 1, 3}, {6, 5, 4}, {7, 8, 9}};
  int exp = 13;
  EXPECT_EQ(solution->minFallingPathSum(matrix), exp);
  delete solution;
}

TEST_F(q931, sample_input02) {
  solution = new Solution();
  vector<vector<int>> matrix = {{-19, 57}, {-40, -5}};
  int exp = -59;
  EXPECT_EQ(solution->minFallingPathSum(matrix), exp);
  delete solution;
}