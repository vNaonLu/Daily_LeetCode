
#ifndef Q918_UNITTEST_H__
#define Q918_UNITTEST_H__
#include <gtest/gtest.h>

#include "q0918.hpp"
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 918.
  *      Maximum Sum Circular Subarray
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given a “circular integer array” ‘nums’ of length ‘n’ , return “the
  *   maximum possible sum of a non-empty “subarray” of ” ‘nums’
  *   A “circular array” means the end of the array connects to the
  *   beginning of the array. Formally, the next element of ‘nums[i]’ is
  *   ‘nums[(i + 1) % n]’ and the previous element of ‘nums[i]’ is ‘nums[(i
  *   - 1 + n) % n]’
  *   A “subarray” may only include each element of the fixed buffer ‘nums’
  *   at most once. Formally, for a subarray ‘nums[i], nums[i + 1], ...,
  *   nums[j]’ , there does not exist ‘i ≤ k1’ , ‘k2 ≤ j’ with ‘k1 % n = k2
  *   % n’ .
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘n = nums.length’
  *   • ‘1 ≤ n ≤ 3 × 10⁴’
  *   • ‘-3 × 10⁴ ≤ nums[i] ≤ 3 × 10⁴’
  *
*/

TEST(q918, sample_input01) {
  l918::Solution solver;
  vector<int> nums = {1, -2, 3, -2};
  int exp = 3;
  EXPECT_EQ(solver.maxSubarraySumCircular(nums), exp);
}

TEST(q918, sample_input02) {
  l918::Solution solver;
  vector<int> nums = {5, -3, 5};
  int exp = 10;
  EXPECT_EQ(solver.maxSubarraySumCircular(nums), exp);
}

TEST(q918, sample_input03) {
  l918::Solution solver;
  vector<int> nums = {3, -1, 2, -1};
  int exp = 4;
  EXPECT_EQ(solver.maxSubarraySumCircular(nums), exp);
}

TEST(q918, sample_input04) {
  l918::Solution solver;
  vector<int> nums = {3, -2, 2, -3};
  int exp = 3;
  EXPECT_EQ(solver.maxSubarraySumCircular(nums), exp);
}

TEST(q918, sample_input05) {
  l918::Solution solver;
  vector<int> nums = {-2, -3, -1};
  int exp = -1;
  EXPECT_EQ(solver.maxSubarraySumCircular(nums), exp);
}

#endif