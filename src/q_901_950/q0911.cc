#include <gtest/gtest.h>
#include <iostream>
#include <unordered_map>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 911.
 *      Online Election
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given two integer arrays ‘persons’ and ‘times’ . In an
 *   election, the ‘iᵗʰ’ vote was cast for ‘persons[i]’ at time ‘times[i]’
 *   For each query at a time ‘t’ , find the person that was leading the
 *   election at time ‘t’ . Votes cast at time ‘t’ will count towards our
 *   query. In the case of a tie, the most recent vote (among tied
 *   candidates)
 *   Implement the ‘TopVotedCandidate’
 *       -  ‘TopVotedCandidate(int[] persons, int[] times)’ Initializes the
 *   object with the ‘persons’ and ‘times’
 *       -  ‘int q(int t)’ Returns the number of the person that was
 *   leading the election at time ‘t’ according to the mentioned rules.
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ persons.length ≤ 5000’
 *   • ‘times.length = persons.length’
 *   • ‘0 ≤ persons[i] < persons.length’
 *   • ‘0 ≤ times[i] ≤ 10⁹’
 *   • ‘times’ is sorted in a strictly increasing order.
 *   • ‘times[0] ≤ t ≤ 10⁹’
 *   • At most ‘10⁴’ calls will be made to ‘q’ .
 *
 */

struct q911 : public ::testing::Test {
  // Leetcode answer here
  class TopVotedCandidate {
  private:
    vector<pair<int, int>> leading; // person, time
  public:
    TopVotedCandidate(vector<int> &persons, vector<int> &times) {
      auto cnt = unordered_map<int, int>();
      auto leader = -1;
      auto curr = 0;

      for (int i = 0; i < persons.size(); ++i) {
        auto p = persons[i];
        auto t = times[i];

        auto &c = ++cnt[p];

        if (c >= curr) {
          if (p != leader) {
            leader = p;
            leading.emplace_back(leader, t);
          }

          curr = c;
        }
      }
    }

    int q(int t) {
      auto find = upper_bound(leading.begin(), leading.end(), t, [](auto x, auto y) {
        return x < y.second;
      });

      return find == leading.begin() ? -1 : (*--find).first;
    }
  };

  /**
   * Your TopVotedCandidate object will be instantiated and called as such:
   * TopVotedCandidate* obj = new TopVotedCandidate(persons, times);
   * int param_1 = obj->q(t);
   */

  class TopVotedCandidate *top_voted_candidate;
};

TEST_F(q911, sample_input01) {
  vector<int> persons = {0, 1, 1, 0, 0, 1, 0};
  vector<int> times = {0, 5, 10, 15, 20, 25, 30};
  top_voted_candidate = new TopVotedCandidate(persons, times);
  EXPECT_EQ(top_voted_candidate->q(3), 0);
  EXPECT_EQ(top_voted_candidate->q(12), 1);
  EXPECT_EQ(top_voted_candidate->q(25), 1);
  EXPECT_EQ(top_voted_candidate->q(15), 0);
  EXPECT_EQ(top_voted_candidate->q(24), 0);
  EXPECT_EQ(top_voted_candidate->q(8), 1);
  delete top_voted_candidate;
}