#include <gtest/gtest.h>
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 947.
 *      Most Stones Removed with Same Row or Column
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   On a 2D plane, we place ‘n’ stones at some integer coordinate points.
 *   Each coordinate point may have at most one
 *   A stone can be removed if it shares either “the same row or the same
 *   column” as another stone that has not been
 *   Given an array ‘stones’ of length ‘n’ where ‘stones[i] = [xᵢ, yᵢ]’
 *   represents the location of the ‘iᵗʰ’ stone, return “the largest
 *   possible number of stones that can be removed” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ stones.length ≤ 1000’
 *   • ‘0 ≤ xᵢ, yᵢ ≤ 10⁴’
 *   • No two stones are at the same coordinate point.
 *
 */

struct q947 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  private:
    int dfs(unordered_map<int, vector<int>> &rows,
            unordered_map<int, vector<int>> &cols, unordered_set<int> &vrows,
            int row) {
      auto res = (int)0;
      if (vrows.emplace(row).second) {
        res += rows[row].size();
        for (auto c : rows[row]) {
          for (auto r : cols[c]) {
            res += dfs(rows, cols, vrows, r);
          }
        }
      }
      return res;
    }

  public:
    int removeStones(vector<vector<int>> &stones) {
      auto cols  = unordered_map<int, vector<int>>();
      auto rows  = unordered_map<int, vector<int>>();
      auto vrows = unordered_set<int>();
      auto res   = (int)0;
      for (auto &s : stones) {
        rows[s[0]].emplace_back(s[1]);
        cols[s[1]].emplace_back(s[0]);
      }
      for (auto &s : rows) {
        res += max(0, dfs(rows, cols, vrows, s.first) - 1);
      }
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q947, sample_input01) {
  solution                   = new Solution();
  vector<vector<int>> stones = {
      {0, 0},
      {0, 1},
      {1, 0},
      {1, 2},
      {2, 1},
      {2, 2}
  };
  int exp = 5;
  int act = solution->removeStones(stones);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q947, sample_input02) {
  solution                   = new Solution();
  vector<vector<int>> stones = {
      {0, 0},
      {0, 2},
      {1, 1},
      {2, 0},
      {2, 2}
  };
  int exp = 3;
  int act = solution->removeStones(stones);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q947, sample_input03) {
  solution                   = new Solution();
  vector<vector<int>> stones = {
      {0, 0}
  };
  int exp = 0;
  int act = solution->removeStones(stones);
  EXPECT_EQ(act, exp);
  delete solution;
}