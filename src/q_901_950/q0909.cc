#include <gtest/gtest.h>
#include <iostream>
#include <numeric>
#include <queue>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 909.
 *      Snakes and Ladders
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given an ‘n x n’ integer matrix ‘board’ where the cells are
 *   labeled from ‘1’ to ‘n²’ in a <a
 *   href="https://en.wikipedia.org/wiki/Boustrophedon" target="_blank">
 *   “Boustrophedon style” </a> starting from the bottom left of the board
 *   (i.e. ‘board[n - 1][0]’ ) and alternating direction each
 *   You start on square ‘1’ of the board. In each move, starting from
 *   square ‘curr’ , do the
 *       - Choose a destination square ‘next’ with a label in the range
 *   ‘[curr + 1, min(curr + 6, n²)]’
 *           - This choice simulates the result of a standard “6-sided die
 *   roll” : i.e., there are always at most 6 destinations, regardless of
 *   the size of the
 *
 *       - If ‘next’ has a snake or ladder, you “must” move to the
 *   destination of that snake or ladder. Otherwise, you move to ‘next’
 *       - The game ends when you reach the square ‘n²’
 *   A board square on row ‘r’ and column ‘c’ has a snake or ladder if
 *   ‘board[r][c] ≠ -1’ . The destination of that snake or ladder is
 *   ‘board[r][c]’ . Squares ‘1’ and ‘n²’ do not have a snake or
 *   Note that you only take a snake or ladder at most once per move. If
 *   the destination to a snake or ladder is the start of another snake or
 *   ladder, you do “not” follow the subsequentsnake or
 *       - For example, suppose the board is ‘[[-1,4],[-1,3]]’ , and on the
 *   first move, your destination square is ‘2’ . You follow the ladder to
 *   square ‘3’ , but do “not” follow the subsequent ladder to ‘4’
 *   Return “the least number of moves required to reach the square ” ‘n²’
 *   “. If it is not possible to reach the square, return ” ‘-1’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = board.length = board[i].length’
 *   • ‘2 ≤ n ≤ 20’
 *   • ‘grid[i][j]’ is either ‘-1’ or in the range ‘[1, n²]’ .
 *   • The squares labeled ‘1’ and ‘n²’ do not have any ladders or snakes.
 *
 */

struct q909 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
  public:
    int snakesAndLadders(vector<vector<int>> &board) {
      int                    n     = board.size();
      int                    label = 1;
      vector<pair<int, int>> cell(n * n + 1);
      vector<int>            cols(n);
      iota(cols.begin(), cols.end(), 0);
      for (int i = n - 1; i >= 0; --i) {
        for (auto c : cols) {
          cell[label++] = {i, c};
        }
        reverse(cols.begin(), cols.end());
      }
      vector<int> dp(n * n + 1, -1);
      queue<int>  q;
      dp[1] = 0;
      q.emplace(1);
      while (!q.empty()) {
        auto curr = q.front();
        q.pop();
        for (int i = curr + 1; i <= min(curr + 6, n * n); ++i) {
          auto [r, c] = cell[i];
          int dest    = board[r][c] != -1 ? board[r][c] : i;
          if (dp[dest] == -1) {
            dp[dest] = dp[curr] + 1;
            q.emplace(dest);
          }
        }
      }
      return dp.back();
    }
  };

  class Solution *solution;
};

TEST_F(q909, sample_input01) {
  solution                  = new Solution();
  vector<vector<int>> board = {
      {-1, -1, -1, -1, -1, -1},
      {-1, -1, -1, -1, -1, -1},
      {-1, -1, -1, -1, -1, -1},
      {-1, 35, -1, -1, 13, -1},
      {-1, -1, -1, -1, -1, -1},
      {-1, 15, -1, -1, -1, -1}
  };
  int exp = 4;
  int act = solution->snakesAndLadders(board);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q909, sample_input02) {
  solution                  = new Solution();
  vector<vector<int>> board = {
      {-1, -1},
      {-1,  3}
  };
  int exp = 1;
  int act = solution->snakesAndLadders(board);
  EXPECT_EQ(act, exp);
  delete solution;
}
