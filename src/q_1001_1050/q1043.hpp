
#ifndef LEETCODE_Q1043_H__
#define LEETCODE_Q1043_H__
#include <iostream>
#include <vector>

namespace l1043 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1043.
 *       Partition Array for Maximum Sum
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given an integer array ‘arr’ , partition the array into (contiguous)
 *   subarrays of length “at most” ‘k’ . After partitioning, each subarray
 *   has their values changed to become the maximum value of that
 *   Return “the largest sum of the given array after partitioning. Test
 *   cases are generated so that the answer fits in a “32-bit” integer.”
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ arr.length ≤ 500’
 *   • ‘0 ≤ arr[i] ≤ 10⁹’
 *   • ‘1 ≤ k ≤ arr.length’
 *
 */

class Solution {
 public:
  int maxSumAfterPartitioning(vector<int>& arr, int k) {
    vector<int> dp(arr.size(), 0);
    dp.front() = arr.front();
    for (int i = 1; i < arr.size(); ++i) {
      int M = arr[i];
      for (int j = i; j > (i - k) && j >= 0; --j) {
        M = max(M, arr[j]);
        dp[i] = max(dp[i], M * (i - j + 1) + (j - 1 >= 0 ? dp[j - 1] : 0));
      }
    }
    return dp.back();
  }
};
}  // namespace l1043

#endif