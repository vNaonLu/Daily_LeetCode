
#ifndef LEETCODE_Q1008_H__
#define LEETCODE_Q1008_H__
#include <iostream>
#include <leetcode/treenode.hpp>
#include <limits>
#include <vector>

namespace l1008 {
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 1008.
  *       Construct Binary Search Tree from Preorder Traversal
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given an array of integers preorder, which represents the “preorder
  *   traversal” of a BST (i.e., “binary search tree” ), construct the tree
  *   and return “its root”.
  *   
  *   It is “guaranteed” that there is always possible to find a binary
  *   search tree with the given requirements for the given test cases.
  *   
  *   A “binary search tree” is a binary tree where for every node, any
  *   descendant of ‘Node.left’ has a value “strictly less than” ‘Node.val’
  *   , and any descendant of ‘Node.right’ has a value “strictly greater
  *   than” ‘Node.val’.
  *   
  *   A “preorder traversal” of a binary tree displays the value of the node
  *   first, then traverses ‘Node.left’ , then traverses ‘Node.right’.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘1 ≤ preorder.length ≤ 100’
  *   • ‘1 ≤ preorder[i] ≤ 10⁸’
  *   • All the values of ‘preorder’ are “unique” .
  *
*/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *   int val;
 *   TreeNode *left;
 *   TreeNode *right;
 *   TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *   TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *   TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
 private:
  TreeNode* build_tree(vector<int>& v, int &idx, int bound = numeric_limits<int>::max()) {
    if(idx == v.size() || v[idx] > bound) return nullptr;
    TreeNode* p = new TreeNode(v[idx++]);
    p->left = build_tree(v, idx, p->val);
    p->right = build_tree(v, idx, bound);
    return p;
  }

 public:
  TreeNode* bstFromPreorder(vector<int>& preorder) {
    int i = 0;
    return build_tree(preorder, i);
  }
};
}  // namespace l1008

#endif