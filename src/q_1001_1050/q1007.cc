#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1007.
 *       Minimum Domino Rotations For Equal Row
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   In a row of dominoes, ‘tops[i]’ and ‘bottoms[i]’ represent the top and
 *   bottom halves of the ‘iᵗʰ’ domino. (A domino is a tile with two
 *   numbers from 1 to 6 - one on each half of the
 *   We may rotate the ‘iᵗʰ’ domino, so that ‘tops[i]’ and ‘bottoms[i]’
 *   swap
 *   Return the minimum number of rotations so that all the values in
 *   ‘tops’ are the same, or all the values in ‘bottoms’ are the
 *   If it cannot be done, return ‘-1’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘2 ≤ tops.length ≤ 2 × 10⁴’
 *   • ‘bottoms.length = tops.length’
 *   • ‘1 ≤ tops[i], bottoms[i] ≤ 6’
 *
 */

struct q1007 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   public:
    int minDominoRotations(vector<int>& tops, vector<int>& bottoms) {
      int res = numeric_limits<int>::max(),
          n = tops.size();
      for (int i = 1; i <= 6; ++i) {
        int top_cnt = 0,
            bottom_cnt = 0;
        auto top_it = tops.begin(),
             bottom_it = bottoms.begin();
        while (top_it != tops.end() && bottom_it != bottoms.end()) {
          if (*top_it != i && *bottom_it != i) {
            break;
          } else if (*top_it != i) {
            ++top_cnt;
          } else if (*bottom_it != i) {
            ++bottom_cnt;
          }
          ++top_it;
          ++bottom_it;
        }
        if (top_it != tops.end()) continue;

        res = min({res, top_cnt, bottom_cnt});
      }
      return res == numeric_limits<int>::max() ? -1 : res;
    }
  };

  class Solution *solution;
};

TEST_F(q1007, sample_input01) {
  solution = new Solution();
  vector<int> tops = {2, 1, 2, 4, 2, 2};
  vector<int> bottoms = {5, 2, 6, 2, 3, 2};
  int exp = 2;
  int act = solution->minDominoRotations(tops, bottoms);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1007, sample_input02) {
  solution = new Solution();
  vector<int> tops = {3, 5, 1, 2, 3};
  vector<int> bottoms = {3, 6, 3, 3, 4};
  int exp = -1;
  int act = solution->minDominoRotations(tops, bottoms);
  EXPECT_EQ(act, exp);
  delete solution;
}