#include <gtest/gtest.h>
#include <iostream>
#include <leetcode/listnode.hpp>
#include <stack>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1019.
 *       Next Greater Node In Linked List
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given the ‘head’ of a linked list with ‘n’
 *   For each node in the list, find the value of the “next greater node” .
 *   That is, for each node, find the value of the first node that is next
 *   to it and has a “strictly larger” value than
 *   Return an integer array ‘answer’ where ‘answer[i]’ is the value of the
 *   next greater node of the ‘iᵗʰ’ node ( “1-indexed” ). If the ‘iᵗʰ’ node
 *   does not have a next greater node, set ‘answer[i] = 0’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • The number of nodes in the list is ‘n’ .
 *   • ‘1 ≤ n ≤ 10⁴’
 *   • ‘1 ≤ Node.val ≤ 10⁹’
 *
 */

struct q1019 : public ::testing::Test {
  // Leetcode answer here
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode() : val(0), next(nullptr) {}
   *     ListNode(int x) : val(x), next(nullptr) {}
   *     ListNode(int x, ListNode *next) : val(x), next(next) {}
   * };
   */
  class Solution {
   private:
    vector<int> res;
    stack<int>  stk;
    void helper(ListNode* p) {
      if (nullptr == p) return;

      helper(p->next);
      if (nullptr != p->next) {
        stk.push(p->next->val);
      }

      while (!stk.empty() && stk.top() <= p->val) {
        stk.pop();
      }

      if (stk.empty()) {
        res.push_back(0);
      } else {
        res.push_back(stk.top());
      }
    }

   public:
    vector<int> nextLargerNodes(ListNode* head) {
      helper(head);
      reverse(res.begin(), res.end());
      return res;
    }
  };

  class Solution *solution;
};

TEST_F(q1019, sample_input01) {
  solution = new Solution();
  ListNode* head = ListNode::generate({2, 1, 5});
  vector<int> exp = {5, 5, 0};
  vector<int> act = solution->nextLargerNodes(head);
  EXPECT_EQ(act, exp);
  ListNode::release(head);
  delete solution;
}

TEST_F(q1019, sample_input02) {
  solution = new Solution();
  ListNode* head = ListNode::generate({2, 7, 4, 3, 5});
  vector<int> exp = {7, 0, 5, 5, 0};
  vector<int> act = solution->nextLargerNodes(head);
  EXPECT_EQ(act, exp);
  ListNode::release(head);
  delete solution;
}