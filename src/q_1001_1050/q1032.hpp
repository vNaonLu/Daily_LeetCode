
#ifndef LEETCODE_Q1032_H__
#define LEETCODE_Q1032_H__
#include <iostream>
#include <optional>
#include <vector>

namespace l1032 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1032.
 *       Stream of Characters
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Design an algorithm that accepts a stream of characters and checks if
 *   a suffix of these characters is a string of a given array of strings
 *   ‘words’
 *   For example, if ‘words = ['abc', 'xyz']’ and the stream added the four
 *   characters (one by one) ‘'a'’ , ‘'x'’ , ‘'y'’ , and ‘'z'’ , your
 *   algorithm should detect that the suffix ‘'xyz'’ of the characters
 *   ‘'axyz'’ matches ‘'xyz'’ from ‘words’
 *   Implement the ‘StreamChecker’
 *       -  ‘StreamChecker(String[] words)’ Initializes the object with the
 *   strings array ‘words’
 *       -  ‘boolean query(char letter)’ Accepts a new character from the
 *   stream and returns ‘true’ if any non-empty suffix from the stream
 *   forms a word that is in ‘words’ .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ words.length ≤ 2000’
 *   • ‘1 ≤ words[i].length ≤ 2000’
 *   • ‘words[i]’ consists of lowercase English letters.
 *   • ‘letter’ is a lowercase English letter.
 *   • At most ‘4 × 10⁴’ calls will be made to query.
 *
 */

class StreamChecker {
 private:
  struct trie {
    vector<optional<trie>> next;
    bool is_end;
    trie() : is_end{false} {
      next.resize(26);
    }
  };

  trie _head;
  vector<char> _queries;
  size_t max_length{0};

 public:
  StreamChecker(vector<string> &words) {
    for (const auto &s : words) {
      auto *node = &_head;
      for (auto it = s.rbegin(); it != s.rend(); ++it) {
        int idx = *it - 'a';
        if (!node->next[idx])
          node->next[idx] = trie{};
        node = &node->next[idx].value();
      }
      node->is_end = true;
      max_length = max(max_length, s.size());
    }
  }

  bool query(char letter) {
    _queries.insert(_queries.begin(), letter);
    if (_queries.size() > max_length) _queries.pop_back();

    auto *node = &_head;
    for (auto it = _queries.begin(); it != _queries.end(); ++it) {
      if (node->is_end) return true;
      if (!node->next[*it - 'a']) return false;
      node = &node->next[*it - 'a'].value();
    }
    return node->is_end;
  }
};

/**
 * Your StreamChecker object will be instantiated and called as such:
 * StreamChecker* obj = new StreamChecker(words);
 * bool param_1 = obj->query(letter);
 */
}  // namespace l1032

#endif