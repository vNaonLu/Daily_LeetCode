
#ifndef Q1008_UNITTEST_H__
#define Q1008_UNITTEST_H__
#include <gtest/gtest.h>

#include "q1008.hpp"
using namespace std;

/**
  * This file is generated by leetcode_add.py
  *
  * 1008.
  *       Construct Binary Search Tree from Preorder Traversal
  *
  * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
  *
  *   Given an array of integers preorder, which represents the “preorder
  *   traversal” of a BST (i.e., “binary search tree” ), construct the tree
  *   and return “its root”.
  *   
  *   It is “guaranteed” that there is always possible to find a binary
  *   search tree with the given requirements for the given test cases.
  *   
  *   A “binary search tree” is a binary tree where for every node, any
  *   descendant of ‘Node.left’ has a value “strictly less than” ‘Node.val’
  *   , and any descendant of ‘Node.right’ has a value “strictly greater
  *   than” ‘Node.val’.
  *   
  *   A “preorder traversal” of a binary tree displays the value of the node
  *   first, then traverses ‘Node.left’ , then traverses ‘Node.right’.
  *
  * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
  *
  *   • ‘1 ≤ preorder.length ≤ 100’
  *   • ‘1 ≤ preorder[i] ≤ 10⁸’
  *   • All the values of ‘preorder’ are “unique” .
  *
*/

TEST(q1008, sample_input01) {
  l1008::Solution solver;
  vector<int> preorder = {8, 5, 1, 7, 10, 12};
  TreeNode* exp = TreeNode::generate({8, 5, 10, 1, 7, NULL_TREENODE, 12});
  EXPECT_TREENODE_EQ(solver.bstFromPreorder(preorder), exp);
}

TEST(q1008, sample_input02) {
  l1008::Solution solver;
  vector<int> preorder = {1, 3};
  TreeNode* exp = TreeNode::generate({1, NULL_TREENODE, 3});
  EXPECT_TREENODE_EQ(solver.bstFromPreorder(preorder), exp);
}

#endif