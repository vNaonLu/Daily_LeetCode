
#ifndef LEETCODE_Q1044_H__
#define LEETCODE_Q1044_H__
#include <iostream>
#include <queue>
#include <string>
#include <unordered_map>

namespace l1044 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1044.
 *       Longest Duplicate Substring
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   Given a string ‘s’ , consider all “duplicated substrings” :
 *   (contiguous) substrings of s that occur 2 or more times.The
 *   occurrencesmay
 *   Return “any” duplicatedsubstring that has the longest possible
 *   length.If ‘s’ does not have a duplicated substring, the answer is ‘''’
 *   .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘2 ≤ s.length ≤ 3 × 10⁴’
 *   • ‘s’ consists of lowercase English letters.
 *
 */

class Solution {
 public:
  string longestDupSubstring(string s) {
    int begin = 0, length = 0;
    int n = s.size();
    unordered_map<char, deque<int>> hash;
    for (int i = 0; i < n; ++i)
      hash[s[i]].emplace_back(i);
    for (int i = 0; i < n; ++i) {
      hash[s[i]].pop_front();
      for (auto it : hash[s[i]]) {
        int j = 0;
        while (i + j < n && it + j < n && s[i + j] == s[it + j]) ++j;
        if (j > length) {
          begin = i;
          length = j;
        }

        if (j == n - i - 1) return s.substr(begin, length);
      }
    }
    return length == 0 ? "" : s.substr(begin, length);
  }
};
}  // namespace l1044

#endif