
#ifndef LEETCODE_Q763_H__
#define LEETCODE_Q763_H__
#include <iostream>
#include <vector>
#include <unordered_map>

namespace l763 {
using namespace std;

/**
  * this file is generated by gquestion.py

  *
  * 763. Partition Labels
  *
  * You are given a string s . We want to partition
  * the string into as many parts as possible so that
  * each letter appears in at most one part.
  * Return a list of integers representing the size
  * of these parts .
  *
  * Constraints:
  * -  1 <= s.length <= 500 
  * -  s consists of lowercase English letters.
  *
*/
class Solution {
 public:
  int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {
    unordered_map<int, bool> banned;
    vector<vector<int>> dp(n, vector<int>(n));

    for (vector<int> mine : mines) {
      banned.insert({mine[0] * n + mine[1], true});
    }
    int res = 0, count;

    for (int i = 0; i < n; ++i) {
      count = 0;
      for (int j = 0; j < n; ++j) {
        count = banned.count(i * n + j) ? 0 : count + 1;
        dp[i][j] = count;
      }

      count = 0;
      for (int j = n - 1; j > -1; --j) {
        count = banned.count(i * n + j) ? 0 : count + 1;
        dp[i][j] = min(dp[i][j], count);
      }
    }

    for (int i = 0; i < n; ++i) {
      count = 0;
      for (int j = 0; j < n; ++j) {
        count = banned.count(j * n + i) ? 0 : count + 1;
        dp[j][i] = min(dp[j][i], count);
      }

      count = 0;
      for (int j = n - 1; j > -1; --j) {
        count = banned.count(j * n + i) ? 0 : count + 1;
        dp[j][i] = min(dp[j][i], count);
        res = max(res, dp[j][i]);
      }
    }

    return res;
  }
};
}  // namespace l763
#endif