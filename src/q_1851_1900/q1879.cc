#include <gtest/gtest.h>
#include <iostream>
#include <vector>

using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1879.
 *       Minimum XOR Sum of Two Arrays
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given two integer arrays ‘nums1’ and ‘nums2’ of length ‘n’
 *   The “XOR sum” of the two integer arrays is ‘(nums1[0] XOR nums2[0]) +
 *   (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1])’ (
 *   “0-indexed”
 *       - For example, the “XOR sum” of ‘[1,2,3]’ and ‘[3,2,1]’ is equal
 *   to ‘(1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4’
 *   Rearrange the elements of ‘nums2’ such that the resulting “XOR sum” is
 *   “minimized”
 *   Return “the “XOR sum” after the rearrangement” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘n = nums1.length’
 *   • ‘n = nums2.length’
 *   • ‘1 ≤ n ≤ 14’
 *   • ‘0 ≤ nums1[i], nums2[i] ≤ 10⁷’
 *
 */

struct q1879 : public ::testing::Test {
  // Leetcode answer here
  class Solution {
   private:
    vector<int>         n1, n2;
    vector<vector<int>> memos;
    int helper(int i, int v) {
      if (i == n1.size()) return 0;
      if (memos[i][v] != -1) return memos[i][v];
      int res = numeric_limits<int>::max();
      for (int j = 0; j < n2.size(); ++j) {
        if (!(v & (1 << j))) {
          auto nv = v | (1 << j);
          res = min(res, helper(i + 1, nv) + (n1[i] ^ n2[j]));
        }
      }
      return memos[i][v] = res;
    }

   public:
    int minimumXORSum(vector<int>& nums1, vector<int>& nums2) {
      n1 = nums1;
      n2 = nums2;
      memos.resize(n1.size(), vector<int>(1 << 15, -1));
      return helper(0, 0);
    }
  };

  class Solution *solution;
};

TEST_F(q1879, sample_input01) {
  solution = new Solution();
  vector<int> nums1 = {1, 2};
  vector<int> nums2 = {2, 3};
  int exp = 2;
  int act = solution->minimumXORSum(nums1, nums2);
  EXPECT_EQ(act, exp);
  delete solution;
}

TEST_F(q1879, sample_input02) {
  solution = new Solution();
  vector<int> nums1 = {1, 0, 3};
  vector<int> nums2 = {5, 3, 4};
  int exp = 8;
  int act = solution->minimumXORSum(nums1, nums2);
  EXPECT_EQ(act, exp);
  delete solution;
}