
#ifndef LEETCODE_Q1881_H__
#define LEETCODE_Q1881_H__
#include <iostream>
#include <string>

namespace l1881 {
using namespace std;

/**
 * This file is generated by leetcode_add.py
 *
 * 1881.
 *       Maximum Value after Insertion
 *
 * ––––––––––––––––––––––––––––– Description –––––––––––––––––––––––––––––
 *
 *   You are given a very large integer ‘n’ , represented as a
 *   string,​​​​​​ and an integer digit ‘x’ . The digits in ‘n’ and the
 *   digit ‘x’ are in the “inclusive” range ‘[1, 9]’ , and ‘n’ may
 *   represent a “negative”
 *   You want to “maximize ” ‘n’ “'s numerical value” by inserting ‘x’
 *   anywhere in the decimal representation of ‘n’ ​​​​​​. You “cannot”
 *   insert ‘x’ to the left of the negative
 *       - For example, if ‘n = 73’ and ‘x = 6’ , it would be best to
 *   insert it between ‘7’ and ‘3’ , making ‘n = 763’
 *       - If ‘n = -55’ and ‘x = 2’ , it would be best to insert it before
 *   the first ‘5’ , making ‘n = -255’
 *   Return “a string representing the “maximum” value of ” ‘n’ “​​​​​​
 *   after the insertion” .
 *
 * ––––––––––––––––––––––––––––– Constraints –––––––––––––––––––––––––––––
 *
 *   • ‘1 ≤ n.length ≤ 10⁵’
 *   • ‘1 ≤ x ≤ 9’
 *   • The digits in ‘n’ ​​​ are in the range ‘[1, 9]’ .
 *   • ‘n’ is a valid representation of an integer.
 *   • In the case of a negative ‘n’ ,​​​​​​ it will begin with ‘'-'’ .
 *
 */

class Solution {
 private:
  string maxInsert(const string &s, const int &x) {
    string res = s;
    for (int i = 0; i < s.size(); ++i) {
      char c = x + '0';
      if (res[i] < c) {
        res.insert(i, 1, c);
        return res;
      }
    }
    res.push_back(x + '0');
    return res;
  }
  string minInsert(const string &s, const int &x) {
    string res = s;
    for (int i = 0; i < s.size(); ++i) {
      char c = x + '0';
      if (res[i] > c) {
        res.insert(i, 1, c);
        return res;
      }
    }
    res.push_back(x + '0');
    return res;
  }

 public:
  string maxValue(string n, int x) {
    if (n[0] == '-') {
      return "-" + minInsert(n.substr(1), x);
    } else {
      return maxInsert(n, x);
    }
  }
};
}  // namespace l1881

#endif