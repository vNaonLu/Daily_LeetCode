#!/usr/bin/python3
import os
import optparse
import pathlib
import subprocess
import time
from utils import prompt as pmt
from utils import local, modify, generate
from leetcode import request as LeetCodeRequest
from leetcode.question import LeetCodeQuestion


def __add_question(qfile: local.QuestionSource, testcase: bool):
    if os.path.exists(qfile.src()):
        pmt.show(pmt.fail(pmt.hi("The file has already exist: ") + str(qfile.src().resolve()), "!"))
        return False

    pmt.pending(pmt.hi("Requesting a slug with question id {}".format(qfile.id())))
    slug = LeetCodeRequest.question_slug(qfile.id())
    if slug == None:
        pmt.recieve(pmt.fail(pmt.hi("There is no question with id {} or have a network error".format(qfile.id())), "x"))
        return False
    pmt.recieve(pmt.succ(pmt.hi("Successfully get the slug \"{}\".".format(slug)), "v"))
    pmt.pending(pmt.hi("Requesting a details of question \"{}\"".format(slug)))
    ques = LeetCodeQuestion(slug, testcase)
    if ques.is_valid():
        pmt.recieve(pmt.succ(pmt.hi("Successfully received the details \"{}\".".format(slug)), "v"))
    else:
        pmt.recieve(pmt.fail(pmt.hi("There is a network error \"{}\".".format(slug)), "v"))
        return False

    pmt.pending(pmt.hi("Generating the template: ") + slug)
    src = ques.template("This file is generated by {}".format(os.path.basename(__file__)),
                        70)
    pmt.recieve(pmt.succ(pmt.hi("Generated the template!"), "+"))

    if not os.path.isdir(qfile.path()):
        os.makedirs(qfile.path())
        pmt.show(pmt.succ(pmt.hi("The directory has been created: ") + str(qfile.path()),"+"))

    generate.file(qfile.src().resolve(), src)
    subprocess.run(["open", qfile.src()])

    return True


def __parser():
    parser = optparse.OptionParser(usage="%prog [options] id1 id2 ...")
    parser.add_option("-o", "--out",
                      dest="output",
                      action="store",
                      default=".",
                      metavar=" Source_Path",
                      help="The directory where files are generated")
    parser.add_option("-q", "--question-list",
                      dest="list",
                      action="store",
                      default="./questions_list.csv",
                      metavar=" Question_Lists_File")
    parser.add_option("-l", "--question-log",
                      dest="log",
                      action="store",
                      default="./logs.csv",
                      metavar=" Question_Logs_File")
    parser.add_option("-n", "--no-testcase",
                      dest="testcase",
                      action="store_true",
                      default=False,
                      metavar=" Question_Logs_File")
    parser.add_option("--timestamp",
                      dest="timestamp",
                      action="store",
                      default=int(time.time()),
                      metavar=" Question_Logs_File")
    return parser


def __main():
    parser = __parser()
    options, args = parser.parse_args()

    if len(args) == 0:
        pmt.show("Usage: {} [options] id1 id2 ...".format(
            os.path.basename(__file__)))
        return

    sour_path = pathlib.Path(options.output).resolve()
    list_csv = pathlib.Path(options.list).resolve()
    log_csv = pathlib.Path(options.log).resolve()
    timestamp = int(options.timestamp)
    testcase = not options.testcase

    modify_subunittest: set = set()
    question_added = False

    for id in args:
        qfile = local.QuestionSource(int(id), sour_path)

        if __add_question(qfile, testcase):
            modify.log(log_csv.resolve(), qfile.id(), timestamp)
            modify_subunittest.add(qfile.interval())
            question_added = True
        else:
            pmt.show(pmt.fail(pmt.hi("Failed to generate question #{}!".format(qfile.id())), "x"))

    if question_added:
        if not os.path.exists(list_csv):
            pmt.pending(pmt.hi("Requesting the question list"))
            question_list = LeetCodeRequest.questions()
            pmt.recieve(pmt.succ(pmt.hi("Successfully received the question list."), "v"))
            generate.question_list(list_csv.resolve(), question_list)
        solved = local.solved_question_ids(sour_path)
        modify.done_question(list_csv.resolve(), solved)


if __name__ == "__main__":
    __main()
